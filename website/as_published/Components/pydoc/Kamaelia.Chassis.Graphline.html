<html>
<head>
<title> Components/pydoc/Kamaelia.Chassis.Graphline </title>
<link rel=stylesheet type="text/css" href="/newcss.css">
  </head>
<body style="font-size: 10pt; font-family: verdana,arial,helvetica,sans-serif; line-height: 1.8;">
</div>

</span></p>

<div id="centreinbrowser">
    <table><tr><td>
        <div id="contentwrapper">
            <div id="contentpanel">
                <div class="column twoC largertext">  &nbsp; </div>
                <div class="column twoC largertext">  &nbsp;  </div>
                <div class="column twoC largertext"> <P class="orange" align="center">  <b><a href="/Home.html"> Home</a></b> </div>
                <div class="column twoC largertext"> 
<P class="orange" align="center"> 
<b><a href="/About.html" class="smallertext">About</a>, 
<a href="/Sitemap.html" class="smallertext">Index</a>, 
<a href="/RecentChanges.html" class="smallertext">Changes</a></b>
  </div>
                <div class="column twoC largertext"> <P class="orange" align="center">  <b> <a href="/Developers/">Developers</a> </b> </div>
                <div class="column last twoC"> <P class="orange" align="center"> 
<b>
   <span class="largertext"><a href="/UserLogin.html">Login</a>/<a href="/UserRegistration.html">Register</a> </span> 
  </b>
 </div>

<div class="divide"></div>
                <div id="masthead">
                    &nbsp;
                    <br>
                </div>
                <div class="fourC column">
                    &nbsp;
                </div>
                <div class="fourC column">
                    &nbsp;
                </div>
                <div class="fourC column last">
                    &nbsp;
                </div>
<div class="divide"></div>
                <div class="twelveC column"> 
                <html>
<head>
<title>Kamaelia docs : Kamaelia.Chassis.Graphline</title>
<style type="test/css">
pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }
</style>
</head>
<body>
<div class="container">
<div class="section">
<h1><a class="reference" href="/Components/pydoc/Kamaelia.html">Kamaelia</a>.<a class="reference" href="/Components/pydoc/Kamaelia.Chassis.html">Chassis</a>.<a class="reference" href="/Components/pydoc/Kamaelia.Chassis.Graphline.html">Graphline</a></h1>
</div>
<div class="section">
<div class="container">
<ul class="simple">
<li><strong>component <a class="reference" href="/Components/pydoc/Kamaelia.Chassis.Graphline.Graphline.html">Graphline</a></strong></li>
</ul>
</div>
<ul class="simple">
<li><a class="reference" href="#283">Wiring up components in a topology</a><ul>
<li><a class="reference" href="#284">Example Usage</a><ul>
</ul>
</li>
<li><a class="reference" href="#285">Shutdown Examples</a><ul>
</ul>
</li>
<li><a class="reference" href="#286">How does it work?</a><ul>
</ul>
</li>
<li><a class="reference" href="#287">Shutdown Handling</a><ul>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#288">Test documentation</a><ul>
</ul>
</li>
</ul>
</div>
<div class="section">
<h1 id="283">Wiring up components in a topology</h1>
<p>The Graphline component wires up a set of components and encapsulates them as a
single component. They are wired up to each other using the 'graph' of linkages
that you specify.</p>
<div class="section">
<h2 id="284"><a id="example-usage" name="example-usage">Example Usage</a></h2>
<p>Joining a PromtedFileReader and a rate control component to make a file reader
that reads at a given rate:</p>
<pre class="literal-block">
return Graphline(RC  = ByteRate_RequestControl(**rateargs),
                 RFA = PromptedFileReader(filename, readmode),
                 linkages = { (&quot;RC&quot;,  &quot;outbox&quot;)  : (&quot;RFA&quot;, &quot;inbox&quot;),
                             (&quot;RFA&quot;, &quot;outbox&quot;)  : (&quot;self&quot;, &quot;outbox&quot;),
                             (&quot;RFA&quot;, &quot;signal&quot;)  : (&quot;RC&quot;,  &quot;control&quot;),
                             (&quot;RC&quot;,  &quot;signal&quot;)  : (&quot;self&quot;, &quot;signal&quot;),
                             (&quot;self&quot;, &quot;control&quot;) : (&quot;RFA&quot;, &quot;control&quot;)
                             }
</pre>
<p>The references to 'self' create linkages that passes through a named inbox on
the graphline to a named inbox of one of the child components. Similarly a
child's outbox is pass-through to a named outbox on the graphline.</p>
</div>
<div class="section">
<h2 id="285"><a id="shutdown-examples" name="shutdown-examples">Shutdown Examples</a></h2>
<p>In this example:</p>
<ul class="simple">
<li>Pinger is a component that sends the messages from &quot;tosend&quot; after with a
brief delay between messages. It sends the messages out of the stated outbox.</li>
<li>Waiter is a component that starts up, and then waits for any message sent
to its inbox &quot;control&quot;</li>
<li>Whinger is a component that complains that it is running periodically, but
will shutdown if it receives any message on its inbox &quot;control&quot;</li>
</ul>
<p>As a result, this example creates 3 components inside a graphline that wait
for shutdown. The Pinger sends a message, which is duplicated to all the
subcomponents, at which point in time, they shutdown, causing the system to
shutdown:</p>
<pre class="literal-block">
Pipeline(
    Pinger(tosend=[<a class="reference" href="/Docs/Axon/Axon.Ipc.producerFinished.html">Axon.Ipc.producerFinished</a>()],box=&quot;signal&quot;),
    Graphline(
        TO_SHUTDOWN1 = Waiter(),
        TO_SHUTDOWN2 = Waiter(),
        TO_SHUTDOWN3 = Waiter(),
        linkages = {}
    ),
    Whinger(),
).run()
</pre>
<p>Note: the shutdown message propogates all the way through the system to the
whinger, which then also shuts down.</p>
<p>Full code for this is in ./Examples/UsingChassis/Graphline/DemoShutdown.py</p>
<p>You can also still have shutdown links between components. If you do, then
the Graphline doesn't interfere with them:</p>
<pre class="literal-block">
Pipeline(
    Pinger(tosend=[<a class="reference" href="/Docs/Axon/Axon.Ipc.producerFinished.html">Axon.Ipc.producerFinished</a>()],box=&quot;signal&quot;),
    Graphline(
        TO_SHUTDOWN1 = Waiter(),
        TO_SHUTDOWN2 = Waiter(),
        TO_SHUTDOWN3 = Waiter(),
        linkages = {
            (&quot;TO_SHUTDOWN1&quot;,&quot;signal&quot;):(&quot;TO_SHUTDOWN2&quot;,&quot;control&quot;),
            (&quot;TO_SHUTDOWN2&quot;,&quot;signal&quot;):(&quot;TO_SHUTDOWN3&quot;,&quot;control&quot;),
        }
    ),
    Whinger(),
).run()
</pre>
<p>Full code for this is in ./Examples/UsingChassis/Graphline/LinkedShutdown.py</p>
</div>
<div class="section">
<h2 id="286"><a id="how-does-it-work" name="how-does-it-work">How does it work?</a></h2>
<p>A Graphline component gives you a way of wiring up a system of components and
then encapsulating th ewhole as a single component, with its own inboxes and
outboxes.</p>
<p>The components you specify are registered as children of the Graphline
component. When you activate the component, all the child components are
activated, and the linkages you specified are created between them.</p>
<p>When specifying linkages, the component 'name' is the string version of the
argument name you used to refer to the component. In the example above, the
components are therefore referred to as &quot;RC&quot; and &quot;RFA&quot;.</p>
<p>If the name you specify is not one of the components you specify, then it is
assumed you must be referring to the Graphline component itself. In the above
example, &quot;self&quot; is used to make this clear. This gives you a way of passing data
in and out of the system of components you have specified.</p>
<p>In these cases, it is assumed you wish to create a pass-through linkage - you
want the Graphline component to forward the named inbox to a child's inbox, or
to forward a child's outbox to a named outbox of the Graphline. For example:</p>
<pre class="literal-block">
Graphline( child = MyComponent(...),
           linkages = { ...
                        (&quot;self&quot;, &quot;inbox&quot;) : (&quot;child&quot;, &quot;bar&quot;),
                        ... }
         )
</pre>
<p>... is interpreted as meaning you want to forward the &quot;inbox&quot; inbox of the
Graphline to the &quot;bar&quot; inbox of the component referred to as &quot;child&quot;.
Similarly:</p>
<pre class="literal-block">
Graphline( child = MyComponent(...),
           linkages = { ...
                        (&quot;child&quot;, &quot;fwibble&quot;) : (&quot;self&quot;, &quot;outbox&quot;),
                        ... }
         )
</pre>
<p>...is interpreted as wishing to forward the &quot;fwibble&quot; outbox of the component
referred to as &quot;child&quot; to the &quot;outbox&quot; outbox of the Graphline component.</p>
<p>Any inbox or outbox you name on the Graphline component is created if it does
not already exist. For example, you might want the Graphline to have a &quot;video&quot;
and an &quot;audio&quot; inbox:</p>
<pre class="literal-block">
Graphline( videoHandler = MyVideoComponent(),
           audioHandler = MyAudioComponent(),
           linkages = { ...
                        (&quot;self&quot;, &quot;video&quot;) : (&quot;videoHandler&quot;, &quot;inbox&quot;),
                        (&quot;self&quot;, &quot;audio&quot;) : (&quot;audioHandler&quot;, &quot;inbox&quot;),
                        ...
                      }
         )
</pre>
<p>The Graphline component will always have inboxes &quot;inbox&quot; and &quot;control&quot; and
outboxes &quot;outbox&quot; and &quot;signal&quot;, even if you do not specify any linkages to them.</p>
<p>During runtime, the Graphline component monitors the child components. It will
terminate if, and only if, <em>all</em> the child components have also terminated.</p>
<p>NOTE that if your child components create additional components themselves, the
Graphline component will not know about them. It only monitors the components it
was originally told about.</p>
<p>Graphline does not GENERALLY intercept any of its inboxes or outboxes. It
ignores whatever traffic flows through them. If you have specified linkages
from them to components inside the graphline, then the data automatically
flows to/from them as you specified.</p>
</div>
<div class="section">
<h2 id="287"><a id="shutdown-handling" name="shutdown-handling">Shutdown Handling</a></h2>
<p>There is however an exception: shutdown handling, where the difference is
light touch, which is this:</p>
<pre class="literal-block">
while not self.childrenDone():
     always pass on messages from our control to appropriate sub-component's control
     if message is shutdown, set shutdown flag

# then after loop

if no component-has-linkage-to-graphline's signal
     if shutdown flag set:
         pass on shutdownMicroprocess
     else:
         pass on producerFinished
</pre>
<p>If the user has wired up the graphline's control box to pass through to one
of their components, then that request is honoured, and the user then
becomes wholly responsible for shutdown.</p>
</div>
<h1 id="288">Test documentation</h1>
<p>Tests passed:</p>
<ul class="simple">
<li>Children are activated as soon as the Graphline itself is activated, but no sooner. They get activated even if they have no linkages specified to them.</li>
<li>Children are activated as soon as the Graphline itself is activated, but no sooner. They get activated even if they have no linkages specified to them.</li>
<li>If a graphline's &quot;signal&quot; outbox is specified to be wired to a child component, the graphline will send any messages itself out of its &quot;signal&quot; outbox, before or after all children have terminated, even if a shutdownMicroprocess or producerFinished message was sent to its &quot;control&quot; inbox.</li>
<li>When all children have terminated. If no child is wired to the Graphline's &quot;signal&quot; outbox, the Graphline will send out its own message. The message sent will be a producerFinished message if a child is wired to the Graphline's &quot;control&quot; inbox, or if no shutdownMicroprocess message has been previously received on that inbox.</li>
<li>When all children have terminated. If no child is wired to the Graphline's &quot;signal&quot; outbox, the Graphline will send out its own message. If no child is wired to the Graphline's &quot;control&quot; inbox and a shutdownMicroprocess message has been previously received on that inbox, then the message sent out will be that shutdownMicroprocess message.</li>
<li>Instantiating with components as named arguments, and specifying an empty linkages argument succeeds</li>
<li>Instantiating a graphline, components specified as named arguments, eg. A=component() and B=component() become children of the graphline once activated and run.</li>
<li>Instantiating with no components as named arguments, and specifying an empty linkages argument succeeds</li>
<li>Instantiating with components as named arguments, but specifying no linkages argument results in a ValueError exception</li>
<li>A linkage from &quot;outbox&quot; to &quot;inbox&quot; between two named child components &quot;A&quot; and &quot;B&quot; can be specified by specifying a &quot;linkages&quot; argument containing a dictionary with an entry: (&quot;A&quot;,&quot;outbox&quot;):(&quot;B&quot;,&quot;inbox&quot;). Data sent to A's &quot;outbox&quot;  will reach B's &quot;inbox&quot; and nowhere else.</li>
<li>If a graphline's &quot;control&quot; inbox and &quot;signal&quot; outbox are both specified to be wired to child components in the graphline, then graphline will not emit its own messages out of its &quot;signal&quot; outbox when it terminates (or at any other time)</li>
<li>If a graphline's &quot;control&quot; inbox and &quot;signal&quot; outbox are not specified to be wired to a child component in the graphline then, if a shutdownMicroprocess message is sent to the &quot;control&quot; inbox, it will be sent on out of the &quot;signal&quot; outbox once all children have terminated.</li>
<li>If a graphline's &quot;control&quot; inbox and &quot;signal&quot; outbox are not specified to be wired to a child component in the graphline then, if a any non shutdownMicroprocess message is sent to the &quot;control&quot; inbox, a producerFinished message will be sent on out of the &quot;signal&quot; outbox once all children have terminated.</li>
<li>If a graphline's &quot;control&quot; inbox is specified to be wired to a child component, but its &quot;signal&quot; outbox is not then, irrespective of what message (eg. shutdownMicroprocess) is sent to the &quot;control&quot; inbox, a producerFinished message will be sent on out of the &quot;signal&quot; outbox once all children have terminated.</li>
<li>If a graphline's &quot;control&quot; inbox is not specified to be wired to a child component in the graphline, then any message (including shutdown messages) flows to the &quot;control&quot; inbox of all children without linkages going to their &quot;control&quot; inbox only.</li>
<li>If a graphline's &quot;control&quot; inbox is specified to be wired to a child component in the graphline, then any message (including shutdown messages) flow along that linkage only.</li>
<li>Several linkages can be specified between components. They will all be created, and messages will be able to flow along them once the graphline is activated and run. Data will only flow along the specified linkages and will not leak anywhere else!</li>
<li>Instantiating a graphline with no arguments results in a ValueError exception</li>
<li>If a linkage is specified whose source is (X, &quot;inbox&quot;) or (X, &quot;control&quot;) where X is not the name given to one of the child components in the graphline, then the linkage created is a passthrough from that named inbox of the graphline to the specified destination child component in the graphline.</li>
<li>If a linkage is specified whose source is (X, Y) where X is not the name given to one of the child components in the graphline and Y is neither &quot;inbox&quot; nor &quot;control&quot;, then an inbox with name Y is created and the linkage created is a passthrough from that named inbox of the graphline to the specified destination child component in the graphline.</li>
<li>If a linkage is specified whose destination is (X, &quot;outbox&quot;) or (X, &quot;signal&quot;) where X is not the name given to one of the child components in the graphline, then the linkage created is a passthrough from the specified source child component in the graphline to that named outbox of the graphline.</li>
<li>If a linkage is specified whose destination is (X, Y) where X is not the name given to one of the child components in the graphline and Y is neither &quot;outbox&quot; nor &quot;signal&quot;, then  an outbox with name Y is created and the linkage created is a passthrough from the specified source child component in the graphline to that named outbox of the graphline.</li>
<li>Graphline will terminate when all of its children have terminated, but not before.</li>
<li>Instantiating a graphline, components specified as named arguments, eg. A=component() and B=component() will not be children of the graphline before it is activated and run</li>
</ul>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="reference" href="/Components/pydoc/Kamaelia.html">Kamaelia</a>.<a class="reference" href="/Components/pydoc/Kamaelia.Chassis.html">Chassis</a>.<a class="reference" href="/Components/pydoc/Kamaelia.Chassis.Graphline.html">Graphline</a>.<a class="reference" href="/Components/pydoc/Kamaelia.Chassis.Graphline.Graphline.html">Graphline</a></h1>
<div class="section">
<h2 id="symbol-Graphline">class Graphline(<a class="reference" href="/Docs/Axon/Axon.Component.component.html">Axon.Component.component</a>)</h2>
<p>Graphline(linkages,**components) -&gt; new Graphline component</p>
<p>Encapsulates the specified set of components and wires them up with the
specified linkages.</p>
<p>Keyword arguments:</p>
<ul class="simple">
<li>linkages    -- dictionary mapping (&quot;componentname&quot;,&quot;boxname&quot;) to (&quot;componentname&quot;,&quot;boxname&quot;)</li>
<li>components  -- dictionary mapping names to component instances (default is nothing)</li>
</ul>
<div class="section">
<h3><a id="symbol-Graphline.Inboxes" name="symbol-Graphline.Inboxes">Inboxes</a></h3>
<ul class="simple">
<li><strong>control</strong> : </li>
<li><strong>inbox</strong> : </li>
</ul>
</div>
<div class="section">
<h3><a id="symbol-Graphline.Outboxes" name="symbol-Graphline.Outboxes">Outboxes</a></h3>
<ul class="simple">
<li><strong>outbox</strong> : </li>
<li><strong>signal</strong> : </li>
<li><strong>_cs</strong> : For signaling to subcomponents shutdown</li>
</ul>
</div>
<div class="section">
<h3>Methods defined here</h3>
<div class="container">
<div style="float: right; border: solid;" class="twoC"> <p><strong>Warning!</strong></p>
<p>You should be using the inbox/outbox interface, not these methods (except construction). This documentation is designed as a roadmap as to their functionalilty for maintainers and new component developers.</p>
</div></div>
<div class="section">
<h4><a id="symbol-Graphline.__init__" name="symbol-Graphline.__init__">__init__(self, linkages, **components)</a></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
</div>
<div class="section">
<h4><a id="symbol-Graphline.addExternalPostboxes" name="symbol-Graphline.addExternalPostboxes">addExternalPostboxes(self)</a></h4>
<p>Adds to self.Inboxes and self.Outboxes any postboxes mentioned in self.layout that don't yet exist</p>
</div>
<div class="section">
<h4><a id="symbol-Graphline.childrenDone" name="symbol-Graphline.childrenDone">childrenDone(self)</a></h4>
<p>Unplugs any children that have terminated, and returns true if there are no
running child components left (ie. their microproceses have finished)</p>
</div>
<div class="section">
<h4><a id="symbol-Graphline.main" name="symbol-Graphline.main">main(self)</a></h4>
<p>Main loop.</p>
</div>
</div>
<div class="section">
</div>
</div>
</div>
</div>





<div class="section">
<h1>Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be clearer?
Want to help improve it? Constructive criticism is very welcome - especially if you can suggest a better rewording!</p>
<p>Please leave you feedback
<a class="reference" href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701">here</a>
in reply to the documentation thread in the Kamaelia blog.</p>
</div>


<p><i>-- Automatic documentation generator, 05 Jun 2009 at 03:01:38 UTC/GMT</i>
</body></html>

                </div> 
                <div id="footer">
                    &nbsp;
                    <br>&nbsp;
                </div>


<div class="divide"></div>
            </div>
        </div>
    </td></tr></table>


<hr>
<div id="aboutblock" style="text-align: left"; padding-left: 1em;>
<font size="-2">
   <P><img src="http://www.kamaelia.org/images/BBC-ResearchLogo-Small.png"
style="float: left; padding-right: 10px; margin-bottom: 3em;"> <a href="http://www.kamaelia.org/Home>5D">Kamaelia</a>
    is an open source project originated from and guided by BBC
    Research. For more information browse the site or get in 
    <a href="/Contact.html">contact</a>.
   <P>This is an ongoing community based development site. As a result the
   contents of this page is the opinions of the contributors of the pages
   involved not the organisations involved. Specificially, this page may
   contain personal views which are not the views of the BBC. (the site is
   powered by a wiki engine)
   <P>(C) Copyright 2008 Kamaelia Contributors, including the British
   Broadcasting Corporation, All Rights Reserved.
</font>
</div>
</div>
<div style="display:none">
This web site is powered by the same code created for the
<a href="http://www.bickermanor.org/"> bicker manor</a> project. For more
details, contact Michael Sparks at BBC Research directly (cf contact)
</div>
</body>
</html>



