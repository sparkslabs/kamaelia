<html>
<head>
<title> CookbookTransclude </title>
<meta name="description" content="Kamaelia - making concurrency simpler in python - CookbookTransclude">
<meta name="keywords" content="python concurrency generators threads processes component system experts beginners media networking">
<link rel=stylesheet type="text/css" href="/newcss.css">
  </head>
<body style="font-size: 10pt; font-family: verdana,arial,helvetica,sans-serif; line-height: 1.8;">
</div>

</span></p>

<div id="centreinbrowser">
    <table><tr><td>
        <div id="contentwrapper">
            <div id="contentpanel">
                <div class="column twoC largertext">  &nbsp; </div>
                <div class="column twoC largertext">  &nbsp;  </div>
                <div class="column twoC largertext"> <P class="orange" align="center">  <b><a href="/Home.html"> Home</a></b> </div>
                <div class="column twoC largertext"> 
<P class="orange" align="center"> 
<b><a href="/About.html" class="smallertext">About</a>, 
<a href="/Sitemap.html" class="smallertext">Index</a>, 
<a href="/RecentChanges.html" class="smallertext">Changes</a></b>
  </div>
                <div class="column twoC largertext"> <P class="orange" align="center">  <b> <a href="/Developers/">Developers</a> </b> </div>
                <div class="column last twoC"> <P class="orange" align="center"> 
<b>
<span class="largertext">&nbsp;</span>
<!--   <span class="largertext"><a href="/UserLogin.html">Login</a>/<a href="/UserRegistration.html">Register</a> </span>  -->
<!--  </b> -->
</b>
 </div>

<div class="divide"></div>
                <div id="masthead">
                    &nbsp;
                    <br>
                </div>
                <div class="fourC column">
                    &nbsp;
                </div>
                <div class="fourC column">
                    &nbsp;
                </div>
                <div class="fourC column last">
                    &nbsp;
                </div>
<div class="divide"></div>
                <div class="twoC column">
                    &nbsp;
                </div>
                <div class="eightC column">
                
<meta name="qrichtext" content="1">
<p><span style="font-size: 24pt; font-weight: 600;">Cookbook</span></p>
<p align="right"><span style="font-size: 18pt;">How can I...?</span></p>
<p><div style="float: right; border: solid;" class="twoC"><b></b>Other ways of using Kamaelia<br></p>

<ul><li><a href="../../../Cookbook/LikeFile">Using Kamaelia concurrently in other systems</a> </div></li></ul><p>This section contains a number of examples in a number of different application areas. These are all included in the Kamaelia distribution, but are provided here for convenience. See also the  <a href="/Docs/.html">documentation</a> in the older structure.</p>
<p>Last Editted: Patrick, 03 Aug 2007 <br></p>
<h3>Linking components together</h3>



<h1>Cookbook : Pipelines and Graphlines</h1><div style="float: right; border: solid;" class="twoC"> <b> Discussion </b> Please discuss this on <a href='http://www.kamaelia.org/CookbookTranscludeDiscuss'> the discussion page </a> for this page  </div>Fairly early on you'll want a quick an easy way to link your components together. To actually build a useful system you need to set up linkages to get data from one component's outbox to another component's inbox. <a href='/Cookbook/Pipelines'> <b>Pipelines</b> </a> and <a href='/Cookbook/Graphlines'> <b>Graphlines</b> </a> are the two simplest and most common ways of doing this.<br><br><div style="float: right; border: solid;" class="twoC"> Find out more about using Pipelines <a href='/Cookbook/Pipelines'> here</a> </div> Pipeline and Graphline are, themselves, components. Pipeline wires components together in a long chain. For example:<br>
<blockquote>
  <pre>from Kamaelia.Chassis.Pipeline import Pipeline<br><br>from Kamaelia.Internet.Multicast_transceiver import Multicast_transceiver<br>from Kamaelia.Protocol.SimpleReliableMulticast import SRM_Sender<br>from Kamaelia.Protocol.Packetise import MaxSizePacketiser<br><br>Pipeline( RateControlledFileReader("myaudio.mp3",readmode="bytes",rate=128000/8),<br>          SRM_Sender(),<br>          MaxSizePacketiser(),<br>          Multicast_transceiver("0.0.0.0", 0, "224.168.2.9", 1600),<br>        ).run()<br></pre>
</blockquote>
<div style="float: right; border: solid;" class="twoC"> Find out more about Graphlines <a href='/Cookbook/Graphlines'> here</a> </div> Whereas a Graphline wires components together in any way you want - you specify each individual link. For example:<br><pre style="margin-left: 40px;">from Kamaelia.UI.Pygame.Button import Button<br>from Kamaelia.UI.Pygame.Image import Image<br><br>from Kamaelia.Util.Chooser import Chooser<br><br>from Kamaelia.Chassis.Graphline import Graphline<br><br>files = [ "slide1.gif", "slide2.gif", .... "slide99.gif" ]<br><br>Graphline(<br>     CHOOSER  = Chooser(files),<br>     IMAGE    = Image(size=(800,600), position=(8,48)),<br>     NEXT     = Button(caption="Next",     msg="NEXT", position=(72,8)  ),<br>     PREVIOUS = Button(caption="Previous", msg="PREV" ,position=(8,8)   ),<br>     FIRST    = Button(caption="First",    msg="FIRST",position=(256,8) ),<br>     LAST     = Button(caption="Last",     msg="LAST" ,position=(320,8) ),<br>     linkages = {<br>        ("NEXT",     "outbox") : ("CHOOSER", "inbox"),<br>        ("PREVIOUS", "outbox") : ("CHOOSER", "inbox"),<br>        ("FIRST",    "outbox") : ("CHOOSER", "inbox"),<br>        ("LAST",     "outbox") : ("CHOOSER", "inbox"),<br><br>        ("CHOOSER",  "outbox") : ("IMAGE",   "inbox"),<br>     }<br>).run()<br><br></pre><p>-- 17 Dec 2006 - Matt Hammond<br></p><br> 








<h1>Cookbook : Pipelines</h1>Pipelines are one of the simplest ways to wire components together. A Pipeline wires components together in a long chain.<br><br>Here's a simple pipeline we want to build that sends a file over multicast, using a simple protocol to ensure reliable transmission:<br><br><div align="center"><img src="/images/pipeline1_idea.gif" alt="We want to wire a set of components together in a long chain (a pipeline)"></div><br>We could build this by writing a new component with a whole bunch of self.link() calls to link each outbox to the next inbox. But that is a lot of code to write and rather tedious! ... surely there must be an easier way?<br><br>... And so the Pipeline component comes to the rescue! No need to write a whole new component, simply use a Pipeline component like this:<br><blockquote><pre><font color="#000000">from Kamaelia.Chassis.Pipeline import Pipeline<br><br>from Kamaelia.Internet.Multicast_transceiver import Multicast_transceiver<br>from Kamaelia.Protocol.SimpleReliableMulticast import Annotator<br>from Kamaelia.Protocol.SimpleReliableMulticast import _Framer<br>from Kamaelia.Protocol.SimpleReliableMulticast import _DataChunker<br>from Kamaelia.Protocol.Packetise import MaxSizePacketiser</font><br>from Kamaelia.File.Reading import RateControlledFileReader<br><br><font color="#000000"><b>Pipeline( RateControlledFileReader("myaudio.mp3",readmode="bytes",rate=128000/8),<br>          Annotator(),<br>          _Framer(),<br>          _DataChunker(),<br>          MaxSizePacketiser(),<br>          Multicast_transceiver("0.0.0.0", 0, "224.168.2.9", 1600),<br>        ).run()</b></font><br></pre></blockquote><p>You can find this code in <tt> Kamaelia/Examples/Multicast/SimpleReliableMulticast </tt><br></p><p>So what did Pipeline actually do?</p><p align="center"><img src="/images/pipeline1_intention.gif" alt="Pipeline component does this for us"></p>It
wires the components into a chain inside itself - linking outboxes to
inboxes. When we call the run() method, the Kamaelia system starts, and
the pipeline component is activated. It in turn, activates all the
components inside.<br><h3>How are the components linked together?</h3><div style="float: right; border: solid;" class="twoC"> <b>Just like unix pipes</b><br>
"inbox"
and "outbox" are a lot like standard-input and standard-output for
command line programs. When you pipe programs together on a unix shell,
the standard-output of one program gets sent to the standard-input of
the next.<br>
<br>
"control" and "signal" are analogous to standard-error. In practice Kamaelia components use it to signal when they are finished.<br>
</div><br>
More specifically, Pipeline links one component to the next in the chain. It links the "outbox" and "signal" outboxes of one component to the "inbox" and "control" inboxes on the next one:<br><ul><li>The
"inbox" and "outbox" boxes are the ones most components use to take in
and send out data. So for example, whatever the RateControlledFileReader
component reads gets sent to the Annotator component.<br><br> </li><li>The
"control" and "signal" boxes are used to send the shutdown message when
a component has finished, and wants to tell the next.</li></ul>So, if we look at precisely what linkages are made, we see something like this:<br><br><div align="center"><img src="/images/pipeline1_inside.gif" alt="Pipeline component links " outbox="" inbox="" and="" signal="" to="" control=""></div><br><h3>Pipeline is a component too ... time to go modular!<br></h3>The Pipeline also links its own inboxes and outboxes to the
start and the end (respectively) of the chain. Pipeline is, after all, a
component too, so it makes sense to be able to send and receive messages to/from the pipeline of components within
using its inboxes and outboxes. Think of it as a kind of container.<br><br>You can therefore use a Pipeline as a way to wrap up a useful pipelined set of components into a single bundle that you can then reuse elsewhere.<br><br>For
example, we could separate the components that make the multicast reliability protocol into another Pipeline, and simply include it like another component:<br><blockquote><pre>Pipeline( RateControlledFileReader("myaudio.mp3",readmode="bytes",rate=128000/8),<br>          <b>Pipeline( Annotator(),<br></b>                     <b>_Framer(),<br></b>                     <b>_DataChunker(),<br></b>                   <b>),</b><br>          MaxSizePacketiser(),<br>          Multicast_transceiver("0.0.0.0", 0, "224.168.2.9", 1600),<br>        ).run()<br></pre></blockquote>We don't have to call the run() or activate() method of the inner pipeline since, just like the other components, they'll all be activated by the main pipeline when it starts.<br><br>In fact, we could actually move that into a completely separate function, that simply returns the pipeline:<br><blockquote><pre>def SRM_Sender():<br>   return Pipeline( Annotator(),<br>                    _Framer(),<br>                    _DataChunker(),<br>                  )<br></pre></blockquote><p>Now we can call that function to put the sub pipeline into the chain:<br></p><blockquote><pre>Pipeline( RateControlledFileReader("myaudio.mp3",readmode="bytes",rate=128000/8),<br>          <b>SRM_Sender(),</b><br>          MaxSizePacketiser(),<br>          Multicast_transceiver("0.0.0.0", 0, "224.168.2.9", 1600),<br>        ).run()</pre></blockquote>We can now, for the most part, use SRM_Sender just like any other component.<br><br>This hopefully makes the design of the system more modular and clearer, and also give us a re-usable
component for applying our multicast reliability protocol - which we previously didn't
have. In fact, this has already been done so you can simply import it and use it:<br><blockquote><pre><b>from Kamaelia.Protocol.SimpleReliableMulticast import SRM_Sender</b><br><br>Pipeline( RateControlledFileReader("myaudio.mp3",readmode="bytes",rate=128000/8),<br>          SRM_Sender(),<br>          MaxSizePacketiser(),<br>          Multicast_transceiver("0.0.0.0", 0, "224.168.2.9", 1600),<br>        ).run()</pre></blockquote><h3>Need more flexibility?</h3>Pipelines are not the only quick and easy way to link up components. Perhaps you need to make different links? Try a <a href='/Cookbook/Graphlines '> Graphline </a> instead.<br><br>-- 18 Dec 2006 - Matt Hammond<br><br>
 



<h1>Cookbook : Graphlines</h1>
<p>A Graphline provides a flexible way to link inboxes and outboxes in any way you wish.
Whereas a Pipeline constrains your components to be wired into ... a
pipeline ... with Graphline you specify each link explicitly.</p><p>Suppose we want to build a simple slideshow application, where pygame Button components control a Chooser component that sends filenames for each slide to a pygame Image display component:</p><p align="center"><img src="/images/graphline1_idea.gif"></p><p>We could build this by writing a new component with a whole bunch of
self.link() calls to link each outbox to the next inbox. But that is a
lot of code to write and rather tedious! ... surely there must be an
easier way?<br><br>... You need the graphline component! No need to write a whole new component, simply use a Graphline
component like this:</p><pre style="margin-left: 40px;">from Kamaelia.Chassis.Graphline import Graphline<br><br>from Kamaelia.UI.Pygame.Button import Button<br>from Kamaelia.UI.Pygame.Image import Image<br>from Kamaelia.Util.Chooser import Chooser<br><br>files = [ "slide1.gif", "slide2.gif", .... "slide99.gif" ]<br><br>Graphline(<br>     CHOOSER  = Chooser(files),<br>     IMAGE    = Image(size=(800,600), position=(8,48)),<br>     NEXT     = Button(caption="Next",     msg="NEXT", position=(72,8)  ),<br>     PREVIOUS = Button(caption="Previous", msg="PREV" ,position=(8,8)   ),<br>     FIRST    = Button(caption="First",    msg="FIRST",position=(256,8) ),<br>     LAST     = Button(caption="Last",     msg="LAST" ,position=(320,8) ),<br><br>     linkages = {<br>        ("NEXT",     "outbox") : ("CHOOSER", "inbox"),<br>        ("PREVIOUS", "outbox") : ("CHOOSER", "inbox"),<br>        ("FIRST",    "outbox") : ("CHOOSER", "inbox"),<br>        ("LAST",     "outbox") : ("CHOOSER", "inbox"),<br><br>        ("CHOOSER",  "outbox") : ("IMAGE",   "inbox"),<br>     }<br>).run()<br></pre><p>What you see here is slightly abridged for clarity. You can find the full version in <tt>
Kamaelia/Examples/SimpleGraphicalApps/Slideshows </tt></p><p>What did we just do? Simple:</p><ol><li>Write each component as a named argument<br><pre style="margin-left: 40px;">     CHOOSER  = Chooser(files),<br>     IMAGE    = Image(size=(800,600), position=(8,48)),<br>     NEXT     = Button(caption="Next",     msg="NEXT", position=(72,8)  ),<br>     PREVIOUS = Button(caption="Previous", msg="PREV" ,position=(8,8)   ),<br>     FIRST    = Button(caption="First",    msg="FIRST",position=(256,8) ),<br>     LAST     = Button(caption="Last",     msg="LAST" ,position=(320,8) ),<br></pre><br></li><li>...then write the linkages you want as the 'linkages' argument in a dictionary:<br><pre style="margin-left: 40px;">     linkages = {<br>        ("NEXT",     "outbox") : ("CHOOSER", "inbox"),<br>        ("PREVIOUS", "outbox") : ("CHOOSER", "inbox"),<br>        ("FIRST",    "outbox") : ("CHOOSER", "inbox"),<br>        ("LAST",     "outbox") : ("CHOOSER", "inbox"),<br><br>        ("CHOOSER",  "outbox") : ("IMAGE",   "inbox"),<br>     }</pre></li></ol><p>For each linkage we want, we write a mapping in the dictionary from a (component, outbox) to a (component, inbox) We refer to the components by the names we just gave them, as strings. We reference the inboxes and outboxes by their names too.</p><p>So, for example: <br></p><pre style="margin-left: 40px;">("NEXT","outbox") : ("CHOOSER","inbox")</pre>specifies that you want the "outbox" outbox of the "Next" Button to be linked to the "inbox" inbox of the Chooser.<br><br><h3>Making links to the outside world<br></h3>So the Graphline defined above wires up the Chooser, Image and 4 Button components inside itself - like Pipeline it is a kind of container:<br><div align="center"><img src="/images/graphline1_intention.gif"><br></div><br>If we look in more detail, the links made are actually like this:<br><br><div style="text-align: center;"><img src="../../../images/graphline1_inside.gif" alt="A diagram showing how the components inside the example graphline are linked up"></div><br>Just like the Pipeline component, a Graphline has its own inboxes and
outboxes. You can specify links to and from these by using the empty
string to name the component.<br><br>For example, we might want to be able to send instructions to the Chooser from outside this graphline, in which case we would add this to the set of linkages:<br><pre style="margin-left: 40px;">        ("", "inbox") : ("NEXT", "inbox"),<br></pre>By using a name for a component that we've not used (in this case simply the empty string suffices) we're telling Graphline to use its own inbox.<br><br>We could do the same for outboxes too if we want. For example, we could ask for the outbox of the Image component to be linked to the Graphline's outbox:<br><pre style="margin-left: 40px;">        ("IMAGE", "outbox") : ("",     "outbox"),<br></pre>In fact, if you also refer to an inbox or outbox name for the Graphline that does not exist. Graphline will simply create it. This means you can use a Graphline as a container, giving it whatever inboxes and outboxes you need - not just the 'standard' ones that most components have.<br><br>Just
like with Pipeline, Graphline is a fully fledged component itself, so
you can put a Graphline inside a Pipeline, or a Pipeline inside a
Graphline, or any other combination you care to choose. Again, it can
be a good way of making your system more modular, by separating off a
little group of components into a separate functional unit.<br><p>
</p> 



<blockquote><br></blockquote><h1>Cookbook : Carousels</h1>
<p>So you've built your components and wired them up using  <a href='/Cookbook/Pipelines '> Pipelines </a> and <a href='/Cookbook/Graphlines '> Graphlines </a>. But what do you do if you want to create or initialise a component at runtime?</p><p>Perhaps you can't know the value of some arguments until you start reading that input file. Or maybe you want to process several streams of data in sequence, but the component you want to use isn't designed to process several streams back to back. This is where a component like the <i>Carousel</i> comes in.</p>The Carousel gives us a way to create a component on-the-fly in response to being sent a message.<br><h3>For example...</h3>Suppose we want to play an MP3 file ... we could use a simple pipeline like this:<br><blockquote><pre>from Kamaelia.File.Reading import RateControlledFileReader<br>from Kamaelia.Audio.Codec.PyMedia.Decoder import Decoder<br>from Kamaelia.Audio.PyMedia.Output import Output<br>from Kamaelia.Chassis.Pipeline import Pipeline<br><br>import sy<filename>s<br>mp3filename=sys.argv[1]<br></filename></pre><pre><filename>Pipeline( RateControlledFileReader( mp3filename, readmode="bytes", rate=256000/8),<br>          Decoder("mp3"),<br>          Output(sample_rate=44100, channels=2, format="S16_LE"),<br>        ).run()<br></filename></pre></blockquote><br>That is all very nice; but what if we get the sample rate, number of channels or format wrong? We can't get this information until we start decoding it. If we get it wrong then the audio may be corrupted or played at the wrong speed!<br><br>It would be great if, at runtime, we could create the audio playback (Output) component in response to receiving a message from the MP3 decoder containing the audio format:<br><br><div align="center"><img src="/images/carousel1_idea.gif"><br></div><br>The PyMedia MP3 Decoder component we are using helpfully sends out a message containing the information we need, so we can use the Carousel component to do it like this:<br><blockquote><pre>from Kamaelia.Chassis.Graphline import Graphline<br>from Kamaelia.Chassis.Carousel import Carousel<br><br><filename>def makeAudioOutput(metadata):<br>    return Output( metadata["sample_rate"],<br>                   metadata["channels"],<br>                   metadata["format"]<br>                 )</filename></pre><pre><filename></filename></pre><pre><filename>Graphline( READ = RateControlledFileReader( mp3filename, readmode="bytes", rate=256000/8),<br>           DECODE = Decoder("mp3"),<br>           <b>OUTPUT = Carousel( makeAudioOutput ),</b><br>           linkages = {<br>               ("READ",   "outbox") : ("DECODE", "inbox"),</filename><br>              <filename> ("DECODE", "outbox") : ("OUTPUT", "inbox"),</filename>
<filename>               <b>("DECODE", "format") : ("OUTPUT", "next"),</b></filename><br><br>              <filename> ("READ",   "signal") : ("DECODE", "control"),<br>               ("DECODE", "signal") : ("OUTPUT", "control"),<br>           }<br>         ).run()<br></filename></pre></blockquote><p><filename>This example is wired up using a Graphline component - find out more about Graphlines <a href='/Cookbook/Graphlines '> here </a>.<br></filename></p><p><filename></filename></p><h3><filename>So what does this do?</filename></h3><h3><filename></filename></h3><p><filename>The MP3 Decoder component we are using helpfully sends out the format of the decoded audio out of its "format" outbox, so we link this to the Carousel's "next" inbox to control it. A message from the decoder wil look like this:<br></filename></p><blockquote><pre><filename>{ "sample_rate" : 44100, "channels":2, "format":"S16_LE" }<br></filename></pre></blockquote><p>We've also written a function makeAudioOutput(). When called with the message as its argument; it returns a new
Output component set up with the right sample rate, number of
channels, and format.</p><p>We give this function to the Carousel. Note
that we don't call it - we just give it the function. The Carousel
calls it when it receives a message on its "next" inbox and therefore needs to create the component:</p><filename><br></filename><div align="center"><img src="/images/carousel_anim.gif"></div><filename><br></filename><ol><li><filename>The Carousel receives a message on its "next" inbox, containing the format of the audio<br></filename></li><li><filename>The Carousel calls our <i>makeAudioOutput</i> function, passing it this message as its parameter<br></filename></li><li><filename>Our function returns a new Output component, ready to be used.<br></filename></li><li>Carousel links the new Output component up to use its own inboxes and outboxes</li></ol>So when the raw audio samples start to arrive at its inbox, there will be a new Output component already linked in to receive them.<br>Note that it does not link the "signal" outbox - this is so that when the component finishes and sends its own shutdown message, this doesn't get passed on - after all, you might want to reuse the Carousel with another component.<br><h3><filename>So why is it called a "Carousel" then?</filename></h3><h3><filename></filename></h3><filename>If you send another message to the "next" inbox, then the component gets replaced. Any existing component is told to shutdown and is thrown away as soon as possible, and a new one is created, by calling our function with the new message as the parameter.<br><br>This kind of behaviour is a little like the carousel on an old slide projector - when you want to move on, the old item is swapped for the next one. Alternatively think of a fairground merry-go-round carousel - where one horse comes by after another.<br></filename><filename><br>For example, suppose we want to improve our MP3 player by making it play multiple files back to back. We could put everything in a Carousel, then when it has finished, it could send us a message. We could then respond by sending it the next filename to play, and letting it start again. Something like this:<br></filename><div align="center"><img src="/images/carousel_anim2.gif"><br><div align="left"><p>We can do this by using a Chooser component for the playlist and putting our existing player inside a Carousel. When all the player components finish, our Carousel will send out a "next" message from its "requestNext" outbox, which we can use to cause our Chooser to send back the next filename:</p><p align="center"><img src="/images/carousel3.gif"></p><p>Notice that we can also wire up the "signal" and "control" boxes, so that when the Chooser has no more names in its playlist, it can tell our player Carousel to shut down.<br></p><p>So now lets build this! First, lets make a function that we will give to the Carousel for it to use to create our player:<br></p><blockquote><pre><filename>def makePlayer(mp3filename):<br>    return Graphline(<br>        READ = RateControlledFileReader( mp3filename, readmode="bytes", rate=256000/8),<br>        DECODE = Decoder("mp3"),<br>        OUTPUT = Carousel( makeAudioOutput ),<br>        linkages = {<br>            ("READ",   "outbox") : ("DECODE", "inbox"),</filename><br>           <filename> ("DECODE", "outbox") : ("OUTPUT", "inbox"),</filename><br><filename>            ("DECODE", "format") : ("OUTPUT", "next"),</filename><br><br>            ("",      "control") : ("READ",   "control"),<br>           <filename> ("READ",   "signal") : ("DECODE", "control"),<br>            ("DECODE", "signal") : ("OUTPUT", "control"),<br>            ("OUTPUT", "signal") : ("",       "signal"),<br>        }<br>      )<br></filename></pre></blockquote><p> </p></div></div><filename>This is almost identical to our player from before. Notice we've added extra links to make sure shutdown messages can get into and out of the Graphline. This is important, as Carousel will be listening for our Graphline sending the shutdown message.<br><br>Now lets wire it all up! We will use a <i>ForwardIteratingChooser</i> because it will send a shutdown message once all the filenames have been iterated over:<br></filename><blockquote><pre><filename>from Kamaelia.Util.Chooser import ForwardIteratingChooser<br><br>filenames = argv[1:]<br><br>Graphline( PLAYLIST = </filename>ForwardIterating<filename>Chooser(filenames),<br>           PLAYER   = Carousel( makePlayer, <b>make1stRequest=True</b> ),<br>           linkages = {<br>               ("PLAYER",   "requestNext") : ("PLAYLIST", "inbox"),<br>               ("PLAYLIST", "outbox")      : ("PLAYER",   "next"),<br><br>               ("PLAYLIST", "signal") : ("PLAYER", "control"),<br>           }<br>         ).run()<br></filename></pre></blockquote><blockquote><pre><filename></filename></pre></blockquote><filename>Notice that we have asked the Carousel to make the 1st request. What this means is that as soon as it starts it will send out its request for the next item - instead of just waiting. This gets things going.<br><br>So there we have it, a simple mp3 playlist system, built entirely in Kamaelia, using Carousels to create components with the right settings when we need them.<br></filename><p>-- 19 Dec 2006 - Matt Hammond<br>
</p> 



<h1>Cookbook : Backplanes</h1><p>Backplanes provide an easy way to distribute data from many sources to many destinations. For example<br></p><h3>Serving to multiple clients<br></h3><p>For example, perhaps we want to build a server where each client that connects receives a copy of a stream of data - perhaps the current time. First, lets create our source of time data:</p><blockquote><pre>from Axon.ThreadedComponent import threadedcomponent<br>import time<br><br>class TimeTick(threadedcomponent):<br>    def main(self):<br>        prev=""<br>        while 1:<br>            now = time.asctime() + "\n"<br>            if now!=prev:<br>                self.send(now, "outbox")<br>                prev=now<br>            else:<br>                self.pause(0.1)</pre></blockquote>We're going to use SimpleServer to provide a simple TCP server to clients. Every time a client connects, we could make a new, private instance of TimeTick to handle that client. Alternatively we could make a single TimeTick component that sends (publishes) its messages to a Backplane:<br><br><blockquote><pre>from Kamaelia.Util.Backplane import Backplane<br>from Kamaelia.Util.Backplane import PublishTo<br>from Kamaelia.Chassis.Pipeline import Pipeline<br><br>Backplane("TIME").activate()<br><br>Pipeline( TimeTick(),<br>          PublishTo("TIME"),<br>        ).activate()</pre></blockquote><p>Then for each client that connects, we ask SimpleServer to make a component that fetches (subscribes) from that same backplane:<br><br></p><blockquote><pre>from Kamaelia.Util.Backplane import SubscribeTo<br>from Kamaelia.Chassis.ConnectedServer import SimpleServer<br><br>SimpleServer(protocol=lambda : SubscribeTo("TIME"), port=1500).run()</pre></blockquote><p></p><h3>So what's going on?<br></h3>Notice we've named the Backplane "TIME" to distinguish it from other Backplanes. You can therefore have as many Backplanes in a system as you like. The SubscribeTo and PublishTo components connect to the right backplane because they look it up (by the name) using the Coordinating Assistant Tracker (CAT). Once the subscribers and publishers are all linked up, you get something like this:<br><br><div align="center"><img src="/images/backplane1.gif" alt="PublishTo components send data to the Backplane. The Backplane then sends it onto ALL SubscribeTo components subscribed to it." align="middle"><br></div><br>PublishTo components send anything that arrives at their "inbox" inbox onto the Backplane. SubscribeTo components talk to the backplane and send on anything they receive from it to their "outbox" outbox. The Backplane itself acts like a splitter component - anything it receives is sent onto all outputs; in this case - all subscribers.<br><h3>Couldn't we have done that more simply?<br></h3><p>For a really simple example like this, there is little or no benefit of doing it this way ... in fact, it might seem like unnecessary extra effort and components! However, the real power is that all the clients are sharing the same data source.</p><h3>A simple relay server<br></h3><p>Perhaps, for example, our source of data is actually coming from another server (say "foo.bar.com" on port 1600). Using a backplane, its easy to build a relay server capable of replicating the data to multiple clients:</p><blockquote><pre>from Kamaelia.Internet.TCPClient import TCPClient<br><br>Pipeline( TCPClient("foo.bar.com", port=1600),<br>          PublishTo("DATA"),<br>        ).activate()<br><br></pre><pre>Backplane("DATA").activate()<br><br>SimpleServer(protocol=lambda : SubscribeTo("DATA"), port=1600).run()</pre></blockquote><h3>An aggregating logger...<br></h3><p>Backplanes aren't just useful for distributing data in a one-to-many fashion; they can also be used for many-to-one or many-to-many. For example, we can use a Backplane to build a logging server capable of logging, to a single file, data received from multiple clients. In effect, a simple aggregating logger:</p><blockquote><pre>from Kamaelia.Visualisation.PhysicsGraph.chunks_to_lines import chunks_to_lines<br>from Kamaelia.File.Writing import SimpleFileWriter<br><br>def sendToBackplane():<br>    return Pipeline( chunks_to_lines(),<br>                      PublishTo("LOGGER"),<br>                    )<br><br>SimpleServer(protocol=sendToBackplane, port=1500).activate()<br><br>Pipeline( SubscribeTo("LOGGER"),<br>          SimpleFileWriter("log.data"),<br>        ).activate()<br><br>Backplane("LOGGER").run()</pre></blockquote><h3>...that can also be a relay<br></h3><p>Because we use a Backplane and a SimpleServer chassis, the client connections are not hard wired - clients can connect and disconnect whenever they choose. In fact, we could extend this further, by allowing clients to connect on a different port to receive a live stream of the aggregated logging data:</p><blockquote><pre>SimpleServer(protocol=SubscribeTo("LOGGER"), port=1501).activate()<br><br></pre></blockquote><p>Our aggregating logger is now also a relay, using the backplane to distribute messages from many sources to many destinations.</p><br>-- Jan 2007, Matt<br> 

<h3>Build TCP Based Clients and Servers</h3>










<meta name="qrichtext" content="1">
<p><span style="font-size: 24pt; font-weight: 600;">Cookbook Example</span></p>
<p align="right"><span style="font-size: 18pt;">How can I...?</span></p>
<p>Example 1: Building a Simple TCP Based Server that allows multiple connections at once and sends a fortune cookie to the client. Includes simple TCP based client that displays the fortune cookie. <span style="font-weight: 600;">Components used:  </span><a href="/Components.html/pydoc/Kamaelia.html.Chassis.html.ConnectedServer.html.SimpleServer.html">SimpleServer</a>, <a href="/Components.html/pydoc/Kamaelia.html.Protocol.FortuneCookieProtocol.html.FortuneCookieProtocol.html.html">FortuneCookieProtocol</a>, <a href="/Components.html/pydoc/Kamaelia.html.Chassis.html.Pipeline.html.html">Pipeline</a>, <a href="/Components.html/pydoc/Kamaelia.html.Internet.html.TCPClient.TCPClient.html">TCPClient</a>, <a href="/Components.html/pydoc/Kamaelia.html.Util.html.Console.ConsoleEchoer.html">ConsoleEchoer</a></p>
<p></p>
<ul type="disc"><div><pre><span style="font-style: italic;">#!/usr/bin/python</span><br><br><span style="font-weight: 600;">from</span> Kamaelia.Protocol.FortuneCookieProtocol <span style="font-weight: 600;">import</span> FortuneCookieProtocol<br><span style="font-weight: 600;">from</span> Kamaelia.SimpleServerComponent <span style="font-weight: 600;">import</span> SimpleServer<br><span style="font-weight: 600;">from</span> Kamaelia.Internet.TCPClient <span style="font-weight: 600;">import</span> TCPClient<br><span style="font-weight: 600;">from</span> Kamaelia.Util.Console <span style="font-weight: 600;">import</span> ConsoleEchoer<br><span style="font-weight: 600;">from</span> Kamaelia.Chassis.Pipeline <span style="font-weight: 600;">import</span> Pipeline<br><span style="font-weight: 600;">import</span> random<br><br>clientServerTestPort=random.randint(1500,1599)<br><br>SimpleServer(protocol=FortuneCookieProtocol, port=clientServerTestPort).activate()<br><br>Pipeline(TCPClient("127.0.0.1",clientServerTestPort),<br>         ConsoleEchoer()<br>        ).run()<br></pre></div>
<div><span style="font-weight: 600;">Source:</span> Examples/example1/FortuneCookie_ServerClient.py</div></ul>
<p></p>
<p></p>
<p></p>

 
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:10pt;font-family:URW Gothic L">
<p><span style="font-size:24pt;font-weight:600">Cookbook Example</span></p>
<p align="right"><span style="font-size:18pt">How can I...?</span></p>
<p>Example 2: A Simple TCP Based Server that allows multiple connections at once, but sends a random ogg vorbis file to the client. Includes a simple TCP based client for this server, that connects to the server, decodes the ogg vorbis audio and plays it back. <span style="font-weight:600">Components used: </span><a href="/Components.html/pydoc/Kamaelia.html.Util.html.PipelineComponent.html.pipeline.html">pipeline</a>, <a href="/Components.html/pydoc/Kamaelia.html.Chassis.html.ConnectedServer.html.SimpleServer.html">SimpleServer</a>, <a href="/Components.html/pydoc/Kamaelia.html.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>, <a href="/Components.html/pydoc/Kamaelia.html.Internet.html.TCPClient.TCPClient.html">TCPClient</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.VorbisDecode.html">VorbisDecode</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a></p>
<ul type="disc"><div><pre><span style="font-style:italic">#!/usr/bin/python</span><br /><br /><span style="font-weight:600">from</span> Kamaelia.Util.PipelineComponent <span style="font-weight:600">import</span> pipeline<br /><span style="font-weight:600">from</span> Kamaelia.SimpleServerComponent <span style="font-weight:600">import</span> SimpleServer<br /><span style="font-weight:600">from</span> Kamaelia.Internet.TCPClient <span style="font-weight:600">import</span> TCPClient<br /><span style="font-weight:600">from</span> Kamaelia.vorbisDecodeComponent <span style="font-weight:600">import</span> VorbisDecode, AOAudioPlaybackAdaptor<br /><span style="font-weight:600">import</span> Kamaelia.ReadFileAdaptor<br /><br />file_to_stream = &quot;/usr/share/wesnoth/music/wesnoth-1.ogg&quot;<br />clientServerTestPort=1500<br /><br /><span style="font-weight:600">def</span> AdHocFileProtocolHandler(filename):<br />    <span style="font-weight:600">class</span> klass(Kamaelia.ReadFileAdaptor.ReadFileAdaptor):<br />        <span style="font-weight:600">def</span> __init__(self,*argv,**argd):<br />            <span style="font-weight:600">super</span>(klass,self).__init__(filename, readmode=&quot;bitrate&quot;, bitrate=400000)<br />    <span style="font-weight:600">return</span> klass<br /><br />server=SimpleServer(protocol=AdHocFileProtocolHandler(file_to_stream),<br />                    port=clientServerTestPort).activate()<br /><br />pipeline(<br />   TCPClient(&quot;127.0.0.1&quot;,clientServerTestPort),<br />   VorbisDecode(),<br />   AOAudioPlaybackAdaptor()<br />).run()<br /></pre><br /><span style="font-weight:600">Source: </span>Examples/example2/SimpleStreamingSystem.py</div></ul>
<p></p>
</body></html>
 
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:10pt;font-family:URW Gothic L">
<p><span style="font-size:24pt;font-weight:600">Cookbook Example</span></p>
<p align="right"><span style="font-size:18pt">How can I...?</span></p>
<p>Example 3: Same as example 2, but as separate scripts. <span style="font-weight:600">Components used in server script:</span> <a href="/Components.html/pydoc/Kamaelia.html.Chassis.html.ConnectedServer.html.SimpleServer.html">SimpleServer</a>, <a href="/Components.html/pydoc/Kamaelia.html.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>. <span style="font-weight:600">Components used in client script:</span> <a href="/Components.html/pydoc/Kamaelia.html.Util.html.PipelineComponent.html.pipeline.html">pipeline</a>, <a href="/Components.html/pydoc/Kamaelia.html.Internet.html.TCPClient.TCPClient.html">TCPClient</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.VorbisDecode.html">VorbisDecode</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a> .</p>
<p>Server script</p>
<ul type="disc"><div><pre><span style="font-style:italic">#!/usr/bin/python<br /><br /></span><span style="font-weight:600">import </span>Kamaelia.ReadFileAdaptor<br /><span style="font-weight:600">from</span> Kamaelia.SimpleServerComponent <span style="font-weight:600">import</span> SimpleServer<br /><br />file_to_stream = &quot;/usr/share/wesnoth/music/wesnoth-1.ogg&quot;<br /><br /><span style="font-weight:600">def</span> AdHocFileProtocolHandler(filename):<br />    <span style="font-weight:600">class</span> klass(Kamaelia.ReadFileAdaptor.ReadFileAdaptor):<br />        <span style="font-weight:600">def</span> __init__(self,*argv,**argd):<br />            super(klass,self).__init__(filename, readmode=&quot;bitrate&quot;, bitrate=400000)<br />    <span style="font-weight:600">return</span> klass<br /><br />clientServerTestPort=1500<br />SimpleServer(protocol=AdHocFileProtocolHandler(file_to_stream),<br />             port=clientServerTestPort).run()<br /></pre></div>
<div><span style="font-weight:600">Source: </span>Examples/example3/SimpleStreamer.py</div></ul>
<p></p>
<p>Client script</p>
<ul type="disc"><div><pre><span style="font-style:italic">#!/usr/bin/python</span> <br /><br /><span style="font-weight:600">from</span> Kamaelia.Internet.TCPClient <span style="font-weight:600">import</span> TCPClient<br /><span style="font-weight:600">from</span> Kamaelia.vorbisDecodeComponent <span style="font-weight:600">import</span> VorbisDecode, AOAudioPlaybackAdaptor<br /><span style="font-weight:600">from</span> Kamaelia.Util.PipelineComponent <span style="font-weight:600">import</span> pipeline<br /><br />clientServerTestPort=1500<br />pipeline(TCPClient(&quot;127.0.0.1&quot;,clientServerTestPort),<br />         VorbisDecode(),<br />         AOAudioPlaybackAdaptor()<br />        ).run()<br /></pre><br /><span style="font-weight:600">Source: </span>Examples/example3/SimpleStreamingClient.py</div></ul>
<p></p>
</body></html>
 

<h3>Build Multicast Based Clients and Servers</h3>

<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:10pt;font-family:URW Gothic L">
<p><span style="font-size:24pt;font-weight:600">Cookbook Example</span></p>
<p align="right"><span style="font-size:18pt">How can I...?</span></p>
<p>Example 4: Building a very simplistic multicast based streaming system using ogg vorbis. <span style="font-weight:600">Components used: </span><span style="font-style:italic;color:#ff0004">component</span>, <a href="/Components.html/pydoc/Kamaelia.html.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.VorbisDecode.html">VorbisDecode</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a>, <a href="/Components.html/pydoc/Kamaelia.html.Internet.html.Multicast_transceiver.Multicast_transceiver.html">Multicast_transceiver</a>, <a href="/Components.html/pydoc/Kamaelia.html.Util.html.PipelineComponent.html.pipeline.html">pipeline</a> </p>
<ul type="disc"><div dir="ltr"><pre><span style="font-style:italic">#!/usr/bin/python</span><br /><br /><span style="font-weight:600">from</span> Axon.Component <span style="font-weight:600">import</span> component<br /><span style="font-weight:600">from</span> Kamaelia.ReadFileAdaptor <span style="font-weight:600">import</span> ReadFileAdaptor<br /><span style="font-weight:600">from</span> Kamaelia.vorbisDecodeComponent <span style="font-weight:600">import</span> VorbisDecode, AOAudioPlaybackAdaptor<br /><span style="font-weight:600">from</span> Kamaelia.Internet.Multicast_transceiver <span style="font-weight:600">import</span> Multicast_transceiver<br /><span style="font-weight:600">from</span> Kamaelia.Util.PipelineComponent <span style="font-weight:600">import</span> pipeline<br /><br />file_to_stream = &quot;/usr/share/wesnoth/music/wesnoth-1.ogg&quot;<br /><br /><span style="font-weight:600">class</span> detuple(component):<br />   <span style="font-weight:600">def</span> __init__(self, index):<br />      super(detuple, self).__init__()<br />      self.index = index<br />   <span style="font-weight:600">def</span> main(self):<br />      <span style="font-weight:600">while</span> 1:<br />         <span style="font-weight:600">if</span> self.dataReady(&quot;inbox&quot;):<br />            tuple=self.recv(&quot;inbox&quot;)<br />            self.send(tuple[self.index], &quot;outbox&quot;)<br />         <span style="font-weight:600">yield</span> 1<br /><br /><span style="font-style:italic;font-weight:600"># Server</span><br />pipeline(<br />    ReadFileAdaptor(file_to_stream, readmode=&quot;bitrate&quot;, bitrate=400000, chunkrate=50),<br />    Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600),<br />).activate()<br /><br /><span style="font-style:italic;font-weight:600"># Client</span><br />pipeline(<br />    Multicast_transceiver(&quot;0.0.0.0&quot;, 1600, &quot;224.168.2.9&quot;, 0),<br />    detuple(1),<br />    VorbisDecode(),<br />    AOAudioPlaybackAdaptor(),<br />).run()<br /></pre><br /><span style="font-weight:600">Source:</span> Examples/example4/MulticastStreamingSystem.py</div></ul>
<p></p>
<p></p>
<p></p>
</body></html>
 
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:10pt;font-family:URW Gothic L">
<p><span style="font-size:24pt;font-weight:600">Cookbook Example</span></p>
<p align="right"><span style="font-size:18pt">How can I...?</span></p>
<p dir="ltr">Example 4: Building a very simplistic multicast based streaming system using ogg vorbis. This time using 2 separate scripts. <span style="font-weight:600">Components used in server script: </span><span style="font-style:italic;color:#ff0004">component</span>, <a href="/Components.html/pydoc/Kamaelia.html.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>, <a href="/Components.html/pydoc/Kamaelia.html.Internet.html.Multicast_transceiver.Multicast_transceiver.html">Multicast_transceiver</a>. <span style="font-weight:600">Components used in client script:</span> <span style="font-style:italic;color:#ff0004">component</span>, <a href="/Components.html/pydoc/Kamaelia.html.Internet.html.Multicast_transceiver.Multicast_transceiver.html">Multicast_transceiver</a>, <span style="font-style:italic;color:#ff0004">detuple</span> (defined in the example), <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.VorbisDecode.html">VorbisDecode</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a>. </p>
<p dir="ltr">Server Script, the easy way</p>
<ul type="disc"><div dir="ltr"><pre><span style="font-style:italic">#!/usr/bin/python<br /><br /></span><span style="font-weight:600">from</span> Kamaelia.ReadFileAdaptor <span style="font-weight:600">import</span> ReadFileAdaptor<br /><span style="font-weight:600">from</span> Kamaelia.Internet.Multicast_transceiver <span style="font-weight:600">import</span> Multicast_transceiver<br /><span style="font-weight:600">from</span> Kamaelia.Util.PipelineComponent <span style="font-weight:600">import</span> pipeline<br /><br />file_to_stream = &quot;/usr/share/wesnoth/music/wesnoth-1.ogg&quot;<br /><br />pipeline(<br />    ReadFileAdaptor(file_to_stream, readmode=&quot;bitrate&quot;, bitrate=400000, chunkrate=50),<br />    Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600),<br />).run()<br /></pre></div></ul>
<p dir="ltr"></p>
<p dir="ltr">Server Script, the hard way (but exactly equivalent)</p>
<ul type="disc"><div dir="ltr"><pre><span style="font-style:italic">#!/usr/bin/python</span><br /><br /><span style="font-weight:600">import</span> Axon<br /><br />file_to_stream = &quot;/usr/share/wesnoth/music/wesnoth-1.ogg&quot;<br /><br /><span style="font-weight:600">def</span> tests():<br />   <span style="font-weight:600">from</span> Axon.Scheduler import scheduler<br />   <span style="font-weight:600">import</span> Kamaelia.ReadFileAdaptor<br />   <span style="font-weight:600">from</span> Kamaelia.Internet.Multicast_transceiver <span style="font-weight:600">import</span> Multicast_transceiver<br /><br />   <span style="font-weight:600">class</span> testComponent(Axon.Component.component):<br />      <span style="font-weight:600">def</span> main(self):<br />        source = Kamaelia.ReadFileAdaptor.ReadFileAdaptor(file_to_stream,<br />                                                          readmode=&quot;bitrate&quot;,<br />                                                          bitrate=400000,<br />                                                          chunkrate=50)<br />        sender   = Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600)<br />        self.link((source,&quot;outbox&quot;), (sender,&quot;inbox&quot;))<br /><br />        self.addChildren(source, sender)<br />        <span style="font-weight:600">yield</span> Axon.Ipc.newComponent(*(self.children))<br />        <span style="font-weight:600">while</span> 1:<br />           <span style="font-weight:600">yield</span> 1<br /><br />   harness = testComponent()<br />   harness.activate()<br />   scheduler.run.runThreads(slowmo=0)<br /><br /><span style="font-weight:600">if</span> __name__==&quot;__main__&quot;:<br /><br />    tests()<br /></pre><br /><span style="font-weight:600">Source: </span>Examples/example4/MulticastStreamingServer.py</div></ul>
<p dir="ltr"></p>
<p dir="ltr">Client Script</p>
<ul type="disc"><div dir="ltr"><pre><span style="font-style:italic">#!/usr/bin/python</span><br /><br /><span style="font-weight:600">from</span> Axon.Component <span style="font-weight:600">import</span> component<br /><span style="font-weight:600">from</span> Kamaelia.vorbisDecodeComponent <span style="font-weight:600">import</span> VorbisDecode, AOAudioPlaybackAdaptor<br /><span style="font-weight:600">from</span> Kamaelia.Internet.Multicast_transceiver <span style="font-weight:600">import</span> Multicast_transceiver<br /><span style="font-weight:600">from</span> Kamaelia.Util.PipelineComponent <span style="font-weight:600">import</span> pipeline<br /><br /><span style="font-weight:600">class</span> detuple(component):<br />   <span style="font-weight:600">def</span> __init__(self, index):<br />      super(detuple, self).__init__()<br />      self.index = index<br />   <span style="font-weight:600">def</span> main(self):<br />      <span style="font-weight:600">while</span> 1:<br />         <span style="font-weight:600">if</span> self.dataReady(&quot;inbox&quot;):<br />            tuple=self.recv(&quot;inbox&quot;)<br />            self.send(tuple[self.index], &quot;outbox&quot;)<br />         <span style="font-weight:600">yield</span> 1<br /><br /><span style="font-style:italic;font-weight:600"># Client</span><br />pipeline(<br />    Multicast_transceiver(&quot;0.0.0.0&quot;, 1600, &quot;224.168.2.9&quot;, 0),<br />    detuple(1),<br />    VorbisDecode(),<br />    AOAudioPlaybackAdaptor(),<br />).run()<br /></pre></div></ul>
<p dir="ltr">Client Script, the hard way (but exactly equivalent)</p>
<ul type="disc"><div dir="ltr"><pre><span style="font-style:italic">#!/usr/bin/python</span><br /><br /><span style="font-weight:600">import</span> Axon<br /><br /><span style="font-weight:600">class</span> detuple(Axon.Component.component):<br />   <span style="font-weight:600">def</span> __init__(self, index):<br />      super(detuple,self).__init__()<br />      self.index = index<br />   <span style="font-weight:600">def</span> main(self):<br />      <span style="font-weight:600">while</span> 1:<br />         <span style="font-weight:600">if</span> self.dataReady(&quot;inbox&quot;):<br />            tuple=self.recv(&quot;inbox&quot;)<br />            self.send(tuple[self.index], &quot;outbox&quot;)<br />         <span style="font-weight:600">yield</span> 1<br /><br /><span style="font-weight:600">def</span> tests():<br />   <span style="font-weight:600">from</span> Axon.Scheduler import scheduler<br />   <span style="font-weight:600">import</span> Kamaelia.ReadFileAdaptor<br />   <span style="font-weight:600">from</span> Kamaelia.vorbisDecodeComponent <span style="font-weight:600">import</span> VorbisDecode, AOAudioPlaybackAdaptor<br />   <span style="font-weight:600">from</span> Kamaelia.Internet.Multicast_transceiver <span style="font-weight:600">import</span> Multicast_transceiver<br /><br />   <span style="font-weight:600">class</span> testComponent(Axon.Component.component):<br />      <span style="font-weight:600">def</span> main(self):<br />        receiver = Multicast_transceiver(&quot;0.0.0.0&quot;, 1600, &quot;224.168.2.9&quot;, 0)<br />        detupler = detuple(1)<br />        decoder = VorbisDecode()<br />        player = AOAudioPlaybackAdaptor()<br /><br />        self.link((receiver,&quot;outbox&quot;), (detupler,&quot;inbox&quot;))<br />        self.link((detupler,&quot;outbox&quot;), (decoder,&quot;inbox&quot;))<br />        self.link((decoder,&quot;outbox&quot;), (player,&quot;inbox&quot;))<br /><br />        self.addChildren(receiver, detupler, decoder, player)<br />        <span style="font-weight:600">yield</span> Axon.Ipc.newComponent(*(self.children))<br />        <span style="font-weight:600">while</span> 1:<br />           <span style="font-weight:600">yield</span> 1<br /><br />   harness = testComponent()<br />   harness.activate()<br />   scheduler.run.runThreads(slowmo=0)<br /><br /><span style="font-weight:600">if</span> __name__==&quot;__main__&quot;:<br /><br />    tests()<br /></pre><br /><span style="font-weight:600">Source:</span> Examples/example4/MulticastStreamingClient.py</div></ul>
<p dir="ltr"></p>
<p dir="ltr"></p>
</body></html>
 
<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:10pt;font-family:URW Gothic L">
<p><span style="font-size:24pt;font-weight:600">Cookbook Example</span></p>
<p align="right"><span style="font-size:18pt">How can I...?</span></p>
<p>Example 4: Building some reliability into the system (<a href="/SimpleReliableMulticast.html.html">Simple Reliable Multicast</a>). Idea is to show layering of protocols.<span style="font-weight:600"> Components used: </span><span style="font-style:italic;color:#ff0004">component</span>, <a href="/Components.html/pydoc/Kamaelia.html.ReadFileAdaptor.ReadFileAdaptor.html">ReadFileAdaptor</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.VorbisDecode.html">VorbisDecode</a>, <a href="/Components.html/pydoc/Kamaelia.html.vorbisDecodeComponent.html.AOAudioPlaybackAdaptor.html">AOAudioPlaybackAdaptor</a>, <a href="/Components.html/pydoc/Kamaelia.html.Internet.html.Multicast_transceiver.Multicast_transceiver.html">Multicast_transceiver</a>, <a href="/Components.html/pydoc/Kamaelia.html.Util.html.PipelineComponent.html.pipeline.html">pipeline</a>, <span style="font-style:italic;color:#ff0004">SRM_Sender</span>, <span style="font-style:italic;color:#ff0004">SRM_Receiver</span></p>
<ul type="disc"><div dir="ltr"><pre><span style="font-style:italic">#!/usr/bin/python</span><br /><br /><span style="font-weight:600">from</span> Axon.Component <span style="font-weight:600">import</span> component<br /><span style="font-weight:600">from</span> Kamaelia.ReadFileAdaptor <span style="font-weight:600">import</span> ReadFileAdaptor<br /><span style="font-weight:600">from</span> Kamaelia.vorbisDecodeComponent <span style="font-weight:600">import</span> VorbisDecode, AOAudioPlaybackAdaptor<br /><span style="font-weight:600">from</span> Kamaelia.Internet.Multicast_transceiver <span style="font-weight:600">import</span> Multicast_transceiver<br /><span style="font-weight:600">from</span> Kamaelia.Util.PipelineComponent <span style="font-weight:600">import</span> pipeline<br /><span style="font-weight:600">from</span> Kamaelia.Protocol.SimpleReliableMulticast <span style="font-weight:600">import</span> SRM_Sender, SRM_Receiver<br /><br />file_to_stream = &quot;/usr/share/wesnoth/music/wesnoth-1.ogg&quot;<br /><br /><span style="font-weight:600">class</span> detuple(component):<br />   <span style="font-weight:600">def</span> __init__(self, index):<br />      super(detuple, self).__init__()<br />      self.index = index<br />   <span style="font-weight:600">def</span> main(self):<br />      <span style="font-weight:600">while</span> 1:<br />         <span style="font-weight:600">if</span> self.dataReady(&quot;inbox&quot;):<br />            tuple=self.recv(&quot;inbox&quot;)<br />            self.send(tuple[self.index], &quot;outbox&quot;)<br />         <span style="font-weight:600">yield</span> 1<br /><br /><span style="font-weight:600">class</span> blockise(component):<br />    <span style="font-weight:600">def</span> main(self):<br />       maxlen = 1000 # Needs to be parameterisable<br />       buffer = &quot;&quot;<br />       <span style="font-weight:600">while</span> 1:<br />           <span style="font-weight:600">if</span> self.dataReady(&quot;inbox&quot;):<br />               buffer = buffer + self.recv(&quot;inbox&quot;)<br />               <span style="font-weight:600">if</span> len(buffer) &gt; maxlen:<br />                  send = buffer[:maxlen]<br />                  buffer = buffer[maxlen:]<br />               <span style="font-weight:600">else</span>:<br />                  send = buffer<br />                  buffer = &quot;&quot;<br />               self.send(send, &quot;outbox&quot;)<br />           <span style="font-weight:600">yield</span> 1<br /><br /><span style="font-style:italic;font-weight:600">#<br /># Server with simple added reliabilty protocol<br />#<br /></span>pipeline(<br />    ReadFileAdaptor(file_to_stream, readmode=&quot;bitrate&quot;, bitrate=400000, chunkrate=50),<br /><span style="font-weight:600">    SRM_Sender(),<br />    blockise(), # Ensure chunks small enough for multicasting!<br /></span>    Multicast_transceiver(&quot;0.0.0.0&quot;, 0, &quot;224.168.2.9&quot;, 1600),<br />).activate()<br /><br /><span style="font-style:italic;font-weight:600">#<br /># Client with simple added reliability protocol<br />#<br /></span>pipeline(<br />    Multicast_transceiver(&quot;0.0.0.0&quot;, 1600, &quot;224.168.2.9&quot;, 0),<br />    detuple(1),<br /><span style="font-weight:600">    SRM_Receiver(),<br />    detuple(1),<br /></span>    VorbisDecode(),<br />    AOAudioPlaybackAdaptor(),<br />).run()<br /></pre><br /><span style="font-weight:600">Source: </span>Examples/example4/MulticastStreamingSystem_SRM.py</div></ul>
<p></p>
</body></html>
 

<h3>Create UDP Based Systems<span style="font-weight: 600;"></span></h3><ul><li><span style="font-weight: 600;"></span><a href="/Examples/UDPSimplePeerExample.html.html">UDPSimplePeerExample</a><br></li></ul>
<h3>Build tools for System Visualisation and Introspection</h3><ul><li><a href="/Examples/IntrospectingASimpleStreamingSystem.html.html">IntrospectingASimpleStreamingSystem</a></li><li><a href="/Examples/NetworkControllableGraphViewer.html.html">NetworkControllableGraphViewer</a></li><li><a href="/Examples/BuildingACustomisedTopologyViewer.html.html">BuildingACustomisedTopologyViewer</a><br></li></ul>
<h3>Build Multimedia Applications<span style="font-weight: 600;"></span></h3><ul><li><span style="font-weight: 600;"></span><a href="/Examples/SimplestPresentationTool.html.html">SimplestPresentationTool</a></li><li><a href="/Examples/TopologySlideshowComponent.html.html">TopologySlideshowComponent</a></li><li><a href="/Examples/TopologyAndSlidesPresentationTool.html.html">TopologyAndSlidesPresentationTool</a></li><li><a href="/Examples/SimpleTextTickerDemonstration.html.html">SimpleTextTickerDemonstration</a><br></li></ul>
<h3>Working with Open GL</h3><i>Coming soon! (<a href="http://svn.sourceforge.net/viewvc/kamaelia/trunk/Code/Python/Kamaelia/Examples/SoC2006/THF/">open GL examples already in subversion here</a></i><i>)</i><br><h3>Write Games<span style="font-weight: 600;"></span></h3><ul><li><span style="font-weight: 600;"></span><a href="Examples/SimpleBouncingCatsGame.html">SimpleBouncingCatsGame</a></li></ul>
<h3>Work with Audio and Video<span style="font-weight: 600;"></span></h3><ul><li><a href="/Examples/SimplestPossibleDiracVideoPlayer.html.html">SimplestPossibleDiracVideoPlayer</a></li><li><a href="/Examples/DiracVideoEncodeAndDecodeChain.html.html">DiracVideoEncodeAndDecodeChain</a></li><li><a href="/Examples/SimpleStreamerWithPlaylistCapability.html.html">SimpleStreamerWithPlaylistCapability</a></li><li><a href="/Examples/SimpleClientForSavingContentsOfTCPStream.html.html">SimpleClientForSavingContentsOfTCPStream</a><span style="font-weight: 600;"></span></li></ul><h3>Working with HTTP</h3><ul><li><a href="/Cookbook.html.html/HTTPServer.html">HTTPServer</a> - How can I integrate a <b>web server</b> into my system? This is a relatively low level component, but does form a base for doing lots of interesting things.</li><li><a href="/Cookbook.html.html/HTTPClient.html">HTTPClient</a> - How can I integrate a <b>web client</b> into my system? <b>How can I deal with RSS feeds?</b><br></li></ul><h3>Working with BitTorrent</h3><ul><li><a href="Cookbook/SimpleBitTorrentExample">SimpleBitTorrentExample</a></li></ul><h3>Working with AIM</h3><ul><li><a href="Cookbook/AIM">Simple AIM client with Pygame</a></li></ul><h3>Working with IRC<br></h3><ul><li><a href="/Cookbook.html.html/IRCClient.html">IRCClient</a></li></ul><h3>Receiving and recording DVB broadcasts</h3><ul><li><a href="../../../Cookbook/DVB/TransportStreamCapture">TransportStreamCapture</a> - how can I capture an entire transport stream? (a DVB multiplex puts multiple channels inside a transport stream)<br></li><li><a href="../../../Cookbook/DVB/TransportStreamDemuxer">TransportStreamDemuxer</a> - how can I work with <b>multiple channels</b> from a transport stream? (yes, you can deal with more than one at a time easily :)<br></li><li><a href="../../../Cookbook/DVB/SingleChannelTransportStreamCapture">SingleChannelTransportStreamCapture</a> - How can I work with a <b>single channel</b> from a transport stream?<br></li><li><a href="../../../Cookbook/DVB/RecordNamedChannel">RecordNamedChannel</a> - Numbers numbers numbers! I want to record BBC ONE! How can I use <b>named channels</b> ?<br></li><li><a style="" href="../../../Cookbook/DVB/PersonalVideoRecorder">PersonalVideoRecorder</a> - How can I record <b>named programmes</b> from a specific channel? (without even specifying the time ? :-)<br></li></ul><hr size="2" width="100%">As an aside, I don't think the rounded boxes idea here was working very well. In theory it was nice, but the actual resulting layout sucked in practice. As a result I've reverted to something more traditional. If anyone has a better idea, please change to that :-) -- Michael, 10 Feb 2007<br><br><br>








                </div>
                <div class="twoC column last">
                    &nbsp;
                </div>
                <div id="footer">
                    &nbsp;
                    <br>&nbsp;
                </div>


<div class="divide"></div>
            </div>
        </div>
    </td></tr></table>


<hr>
<div id="aboutblock" style="text-align: left"; padding-left: 1em;>
<font size="-2">
   <P><img src="http://www.kamaelia.org/images/BBC-ResearchLogo-Small.png"
style="float: left; padding-right: 10px; margin-bottom: 3em;"> <a href="http://www.kamaelia.org/Home.html">Kamaelia</a>
    is an open source project originated from and guided by <a href="http://www.bbc.co.uk/rd"> BBC 
    Research</a>. For more information browse the site or get in 
    <a href="/Contact.html">contact</a>.
   <P>This is an ongoing community based development site. As a result the
   contents of this page is the opinions of the contributors of the pages
   involved not the organisations involved. Specificially, this page may
   contain personal views which are not the views of the BBC. (the site is
   powered by a wiki engine)
   <P>(C) Copyright 2008 Kamaelia Contributors, including the British
   Broadcasting Corporation, All Rights Reserved
</font>
</div>
</div>
<div style="display:none">
This web site is powered by the same code created for the
<a href="http://www.bickermanor.org/"> bicker manor</a> project. For more
details, contact Michael Sparks at BBC Research directly (cf contact)
</div>
</body>
</html>



