<html>
<head>
<title> InheritableDefaultValues </title>
<meta name="description" content="Kamaelia - making concurrency simpler in python - InheritableDefaultValues">
<meta name="keywords" content="python concurrency generators threads processes component system experts beginners media networking">
<link rel=stylesheet type="text/css" href="/newcss.css">
  </head>
<body style="font-size: 10pt; font-family: verdana,arial,helvetica,sans-serif; line-height: 1.8;">
</div>

</span></p>

<div id="centreinbrowser">
    <table><tr><td>
        <div id="contentwrapper">
            <div id="contentpanel">
                <div class="column twoC largertext">  &nbsp; </div>
                <div class="column twoC largertext">  &nbsp;  </div>
                <div class="column twoC largertext"> <P class="orange" align="center">  <b><a href="/Home.html"> Home</a></b> </div>
                <div class="column twoC largertext"> 
<P class="orange" align="center"> 
<b><a href="/About.html" class="smallertext">About</a>, 
<a href="/Sitemap.html" class="smallertext">Index</a>, 
<a href="/RecentChanges.html" class="smallertext">Changes</a></b>
  </div>
                <div class="column twoC largertext"> <P class="orange" align="center">  <b> <a href="/Developers/">Developers</a> </b> </div>
                <div class="column last twoC"> <P class="orange" align="center"> 
<b>
<span class="largertext">&nbsp;</span>
<!--   <span class="largertext"><a href="/UserLogin.html">Login</a>/<a href="/UserRegistration.html">Register</a> </span>  -->
<!--  </b> -->
</b>
 </div>

<div class="divide"></div>
                <div id="masthead">
                    &nbsp;
                    <br>
                </div>
                <div class="fourC column">
                    &nbsp;
                </div>
                <div class="fourC column">
                    &nbsp;
                </div>
                <div class="fourC column last">
                    &nbsp;
                </div>
<div class="divide"></div>
                <div class="twoC column">
                    &nbsp;
                </div>
                <div class="eightC column">
                




























<h1>Inheritable Default Values</h1><div align="right"><b>Making systemic specialisation more declarative</b><br></div>This feature was introduced in Axon 1.6.0 (Kamaelia 0.6.0)<br><br>The idea behind this is to allow a more compact, declarative way of defining more complex Kamaelia systems. It stemmed initially from an observation that two of us wanted to do this:<br><br><blockquote><pre>def ReusableSocketAddrServer(port=100,<br>                       protocol=EchoProtocol):<br>    return ServerCore(protocol=protocol,<br>                      port=port,<br>                      socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1))</pre></blockquote><br>Specifically we noticed that we were creating a fair number of factory functions which only really differed based on on value. The problem we have here is that this is relatively fragile. Specifically, what happens if ServerCore adds in extra arguments - do we also update ReusableSocketAddrServer ? What if we don't, does someone else come along and duplicate our code in order to support those extra arguments? OK, well we can handle this in python if we use the **argd syntax. If we do that, we can do that this way:<br><blockquote><pre>def ReusableSocketAddr(**argd):<br>    argd_local = dict(argd)<br>    argd_local["socketOptions"] = (socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br>    return ServerCore(**argd_local)</pre></blockquote>
Whilst that's maybe more reflective of what we wanted to do, it now looks rather obscured. We then realised that there is a useful side effect of python namespaces that we can take advantage of, which is this:<br><ul><li>self.attribute first of all looks inside the object self. If this is not found...</li><li>self.attribute looks inside self.__class__ . If that's not found,</li><li>self.attribute looks inside the parents of self.__class__ all the way up.</li><ul><li>This is kinda necessary to make (self.method) work, so it can be relied upon.</li></ul></ul>This means that if we change the base component class to do this:<br><blockquote><pre>def __init__(self, **argd):<br>     self.__dict__.update(argd)</pre></blockquote>Then we can do this:<br><blockquote><pre>class ReusableSocketAttrServer(ServerCore):<br>    socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  </pre></blockquote>This has a number of advantages over the factory method:<br><ul><li>First and foremost it makes it very clear that this is just a ServerCore that happens to have different socketOptions.</li><li>Secondly it means that if the parent component (ServerCore) adds extra arguments into the initialiser, we'll pick those up automagically.</li><li>Thirdly, it encourages us to provide more things into the class namespace, which actually assists with testing, but also makes the system more flexible.</li></ul>For example, suppose the component we're using creates components as a part of it's operation, and we want to add tracing to these. Normally that code would default to looking like this:<br><br><blockquote><pre>from import Kamaelia.Internet.TCPServer import TCPServer<br><br>class ServerCore(...):<br>...<br><br>    def initialiseComponent(self):<br>...<br>            myPLS = TCPServer(listenport=self.listenport)</pre><b>Hypothetical File: </b>ExamplePatch.py<br></blockquote>
<br>Replacing TCPServer here with our TracedTCPServer would have to look like this:<br><br><blockquote><pre>from Hypothetical import TracedTCPServer<br>import ExamplePatch<br>ExamplePatch.TCPServer = TracedTCPServer<br></pre><b>Hypothetical File: </b>ExamplePatchUser.py<br></blockquote>
The downside of this as well is that this is not particularly targetted, and leads to the situation where it would be more natural to create a copy of the code for traced versions. This misses one of the handy features of what inheritance gives us, which is controlled duplication of functionality with little twists of functionality. By comparison, with inheritable default values, we can do this instead:<br><br><blockquote>
  <pre>from import Kamaelia.Internet.TCPServer import TCPServer<br><br>class ServerCore(...):<br>    TCPS = TCPServer<br>    def initialiseComponent(self):<br>...<br>            TCPServer = self.TCPS<br>            myPLS = TCPServer(listenport=self.listenport)</pre>
  <b>Hypothetical File: </b>ExamplePatch.py<br>
</blockquote>

However, when someone wants to create a traced version they can be far more to the point. Suppose they have code that looks like this:<br>ServerCore(port = 1500, protocol=WhizzyProto1).run()<br><br>They can change it over to use the hypothetical TracedTCPServer like this:<br><blockquote><pre>from Hypothetical import TracedTCPServer<br><br>ServerCore(port = 1500, protocol=WhizzyProto1, TCPS=TracedTCPServer).run()<br><b><br></b></pre><p><b>Hypothetical File: </b>ExamplePatchUser.py</p><pre></pre></blockquote><br>Not only that, but if they wanted to define this as a common thing they wanted to do, they could do this:<br><blockquote><pre>class TracedServerCore(ServerCore):<br>     TCPS = TracedTCPServer</pre></blockquote>Which would then get used:<br><blockquote><pre>TracedServerCore(port = 1500, protocol=WhizzyProto1).run()</pre></blockquote>Whilst this seems theoretical, it was bandied about as a possible idea for nearly a year until it suddenly became extremely useful - specifically in the <a href="/KamaeliaGrey.html">greylisting code</a> to allow it to use inactivity timers on connected sockets, as well as configuration of protocol handlers in a declarative manner:<br><blockquote><pre>class GreylistServer(ServerCore):<br>    logfile = config["greylist_log"]<br>    debuglogfile = config["greylist_debuglog"]<br>    socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br>    port = config["port"]<br>    class TCPS(TCPServer):<br>        CSA = NoActivityTimeout(ConnectedSocketAdeapter, timeout=config["inactivity_timeout"], debug=False)<br>    class protocol(GreyListingPolicy):<br>        servername = config["servername"]<br>        serverid = config["serverid"]<br>        smtp_ip = config["smtp_ip"]<br>        smtp_port = config["smtp_port"]<br>        allowed_senders = config["allowed_senders"]<br>        allowed_sender_nets = config["allowed_sender_nets"] # Yes, only class C network style<br>        allowed_domains = config["allowed_domains"]<br>        whitelisted_triples = config["whitelisted_triples"]<br>        whitelisted_nonstandard_triples = config["whitelisted_nonstandard_triples"]<br></pre></blockquote>Since then the idiom has been found to be useful in other scenarios.<br><br>It's also worth noticing that this also means that the ServerCore code could be repurposed to work with servers that act in a similar way to TCPServer. For example, a hypothetical ConnectionBasedUDPListener, could be created which operated in a similar manner to TCPServer, and then reused as follows:<br><blockquote><pre>class UDPServerCore(ServerCore):<br>     TCPS = ConnectionBasedUDPListener</pre></blockquote>Thereby making it as simple to create connection oriented UDP servers as it would be to create TCPServers. The only difference between the two being lack of guarantee of ordering or delivery.<br><h2>Downsides?</h2>The clear downside of this is that the signature of your component's generally initialiser becomes this:<br><blockquote><pre>def __init__(self, **argd):<br> ...</pre></blockquote>This in turn puts a greater onus on you as a component writer to document the arguments to your component in a clearer manner.<br><br><h2>But WHY???</h2>This is an implicit thing. <b>In Kamaelia when syntactic sugar gets added</b> (and that's precisely what this is),<b> one of the most common aims is to aim to move towards a declarative reusable syntax.</b> After all, if you consider that the starting point was this:<br><blockquote><pre>def ReusableSocketAddrServer(port=100,<br>                       protocol=EchoProtocol):<br>    return ServerCore(protocol=protocol,<br>                      port=port,<br>                      socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1))</pre></blockquote>You're actually starting off with something very fragile, especially considering that if ServerCore changes it's configuration, you have to change this factory function as well.<br><br>Secondly, the next approach for dealing with changing __init__ialiser arguments is to use **argd, you then end up with something which is a bit perl-ish in structure, and obfuscates what's really going on:<br><blockquote><pre>def ReusableSocketAddr(**argd):<br>    argd_local = dict(argd)<br>    argd_local["socketOptions"] = (socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)<br>    return ServerCore(**argd_local)<br></pre></blockquote>
However, by switching over to an inheritable default value approach you gain something which is declarative, picks up new default values from the base class cleanly and makes it much clearer that actually this returns objects of this type, just preconfigured in a particular way:<br><blockquote><pre>class ReusableSocketAttrServer(ServerCore):<br>    socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)  </pre></blockquote>So, by aiming for a syntactic sugar that's declarative in nature, we're hopefully making the intent in the system clearer.<br><h2>Summary</h2><br>If you want to provide default values for parameters for your components, and please do, providing them in the form of inheritable default values will make your components more useful to others. You don't have to do this, and if you find it odd, simply don't do this. However if you do, it would be appreciated by the users of your code. <br><br>





                </div>
                <div class="twoC column last">
                    &nbsp;
                </div>
                <div id="footer">
                    &nbsp;
                    <br>&nbsp;
                </div>


<div class="divide"></div>
            </div>
        </div>
    </td></tr></table>


<hr>
<div id="aboutblock" style="text-align: left"; padding-left: 1em;>
<font size="-2">
   <P><img src="http://www.kamaelia.org/images/BBC-ResearchLogo-Small.png"
style="float: left; padding-right: 10px; margin-bottom: 3em;"> <a href="http://www.kamaelia.org/Home.html">Kamaelia</a>
    is an open source project originated from and guided by <a href="http://www.bbc.co.uk/rd"> BBC 
    Research</a>. For more information browse the site or get in 
    <a href="/Contact.html">contact</a>.
   <P>This is an ongoing community based development site. As a result the
   contents of this page is the opinions of the contributors of the pages
   involved not the organisations involved. Specificially, this page may
   contain personal views which are not the views of the BBC. (the site is
   powered by a wiki engine)
   <P>(C) Copyright 2008 Kamaelia Contributors, including the British
   Broadcasting Corporation, All Rights Reserved
</font>
</div>
</div>
<div style="display:none">
This web site is powered by the same code created for the
<a href="http://www.bickermanor.org/"> bicker manor</a> project. For more
details, contact Michael Sparks at BBC Research directly (cf contact)
</div>
</body>
</html>



