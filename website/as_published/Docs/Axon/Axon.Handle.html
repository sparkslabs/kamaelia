<html>
<head>
<title> Docs/Axon/Axon.Handle </title>
<meta name="description" content="Kamaelia - making concurrency simpler in python - Docs/Axon/Axon.Handle">
<meta name="keywords" content="python concurrency generators threads processes component system experts beginners media networking">
<link rel=stylesheet type="text/css" href="/newcss.css">
  </head>
<body style="font-size: 10pt; font-family: verdana,arial,helvetica,sans-serif; line-height: 1.8;">
</div>

</span></p>

<div id="centreinbrowser">
    <table><tr><td>
        <div id="contentwrapper">
            <div id="contentpanel">
                <div class="column twoC largertext">  &nbsp; </div>
                <div class="column twoC largertext">  &nbsp;  </div>
                <div class="column twoC largertext"> <P class="orange" align="center">  <b><a href="/Home.html"> Home</a></b> </div>
                <div class="column twoC largertext"> 
<P class="orange" align="center"> 
<b><a href="/About.html" class="smallertext">About</a>, 
<a href="/Sitemap.html" class="smallertext">Index</a>, 
<a href="/RecentChanges.html" class="smallertext">Changes</a></b>
  </div>
                <div class="column twoC largertext"> <P class="orange" align="center">  <b> <a href="/Developers/">Developers</a> </b> </div>
                <div class="column last twoC"> <P class="orange" align="center"> 
<b>
<span class="largertext">&nbsp;</span>
<!--   <span class="largertext"><a href="/UserLogin.html">Login</a>/<a href="/UserRegistration.html">Register</a> </span>  -->
<!--  </b> -->
</b>
 </div>

<div class="divide"></div>
                <div id="masthead">
                    &nbsp;
                    <br>
                </div>
                <div class="fourC column">
                    &nbsp;
                </div>
                <div class="fourC column">
                    &nbsp;
                </div>
                <div class="fourC column last">
                    &nbsp;
                </div>
<div class="divide"></div>
                <div class="twoC column">
                    &nbsp;
                </div>
                <div class="eightC column">
                <html>
<head>
<title>Kamaelia docs : Axon.Handle</title>
<style type="test/css">
pre.literal-block, pre.doctest-block {
  margin-left: 2em ;
  margin-right: 2em ;
  background-color: #eeeeee }
</style>
</head>
<body>
<div class="container">
<div class="section">
<div class="section">
<h2><a class="reference" href="/Docs/Axon/Axon.html">Axon</a>.<a class="reference" href="/Docs/Axon/Axon.Handle.html">Handle</a></h2>
</div>
</div>
<div class="section">
<h1>Communicating with components from non Axon code</h1>
<div class="container">
<ul class="simple">
<li><strong>class <a class="reference" href="/Docs/Axon/Axon.Handle.Handle.html">Handle</a></strong></li>
</ul>
</div>
<ul class="simple">
<li><a class="reference" href="#11">Still Experimental</a><ul>
</ul>
</li>
<li><a class="reference" href="#12">Example Usage</a><ul>
</ul>
</li>
<li><a class="reference" href="#13">Behaviour</a><ul>
</ul>
</li>
<li><a class="reference" href="#14">Limitations</a><ul>
<li><a class="reference" href="#15">Limited to standard inboxes and outboxes</a><ul>
</ul>
</li>
<li><a class="reference" href="#16">CPU Usage</a><ul>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#17">Design rationale and history</a><ul>
</ul>
</li>
</ul>
</div>
<div class="section">
<p>The Handle component wraps another component and allows data to be sent to and
received from its standard inboxes (&quot;inbox&quot; and &quot;control&quot;) and standard outboxes
(&quot;outbox&quot; and &quot;signal&quot;). It provides this via thread safe, non-blocking get()
and put() methods.</p>
<p>This is particularly useful in combination with <a class="reference" href="/Docs/Axon/Axon.background.html">Axon.background</a> - allowing
communication with components running in the background of a non Axon based
piece of code.</p>
<div class="section">
<h2 id="11"><a id="still-experimental" name="still-experimental">Still Experimental</a></h2>
<p>This code is currently experimental - we'd welcome reports of any issues you may
encounter when using this code.</p>
</div>
<div class="section">
<h2 id="12"><a id="example-usage" name="example-usage">Example Usage</a></h2>
<p>Here, Axon/Kamaelia is used to connect to a server then receive text, chunking
it into individual lines. This is done by using Axon in the background (since
other code in this hypothetical system is not Axon based).</p>
<p>NOTE: To see how this could be done without using <a class="reference" href="/Docs/Axon/Axon.Handle.html">Axon.Handle</a>, see the examples
in the documentation for <a class="reference" href="/Docs/Axon/Axon.background.html">Axon.background</a>.</p>
<ol class="arabic">
<li><p class="first">We create a background object and call its start() method:</p>
<pre class="literal-block">
from <a class="reference" href="/Docs/Axon/Axon.background.html">Axon.background</a> import background

background().start()
</pre>
</li>
<li><p class="first">We create and activate our Kamaelia pipeline of components, wrapped in an
instance of the Handle class:</p>
<pre class="literal-block">
from <a class="reference" href="/Docs/Axon/Axon.Handle.html">Axon.Handle</a> import Handle
from Kamaelia.Chassis.Pipeline import Pipeline
from Kamaelia.Internet.TCPClient import TCPClient
from Kamaelia.Visualisation.PhysicsGraph import chunks_to_lines

queue = Queue()

connection = Handle(
    Pipeline(
        TCPClient(&quot;my.server.com&quot;, 1234),
        chunks_to_lines()
    )
).activate()
</pre>
</li>
</ol>
<p>We can now fetch items of data when they arrive, using the Handle, from the
&quot;outbox&quot; outbox of the pipeline:</p>
<pre class="literal-block">
from Queue import Empty

while 1:
   try:
       received_line = connection.get(&quot;outbox&quot;)
       print &quot;Received line:&quot;, received_line
   except Empty:
       # no data yet
       time.sleep(0.1)
</pre>
<p>We can also send data, back to the server, by sending it to the &quot;inbox&quot; inbox
of the pipeline:</p>
<pre class="literal-block">
connection.put(&quot;Bytes to send to server\n&quot;, &quot;inbox&quot;)
</pre>
</div>
<div class="section">
<h2 id="13"><a id="behaviour" name="behaviour">Behaviour</a></h2>
<p>Handle is a threaded component. It does not have the standard inboxes (&quot;inbox&quot;
and &quot;control&quot;) or standard outboxes (&quot;outbox&quot; and &quot;signal&quot;). The only way to
communicate with Handle is via its get() and put() methods.</p>
<p>Instantiate Handle, passing it a component to wrap. Upon activation, Handle
automatically wires inboxes and outboxes of its own to the &quot;inbox&quot; and
&quot;control&quot; inboxes and &quot;outbox&quot; and &quot;signal&quot; outboxes of the component it is
wrapping. Handle then activates the wrapped component.</p>
<p>To send data to the wrapped component's &quot;inbox&quot; or &quot;control&quot; inboxes, call the
put() method, specifying, as arguments, the item of data and the name of the
inbox it is destined for. The data is queued and sent at the next opportunity.</p>
<p>To retrieve data sent out by the wrapped component's &quot;outbox&quot; or &quot;signal&quot;
outboxes, call the get() method, specifying, as an argument, the name of the
outbox in question. This method is <em>non blocking</em> - if there is data waiting,
then the oldest item of data is returned, otherwise a Queue.Empty exception is
immediately thrown.</p>
<p>When the wrapped component terminates, Handle will immediately terminate.
Handle does not respond to shutdown messages received from the wrapped
component. Handle cannot be sent shutdown messages since it has no &quot;control&quot;
inbox on which to receive them.</p>
</div>
<div class="section">
<h2 id="14"><a id="limitations" name="limitations">Limitations</a></h2>
<div class="section">
<h3 id="15"><a id="limited-to-standard-inboxes-and-outboxes" name="limited-to-standard-inboxes-and-outboxes">Limited to standard inboxes and outboxes</a></h3>
<p>Handle currently only provides access to the standard &quot;inbox&quot; and &quot;control&quot;
inboxes and standard &quot;outbox&quot; and &quot;signal&quot; outboxes of the component it wraps.</p>
<p>If access is required to a different inbox or outbox, try wrapping the component
within a Kamaelia.Chassis.Graphline component and specifying linkages to connect
the inbox or outbox in question to one of the standard inboxes or outboxes of
the Graphline.</p>
</div>
<div class="section">
<h3 id="16"><a id="cpu-usage" name="cpu-usage">CPU Usage</a></h3>
<p>The current implememntation of Handle involves a degree of polling. However it
does use a slight (approximately 1 centisecond) delay between pollings.</p>
<p>Therefore when idle, CPU usage of this component will be slightly greater than zero.</p>
</div>
</div>
<div class="section">
<h2 id="17"><a id="design-rationale-and-history" name="design-rationale-and-history">Design rationale and history</a></h2>
<p>This component is the successor to the earlier &quot;likefile&quot; component. Likefile
suffered from some design issues that resulted in occassional race conditions.</p>
<p>We dropped the name &quot;LikeFile&quot; since whilst it derives from the concept of a
file handle, it doesn't use the same API as file() for some good reasons we'll
come back to.</p>
<p>A file handle is an opaque thing that you can .write() data to, and .read() data
from. This is a very simple concept and belies a huge amount of parallel
activity happening concurrently to your application. The file system is taking
your data and typically buffering it into blocks. Those blocks then may need
padding, and depending on the file system, may actually be written immediately
to the end of a cyclone buffer in a journal with some write operations. Then
periodically those buffers get flushed to the actual disk.</p>
<p>Based on the fact that file handles are a very natural thing for people to work
with, based on their ubiquity, and the fact that it masks the fact you're
accessing a concurrent system from a linear one, that's why we've taken this
approach for integrating Kamaelia components (which are naturally parallel) with
non-Kamaelia code, which is typically not parallel.</p>
<p>For simplicity of implementation, initially the implementation of Handle
supports only the equivalent of non-blocking file handles. This has two
implications:</p>
<ul class="simple">
<li>Reading data from a Handle may fail, since there may not be any ready yet.
This is chosen in preference to a blocking operation</li>
<li>Writing data to a Handle may also fail, since the component may not actually
be ready to receive data from us.</li>
</ul>
</div>
</div>
<hr class="docutils" />
<div class="section">
<h1><a class="reference" href="/Docs/Axon/Axon.html">Axon</a>.<a class="reference" href="/Docs/Axon/Axon.Handle.html">Handle</a>.<a class="reference" href="/Docs/Axon/Axon.Handle.Handle.html">Handle</a></h1>
<div class="section">
<h2 id="symbol-Handle">class Handle(<a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.threadedcomponent.html">Axon.ThreadedComponent.threadedcomponent</a>)</h2>
<div class="section">
</div>
<div class="section">
<h3>Methods defined here</h3>
<div class="section">
<h4><a id="symbol-Handle.__init__" name="symbol-Handle.__init__">__init__(self, someComponent)</a></h4>
<p>x.__init__(...) initializes x; see x.__class__.__doc__ for signature</p>
</div>
<div class="section">
<h4><a id="symbol-Handle._get" name="symbol-Handle._get">_get(self)</a></h4>
</div>
<div class="section">
<h4><a id="symbol-Handle.childrenDone" name="symbol-Handle.childrenDone">childrenDone(self)</a></h4>
<p>Unplugs any children that have terminated, and returns true if there are no
running child components left (ie. their microproceses have finished)</p>
</div>
<div class="section">
<h4><a id="symbol-Handle.get" name="symbol-Handle.get">get(self[, boxname])</a></h4>
<p>Return an item of data sent to an outbox of the wrapped component.</p>
<p>This method is non blocking and always returns immediately. If there is
no data to return, then the exception Queue.Empty is thrown</p>
<p>Arguments:</p>
<ul class="simple">
<li>boxname  -- (optional) the name of the outbox of the wrapped component
from which the data should be collected (default=&quot;outbox&quot;, should be
either &quot;outbox&quot; or &quot;signal&quot;)</li>
</ul>
</div>
<div class="section">
<h4><a id="symbol-Handle.main" name="symbol-Handle.main">main(self)</a></h4>
<p>Main loop.</p>
</div>
<div class="section">
<h4><a id="symbol-Handle.put" name="symbol-Handle.put">put(self, *args)</a></h4>
<p>Send an item of data to one of the inboxes of the wrapped component.</p>
<p>The item of data is queued and sent to the inbox as soon as possible.</p>
<p>Arguments:</p>
<ul class="simple">
<li>the item of data</li>
<li>the name of the inbox it is destined for (either &quot;inbox&quot; or &quot;control&quot;)</li>
</ul>
</div>
</div>
<div class="section">
<div class="section">
<h4>Methods inherited from <a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.threadedcomponent.html">Axon.ThreadedComponent.threadedcomponent</a> :</h4>
<ul class="simple">
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.initialiseComponent">initialiseComponent</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent._handlemessagefromthread">_handlemessagefromthread</a>(self, msg)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.activate">activate</a>(self[, Scheduler][, Tracker][, mainmethod])</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.mainBody">mainBody</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.recv">recv</a>(self[, boxname])</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.forwardInboxToThread">forwardInboxToThread</a>(self, box)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.closeDownComponent">closeDownComponent</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.unlink">unlink</a>(self[, thecomponent][, thelinkage])</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.sync">sync</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.send">send</a>(self, message[, boxname])</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent._threadmain">_threadmain</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.pause">pause</a>(self[, timeout])</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent._localmain">_localmain</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent._do_threadsafe">_do_threadsafe</a>(self, cmd, argL, argD)</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.link">link</a>(self, source, sink[, passthrough])</li>
<li><a class="reference" href="/Docs/Axon/Axon.ThreadedComponent.html#symbol-threadedcomponent.dataReady">dataReady</a>(self[, boxname])</li>
</ul>
</div>
<div class="section">
<h4>Methods inherited from <a class="reference" href="/Docs/Axon/Axon.Component.component.html">Axon.Component.component</a> :</h4>
<ul class="simple">
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component.__str__">__str__</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component.childComponents">childComponents</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component.setInboxSize">setInboxSize</a>(self, boxname, size)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component.anyReady">anyReady</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component.__addChild">__addChild</a>(self, child)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component._closeDownMicroprocess">_closeDownMicroprocess</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component._deliver">_deliver</a>(self, message[, boxname])</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component.removeChild">removeChild</a>(self, child)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component.Inbox">Inbox</a>(self[, boxname])</li>
<li><a class="reference" href="/Docs/Axon/Axon.Component.html#symbol-component.addChildren">addChildren</a>(self, *children)</li>
</ul>
</div>
<div class="section">
<h4>Methods inherited from <a class="reference" href="/Docs/Axon/Axon.Microprocess.microprocess.html">Axon.Microprocess.microprocess</a> :</h4>
<ul class="simple">
<li><a class="reference" href="/Docs/Axon/Axon.Microprocess.html#symbol-microprocess._unpause">_unpause</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Microprocess.html#symbol-microprocess._microprocessGenerator">_microprocessGenerator</a>(self, someobject[, mainmethod])</li>
<li><a class="reference" href="/Docs/Axon/Axon.Microprocess.html#symbol-microprocess._isStopped">_isStopped</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Microprocess.html#symbol-microprocess.stop">stop</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Microprocess.html#symbol-microprocess.next">next</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Microprocess.html#symbol-microprocess.unpause">unpause</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Microprocess.html#symbol-microprocess.run">run</a>(self)</li>
<li><a class="reference" href="/Docs/Axon/Axon.Microprocess.html#symbol-microprocess._isRunnable">_isRunnable</a>(self)</li>
</ul>
</div>
</div>
</div>
</div>
</div>









<div class="section">
<h1>Feedback</h1>
<p>Got a problem with the documentation? Something unclear that could be clearer?
Want to help improve it? Constructive criticism is very welcome - especially if you can suggest a better rewording!</p>
<p>Please leave you feedback
<a class="reference" href="../../../cgi-bin/blog/blog.cgi?rm=viewpost&amp;nodeid=1142023701">here</a>
in reply to the documentation thread in the Kamaelia blog.</p>
</div>




<p><i>-- Automatic documentation generator, 01 Feb 2010 at 04:00:28 UTC/GMT</i>
</body></html>

                </div>
                <div class="twoC column last">
                    &nbsp;
                </div>
                <div id="footer">
                    &nbsp;
                    <br>&nbsp;
                </div>


<div class="divide"></div>
            </div>
        </div>
    </td></tr></table>


<hr>
<div id="aboutblock" style="text-align: left"; padding-left: 1em;>
<font size="-2">
   <P><img src="http://www.kamaelia.org/images/BBC-ResearchLogo-Small.png"
style="float: left; padding-right: 10px; margin-bottom: 3em;"> <a href="http://www.kamaelia.org/Home.html">Kamaelia</a>
    is an open source project originated from and guided by <a href="http://www.bbc.co.uk/rd"> BBC 
    Research</a>. For more information browse the site or get in 
    <a href="/Contact.html">contact</a>.
   <P>This is an ongoing community based development site. As a result the
   contents of this page is the opinions of the contributors of the pages
   involved not the organisations involved. Specificially, this page may
   contain personal views which are not the views of the BBC. (the site is
   powered by a wiki engine)
   <P>(C) Copyright 2008 Kamaelia Contributors, including the British
   Broadcasting Corporation, All Rights Reserved
</font>
</div>
</div>
<div style="display:none">
This web site is powered by the same code created for the
<a href="http://www.bickermanor.org/"> bicker manor</a> project. For more
details, contact Michael Sparks at BBC Research directly (cf contact)
</div>
</body>
</html>



