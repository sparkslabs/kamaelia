<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:10pt;font-family:URW Gothic L">
<p><span style="font-size:22pt;font-weight:600">Asked and Answered Questions </span></p>
<p align="right"><span style="font-size:16pt">Draft</span></p>
<ul type="disc"><div><span style="font-style:italic;font-weight:600">This document is still at a draft stage - a variety of questions</span></div>
<div><span style="font-style:italic;font-weight:600">have come in over recent days, this page collates those Q's</span></div>
<div><span style="font-style:italic;font-weight:600">and A's so far. More work on collation &amp; summarisation is</span></div>
<div><span style="font-style:italic;font-weight:600">needed however.</span></div></ul>
<p></p>
<p>(Names regarding questions removed, more generalisation/summarisation to come)</p>
<p></p>
<p>&gt; - (how) does kamaelia help me in defining my protocol state machines?</p>
<p></p>
<p>Kamaelia doesn't _directly_ simplify the process of building a protocol using</p>
<p>a state machine, but can help people avoid having to implement the protocol</p>
<p>as a state machine.</p>
<p></p>
<p>Take a simple TCP Client for example. One of the most direct ways to write a</p>
<p>TCP client might be as follows (handling some basic error cases):</p>
<p>   def runClient(self,sock=None):</p>
<p>      try: sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</p>
<p>         try:</p>
<p>            sock.setblocking(0);</p>
<p>            try: sock.connect(sock,(self.host, self.port)</p>
<p>               while working:</p>
<p>                  # Do work with the connection.</p>
<p>            finally:</p>
<p>               result = sock.shutdown(2)</p>
<p>         finally:</p>
<p>            sock.close()</p>
<p>      finally:</p>
<p>            sock.close()</p>
<p></p>
<p>This is relatively clear, and in a threaded environment you could quite</p>
<p>happily use this. However in a single threaded environment you'd normally</p>
<p>need to change that to being a state machine.</p>
<p></p>
<p>However, using Kamaelia, since we use generators we can choose to use this in</p>
<p>a single threaded environment quite happily by yielding at various points in</p>
<p>time.</p>
<p></p>
<p>[[aside]</p>
<p>Since the ability to do try:... finally:... in</p>
<p>generators is only just appearing in 2.5, we use the</p>
<p>following to force the same behaviour:</p>
<p>try:</p>
<p>     ... some work that requires shutdown</p>
<p>     raise Finality # (subclasses Exception)</p>
<p>except Exception, e</p>
<p>     # do shutdown</p>
<p>raise e</p>
<p>]</p>
<p></p>
<p>Furthermore, since TCP connecting can fail at any point in time, we can use</p>
<p>the yields during testing to force failures and check that the correct</p>
<p>behaviours ensue by checking execution traces:</p>
<p></p>
<p>   def runClient(self,sock=None):</p>
<p>      # The various numbers yielded here indicate progress through the</p>
<p>      # function, and nothing else specific.</p>
<p>      try:</p>
<p>         sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM); yield 0.3</p>
<p>         try:</p>
<p>            sock.setblocking(0); yield 0.6</p>
<p>            try:</p>
<p>               while not self.safeConnect(sock,(self.host, self.port)):</p>
<p>                   yield 1</p>
<p>               yield newComponent(*self.setupCSA(sock))</p>
<p>               while self.waitCSAClose():</p>
<p>                  self.pause()</p>
<p>                  yield 2</p>
<p>               raise Finality</p>
<p>            except Exception, x:</p>
<p>               result = sock.shutdown(2) ; yield 3</p>
<p>               raise x  # XXXX If X is not finality, an error</p>
<p>               # The logical place to send the error is to the signal outbox</p>
<p>         except Exception, x:</p>
<p>            sock.close() ; yield 4,x # XXXX If x is not finality, an error</p>
<p>            raise x</p>
<p>      except Finality: # Not an error</p>
<p>         yield 5</p>
<p>      except socket.error, e:</p>
<p>         # Pass on the socket error to the next in the chain to let them know</p>
<p>         # of failure.</p>
<p>         #</p>
<p>         self.send(e, &quot;signal&quot;)</p>
<p></p>
<p>This still clearly follows the same basic structure, and in Python 2.5 will</p>
<p>be able to be shorter and clearer (due to supporting try...finally in</p>
<p>generators).</p>
<p></p>
<p>Obviously you could turn the above into a state machine - essentially take</p>
<p>the code chunks between yields, turn each into a state and then use a state</p>
<p>variable to control which state you're in.</p>
<p></p>
<p>The ability to have the structure of the code follow the basic logic of the</p>
<p>protocol in hand (TCP setup/shutdown clearly being a simple case - but easy</p>
<p>to get wrong) makes it easier for a maintainer to look at later on.</p>
<p></p>
<p>That's relatively low level. If you're writing a protocol that sits on top of</p>
<p>TCP or multicast then at present you can write a protocol using the following</p>
<p>basic pattern:</p>
<p></p>
<p>class myProtocol(component):</p>
<p>   def main(self):</p>
<p>      # Local protocol setup</p>
<p dir="ltr">      while 1:</p>
<p dir="ltr">         yield 1</p>
<p dir="ltr">         if self.dataReady(&quot;inbox&quot;):</p>
<p dir="ltr">            # Data has been recieved on the socket and passed to our inbox</p>
<p dir="ltr">            data = self.recv(&quot;inbox&quot;) take the data</p>
<p dir="ltr">            &lt; do whatever you'd normally do for your protocol &gt;</p>
<p dir="ltr">            self.send(response, &quot;outbox&quot;)</p>
<p dir="ltr">            # send data to the connection via our outbox.</p>
<p></p>
<p>OK, on the surface it doesn't look like you've gained much, but what it does</p>
<p>allow is the automated testing of a protocol handler without involving the</p>
<p>network at all. This allows you for example to do the following:</p>
<p></p>
<p>pipeline(</p>
<p>   ReadFileAdaptor(&quot;destruction_data&quot;),</p>
<p>   myProtocol(),</p>
<p>   ResultsChecker(&quot;expected_data&quot;),</p>
<p>   consoleEchoer()</p>
<p>).run()</p>
<p></p>
<p>Furthermore, if you have a protocol that has stages (such as read header,</p>
<p>read body), this can be expressed very directly:</p>
<p></p>
<p>class stagedProtocol(component):</p>
<p>   def main(self):</p>
<p>      # Local protocol setup</p>
<p>      try:</p>
<p>         readingHeader = True</p>
<p>         while readingHeader:</p>
<p>            yield 1</p>
<p>            if self.dataReady(&quot;inbox&quot;):</p>
<p>                # Assume data from socket has been collated as a line</p>
<p>                # (lines starting with whitespace appended onto preceding</p>
<p>                # lines</p>
<p>                data = self.recv(&quot;inbox&quot;) take the data</p>
<p>                try:</p>
<p>                   header, value = self.parseHeaderLine(data)</p>
<p>                   try:</p>
<p>                       self.requestHeader[header].append(value)</p>
<p>                   except KeyError:</p>
<p>                       self.request[header] = [ value ]</p>
<p>                except BadHeader:</p>
<p>                   readingHeader = False</p>
<p></p>
<p>         readingBody = True</p>
<p>         while readingBody:</p>
<p>            yield 1</p>
<p>            if self.dataReady(&quot;inbox&quot;):</p>
<p>                # Data has been recieved on the socket and passed to our inbox data = self.recv(&quot;inbox&quot;) take the data</p>
<p>               &lt; do whatever you'd normally do for your protocol &gt;</p>
<p>               self.send(response, &quot;outbox&quot;)</p>
<p>               # send data to the connection via our outbox.</p>
<p></p>
<p>         self.send(self.generateResponse(), &quot;outbox&quot;)</p>
<p></p>
<p>OK, in pratice you might want to split this into probably 3 methods - one for</p>
<p>handling the reading header loop, one for the reading body loop, but you</p>
<p>can clearly see the logic - as could any new programmer coming along (in</p>
<p>what, a screenfull of code?).</p>
<p></p>
<p>Obviously this doesn't preclude using a traditional state machine approach,</p>
<p>but it does provide an alternative (hopefully interesting/compelling).</p>
<p></p>
<p>For an example on composing a protocol is here:</p>
<p>   * http://kamaelia.sourceforge.net/SimpleReliableMulticast.html</p>
<p></p>
<p>The source files relating to this are here:</p>
<p>   * Actual logic of protocol: http://tinyurl.com/9ls9v</p>
<p>   * Framing and chunking: http://tinyurl.com/9rarp</p>
<p></p>
<p>&gt; - are timers supported?</p>
<p></p>
<p>At present not directly. However a component can do this:</p>
<p>      self.pause()</p>
<p>      yield 1</p>
<p></p>
<p>That will tell the scheduler not to give the component any CPU time. Whilst</p>
<p>there isn't a component for this at present, we do have the concept of</p>
<p>services. A timer service could be constructed fairly easily such that a</p>
<p>timer service could be used as follows:</p>
<p></p>
<p>class myComponent(component):</p>
<p>   Outboxes = { &quot;outbox&quot;: &quot;default data outbox&quot;,</p>
<p>                        &quot;signal&quot;: &quot;default data outbox&quot;,</p>
<p>                        &quot;timerbox&quot;: &quot;default data outbox&quot;,</p>
<p>                     }</p>
<p>...</p>
<p>         timerservice = Timer.getTimerService()</p>
<p>         self.link((self, &quot;timerbox&quot;), timerservice)</p>
<p>         sleep_seconds = 5 # number of seconds to sleep</p>
<p>         self.send( (sleep_seconds, (self,&quot;control&quot;) ) , &quot;timerbox)</p>
<p>         self.pause(); yield 1</p>
<p>...</p>
<p></p>
<p>This would not be a hard realtime event of course, rather a soft realtime</p>
<p>event. (We've deliberately shied away from a specific events model so far,</p>
<p>though it will be added at some point)</p>
<p></p>
<p>&gt; - do you have any experience with load/stress testing? (e.g. can I</p>
<p>&gt; use kamaelia to set a server under heavy load for testing?)</p>
<p></p>
<p>If you haven't seen it I've written a white paper about Kamaelia which is</p>
<p>essentially a translation of &quot;slides+what I said&quot; into text (presentations</p>
<p>given at Europython &amp; ACCU/Python UK). This can be found here:</p>
<p>   * http://www.bbc.co.uk/rd/pubs/whp/whp113.shtml</p>
<p></p>
<p>(PDF only, if you want a different format for whatever reason, let me</p>
<p>know - it will be on the website in HTML form at some point.)</p>
<p></p>
<p>&gt; Quoting Michael Sparks &lt;michaels@rd.bbc.co.uk&gt;:</p>
<p>&gt; &gt;                 data = self.recv(&quot;inbox&quot;) take the data</p>
<p dir="ltr">&gt; &gt;                 &lt; do whatever you'd normally do for your protocol &gt;</p>
<p>&gt; &gt;                 self.send(response, &quot;outbox&quot;)</p>
<p>&gt;</p>
<p>&gt; Can I assume, that I can have multiple in- and outboxes?</p>
<p></p>
<p>Sure - think pins on a chip - you have multiple in-pins and out-pins. Each</p>
<p>expecting specific sorts of information carrying either signalling or data</p>
<p>information.</p>
<p></p>
<p>The default set is as follows - this declaration simply overwrites the</p>
<p>defaults with the defaults:</p>
<p></p>
<p>class someComponent(component):</p>
<p>   Inboxes = [ &quot;inbox&quot;, &quot;control&quot; ]</p>
<p>   Outboxes = [ &quot;outbox&quot;, &quot;signal&quot; ]</p>
<p></p>
<p>A more complex example in CVS which is currently being documented is a</p>
<p>sprite component (originally part of an optimisation test). Since the actual</p>
<p>inbox/outbox datastructures are created during initialisation by simply</p>
<p>interating through the lists of names of components, you can use this to</p>
<p>help document the purpose of the inboxes/outboxes as well. For example</p>
<p>the sprite component:</p>
<p></p>
<p>class BasicSprite(component):</p>
<p>   Inboxes= {</p>
<p>          &quot;rotator&quot; : &quot;Recieves a value between 0 and 360 to set the current rotation&quot;,</p>
<p>          &quot;translation&quot; : &quot;Set the current position - translation - from the origin - expects a tuple for the pixel position&quot;,</p>
<p>         &quot;scaler&quot; : &quot;Expects a floating value greater that 0, normally &lt;=1.0 - scales the current image by this preserving aspect&quot;,</p>
<p>         &quot;imaging&quot; : &quot;Expects a pygame surface that contains an image, replaces the image the sprite surface is showing with this&quot;,</p>
<p>         &quot;inbox&quot; : &quot;default, unused&quot;,</p>
<p>         &quot;control&quot; : &quot;default, used to tell the BasicSprite to shutdown&quot;,</p>
<p>   }</p>
<p>   # Take default outboxes</p>
<p></p>
<p>&gt; &gt;    * Actual logic of protocol: http://tinyurl.com/9ls9v</p>
<p dir="ltr">&gt; &gt;    * Framing and chunking: http://tinyurl.com/9rarp</p>
<p>&gt;</p>
<p>&gt; I could not access these pages.  Could you please send the</p>
<p>&gt; complete link? Thanks.</p>
<p></p>
<p>Sorry - simply used it for brevity - the links are here:</p>
<p>Logic:</p>
<ul type="disc"><li>http://cvs.sourceforge.net/viewcvs.py/kamaelia/Code/Python/Kamaelia/Kamaelia/Protocol/SimpleReliableMulticast.py?rev=1.2&amp;view=markup</li></ul>
<p>Framing/Chunking:</p>
<ul type="disc"><li>http://cvs.sourceforge.net/viewcvs.py/kamaelia/Code/Python/Kamaelia/Kamaelia/Protocol/Framing.py?rev=1.2&amp;view=auto</li></ul>
<p></p>
<p>&gt; &gt; This would not be a hard realtime event of course, rather a soft realtime</p>
<p>&gt; &gt; event. (We've deliberately shied away from a specific events model so</p>
<p>&gt; &gt; far, though it will be added at some point)</p>
<p>&gt;</p>
<p>&gt; Some communication protocols have some demands on timer accuracy...</p>
<p></p>
<p>Indeed - currently we're building up the building blocks slowly - rather than</p>
<p>jumping straight in with ones that do require timer accuracy. (Think</p>
<p>automated creation of tunnels between multicast islands, and bit-rate</p>
<p>limited serving of pre-encoded content on a content agnostic channel)</p>
<p></p>
<p>&gt; What do you mean by events model? The structure/encoding of</p>
<p>&gt; events?</p>
<p></p>
<p>One common approach to concurrency - is to have an events wheel - much</p>
<p>like the approach taken by simulation systems. However it can encourage a</p>
<p>certain kind of architecture, and we're really experimenting to find a</p>
<p>method of building these sorts of systems easily. (Hence modelling the</p>
<p>system on an approach where building blocks seems to work)</p>
<p></p>
<p>&gt; Btw. do you know SimPy (= Simulation in Python)? See</p>
<p>&gt; http://simpy.sourceforge.net/ and the Debian packages at</p>
<p>&gt; http://packages.debian.org/stable/python/python-simpy</p>
<p></p>
<p>I do indeed. I haven''t had a look at how they're doing recently, but at some</p>
<p>point we'll need to revisit things because their events model is pretty good.</p>
<p>(But then being based on Simula's approach it would be!)</p>
<p>---------------------------------------------------------------------------------------------------------------------------------------</p>
<p>&gt; Kamaelia seems it might be an interesting project. However, I don't </p>
<p>&gt; think the project is well served by this announcement -- which I </p>
<p>&gt; find vague and hard to understand. Which is a shame, because it </p>
<p>&gt; means that other people probably don't understand it very well </p>
<p>&gt; either, which means less people will use it. </p>
<p></p>
<p>It is a shame, and thanks for mentioning this. </p>
<p></p>
<p>OK, here's a better go. (It's always difficult to think where to pitch </p>
<p>this sort of thing) </p>
<p></p>
<p>---START--- </p>
<p>The project aims to make it simple to build networked multimedia </p>
<p>systems (eg audio, video, interactive systems), which are naturally </p>
<p>componentised and naturally concurrent allowing quick and fast reuse in </p>
<p>the same way as Unix pipelines do. </p>
<p> </p>
<p>It is designed as a practical toolkit, such that you can build systems </p>
<p>such as: </p>
<p>    * Ogg Vorbis streaming server/client systems (via vorbissimple) </p>
<p>    * Simple network aware games (via pygame) </p>
<p>    * Quickly build TCP based network servers and clients </p>
<p>    * Quickly build Multicast based network servers and clients </p>
<p></p>
<p>It runs on Linux, Window, Mac OS X with a subset running on Series 60 </p>
<p>phones. </p>
<p></p>
<p>The basic underlying metaphor of a component us like an office worker </p>
<p>with inboxes and outboxes, with deliveries occuring between desks, </p>
<p>offices, and depts. The component can thus do work anyway it likes but </p>
<p>only communicates with these inboxes and outboxes. Like office workers, </p>
<p>components run in parallel, and to achieve this are generally </p>
<p>implemented using python generators, but can also used threads. </p>
<p></p>
<p>The rationale behind the project is to provide a toolkit enabling the </p>
<p>development of new protocols, including streaming, for large scale </p>
<p>media delivery. The license essentially allows use in proprietary </p>
<p>systems without change, but all changes to the system itself must be </p>
<p>shared. </p>
<p>---END--- </p>
<p></p>
<p>Is that clearer ? </p>
<p></p>
<p>A short summary of all that could be: </p>
<p></p>
<p>&quot;&quot;&quot;Kamaelia is a networking/communications infrastructure for innovative </p>
<p>multimedia systems. Kamaelia uses a component architecture designed to </p>
<p>simplify creation and testing of new protocols and large scale media </p>
<p>delivery systems.&quot;&quot;&quot; </p>
<p></p>
<p>Hopefully that's clearer than: </p>
<p></p>
<p>&gt;&gt;Kamaelia is a collection of Axon components designed for network </p>
<p>&gt;&gt;protocol experimentation in a single threaded, select based </p>
<p>&gt;&gt;environment. Axon components are python generators are augmented by </p>
<p>&gt;&gt;inbox and outbox queues (lists) for communication in a communicating </p>
<p>&gt;&gt;sequential processes (CSP) like fashion. </p>
<p></p>
<p>[ which you noted &quot;I really have very little idea what this means.&quot; ] </p>
<p></p>
<p>&gt; The information I can guess out of this is: &quot;Kamaelia is a library </p>
<p>&gt; for creating network protocols that sit on top of tcp and/or udp&quot;. </p>
<p>&gt; Given that it's a BBC project, I imagine we're talking about </p>
<p>&gt; protocols for transferring large amount of data, e.g. sound or </p>
<p>&gt; motion pictures. </p>
<p></p>
<p>Indeed. However, if you're having to guess I'm not doing the best job </p>
<p>(despite trying!) at explaining this. </p>
<p></p>
<p>&gt; BTW, the html is broken in that it's very poorly written, </p>
<p></p>
<p>It's written using a PyQT based WYSIWYG editor (written on my time, </p>
<p>not the BBC's) that has the limitation that preformatted text gets </p>
<p>squished (since the editor doesn't support the pre tag - or indeed </p>
<p>a lot of other tags). At some point I'll fix the editor to handle </p>
<p>pre-formatted text, but it's not a priority right now. (Should it be?) </p>
<p></p>
<p>The HTML isn't really *that* bad as far as generated code is concerned </p>
<p>IMHO, and is directly what the PyQT QTextEdit widget creates. (It's not </p>
<p>that great either - you may notice it doesn't have proper headings </p>
<p>either) </p>
<p></p>
<p>&gt; doesn't use CSS, </p>
<p></p>
<p>This isn't a problem IMHO, YMMV. The site's been tested on a variety of </p>
<p>browsers/platforms and looks pretty much the same on all. </p>
<p></p>
<p>&gt; I guess the main question that needs to be answered is &quot;Why would I, </p>
<p>&gt; as a programmer, use Kamaelia?&quot; </p>
<p></p>
<p>Probably the most interesting response I've had back from people who've </p>
<p>picked it up is that it's FUN. You can write small sketches (throwaway </p>
<p>code fragments), rewrite their inputs/outputs to take data from inboxes </p>
<p>&amp; outboxes, and then it's usable in a much wider system. It encourages </p>
<p>reuse of code, and assimilating existing systems can be relatively </p>
<p>trivial. </p>
<p></p>
<p>For example, trivial sketches: </p>
<p>    * A program to display an image using pygame </p>
<p>    * A program that can understand when an area of space has been </p>
<p>      clicked. (call it a button) </p>
<p>    * A program that can print a list of filenames, pausing waiting for a </p>
<p>      user to press return.  (call it a chooser) </p>
<p></p>
<p>Trivial changes: </p>
<p>    * Take the filename of the image from an inbox </p>
<p>    * Rather than print the filenames to send the filename to an outbox. </p>
<p>    * Rather than wait for a user to press a key, wait for a message on </p>
<p>      an inbox. </p>
<p></p>
<p>A useful composition linking some of these together: </p>
<p></p>
<p>Graphline( </p>
<p>      CHOOSER = Chooser(items = files), </p>
<p>      IMAGE = Image(size=(800,600), position=(8,48)), </p>
<p>      NEXT = Button(caption=&quot;Next&quot;, msg=&quot;NEXT&quot;, position=(72,8)), </p>
<p>      PREVIOUS = Button(caption=&quot;Previous&quot;, msg=&quot;PREV&quot;,position=(8,8)), </p>
<p>      linkages = { </p>
<p>         (&quot;NEXT&quot;,&quot;outbox&quot;) : (&quot;CHOOSER&quot;,&quot;inbox&quot;), </p>
<p>         (&quot;PREVIOUS&quot;,&quot;outbox&quot;) : (&quot;CHOOSER&quot;,&quot;inbox&quot;), </p>
<p>         (&quot;CHOOSER&quot;,&quot;outbox&quot;) : (&quot;IMAGE&quot;,&quot;inbox&quot;), </p>
<p>      } </p>
<p> ).run() </p>
<p></p>
<p>And you have a simple presentation tool ! </p>
<p></p>
<p>Another example. The visualisation framework was originally a stand </p>
<p>alone piece of code and was essentially just a piece of eye candy. I </p>
<p>threw in a few yields into certain locations. File reading &amp; static </p>
<p>graph construction was replaced with recieving data from inboxes, and </p>
<p>then it was available for use (and networked after creating trivial </p>
<p>protocol components). </p>
<p></p>
<p>A piece of eye candy is now a useful tool. It's likely to gain the </p>
<p>ability to send to an outbox a message saying &quot;this blob is clicked&quot; </p>
<p>meaning we can have 'WYSIWYG' GUI based construction of pipelines </p>
<p>easily. </p>
<p></p>
<p>It's designed literally as a tool for making it simple to bolt things </p>
<p>together with minimal change. (Which means you choose what you </p>
<p>use, not the framework.) </p>
<p></p>
<p>The system also lends itself to test driven and network independent </p>
<p>development, something not that simple normally with network </p>
<p>protocols. </p>
<p></p>
<p>Why wouldn't you use it? When Twisted is appropriate (Twisted is a more </p>
<p>mature framework).</p>
<p>---------------------------------------------------------------------------------------------------------------------</p>
<p>&gt;&gt;&gt; Is the audience programmers or</p>
<p>&gt;&gt;&gt; less technical people? A project that allows non-technical people</p>
<p>&gt;&gt;&gt; to build complex network applications is an ambitious one, but not</p>
<p>...</p>
<p>&gt;&gt;It's a little ambitious at this stage, yes.</p>
<p></p>
<p>&gt; But it couldbe there eventually?</p>
<p></p>
<p>Could? Yes. Will? Can't say. I can agree it would be nice, and given</p>
<p>time/resources (or someone sufficiently interested externally) then it</p>
<p>may happen. (IMO there's no real reason that it couldn't happen aside</p>
<p>from time/effort/resources)</p>
<p></p>
<p>&gt;&gt;&gt; What sort of servers and clients?</p>
<p>&gt;&gt;Whatever you feel like. If you want a server to split and serve audio,</p>
<p>&gt;&gt;you could do that.</p>
<p>&gt; This is streaming audio, right? For non-streaming I can just use an</p>
<p>&gt; ftp or http server.</p>
<p></p>
<p>There's more to network servers and clients than just audio &amp; video, or</p>
<p>unidirectional download.</p>
<p></p>
<p>For example the visualisation/introspection tool is an example of a</p>
<p>client server system. The server is the visualisation tool. It listens on a</p>
<p>specified port waiting for a connection. The client connects and sends</p>
<p>data to it about the internal structure, and the server displays this.</p>
<p></p>
<p>&gt;&gt;&gt;&gt;   * Quickly build Multicast based network servers and clients</p>
<p>&gt;&gt;&gt; Serving what? Could I use it, for example, to build an n-player</p>
<p>&gt;&gt;&gt; encrypted  VoIP server to allow people to do conference calls over</p>
<p>&gt;&gt;&gt; the Internet?</p>
<p>&gt;&gt;</p>
<p>&gt;&gt;You could do that probably. (Though we don't have a component</p>
<p>&gt;&gt;for audio capture (though a read file adaptor reading from /dev/audio</p>
<p>&gt;&gt;might work depending on your platform I suppose) and audio</p>
<p>&gt;&gt;encoding at the moment, so those would probably be the core</p>
<p>&gt;&gt;components to integrate.</p>
<p>&gt; </p>
<p>&gt; That's a slightly worrying answer for me, worrying because it seems</p>
<p>&gt; I've misunderstood the nature of the project. I assumed that</p>
<p>&gt; components for audio capture, and related activities, would be at</p>
<p>&gt; the heart of the project.</p>
<p></p>
<p>*Our* main interest, at the moment, is in /delivery/ of content. </p>
<p></p>
<p>Dealing with capture would be largely re-inventing wheels before we know</p>
<p>whether the framework is a suitable framework. We are looking at making it</p>
<p>possible to use pymedia for dealing with capture/encoding/decoding.</p>
<p></p>
<p>There's a number of things along the way we need to deal with this, but</p>
<p>we're not starting from the perspective of capture. </p>
<p></p>
<p>(After all for capture we can generally look at using dedicated encoder</p>
<p>hardware that will often spit out it's encoded information in the form of a</p>
<p>network connection. As a result capture and encoding hasn't been a priority</p>
<p>as yet. Sometimes looking into a project from the outside I can appreciate</p>
<p>that certain decisions might look strange, but consider that you don't need</p>
<p>to worry about capture in order </p>
<p></p>
<p>&gt;&gt;&gt; (I mean proper encryption here, the sort GCHQ or the NSA can't break)</p>
<p>&gt;&gt;</p>
<p>&gt;&gt;I'd be impressed if that could be written, using anything really. (Can't</p>
<p>&gt;&gt;implies never)</p>
<p>&gt; </p>
<p>&gt; What -- good encryption? That's pretty much a well-known technique</p>
<p>&gt; these days (unless the NSA has some *very* advanced hardware in</p>
<p>&gt; their basement, which I strongly suspect they don't).</p>
<p></p>
<p>You said *can't*. That says to me cannot ever be broken. If you have a large</p>
<p>number of listeners, as your statement implied, that implies decryptable by</p>
<p>many listeners - you then just need one compromised listener (essentially</p>
<p>you're asking for the equivalent of implementing a DRM system that the NSA</p>
<p>couldn't break...).</p>
<p></p>
<p>If you can provide me with a library that you can guarantee that it will</p>
<p>satisfy the following properties:</p>
<p></p>
<p>   encoded = F(data)</p>
<p></p>
<p>and a piece of client code that can do this:</p>
<p>   decoded = G(encoded)</p>
<p></p>
<p>Then yes, that can be wrapped. That's trivial in fact:</p>
<p>---(start)---</p>
<p>from magic import unbreakable_encryption</p>
<p></p>
<p>class encoder(component):</p>
<p>   def __init__(self, **args):</p>
<p>       self.encoder = unbreakable_encryption.encoder(**args)</p>
<p>   def main(self):</p>
<p>      while 1:</p>
<p>          if self.dataReady(&quot;inbox&quot;):</p>
<p>             data = self.recv(&quot;inbox&quot;)</p>
<p>             encoded = self.encoder.encode(data)</p>
<p>             self.send(encoded, &quot;outbox&quot;)</p>
<p>          yield 1</p>
<p></p>
<p>class decoder(component):</p>
<p>   def __init__(self, **args):</p>
<p>       self.decoder = unbreakable_encryption.decoder(**args)</p>
<p>   def main(self):</p>
<p>      while 1:</p>
<p>          if self.dataReady(&quot;inbox&quot;):</p>
<p>             data = self.recv(&quot;inbox&quot;)</p>
<p>             decoded = self.decoder.decode(data)</p>
<p>             self.send(decoded, &quot;outbox&quot;)</p>
<p>          yield 1</p>
<p>---(end)---</p>
<p></p>
<p>If you believe you can implement F&amp;G for general use such that F&amp;G</p>
<p>can //never// be decrypted by anyone other than authorised recipients, I</p>
<p>suggest you cease this conversation - you have some highly marketable</p>
<p>technology.</p>
<p></p>
<p>&gt;&gt;&gt;&gt;The basic underlying metaphor of a component us like an office worker</p>
<p>&gt;&gt;&gt;&gt;with inboxes and outboxes, with deliveries occuring between desks,</p>
<p>&gt;&gt;</p>
<p>&gt;&gt;&gt; That metaphor brings up an image (at least to me) that the sorts of</p>
<p>&gt;&gt;&gt; data that can be communicated are things like documents,</p>
<p>&gt;&gt;&gt; spreadsheets, business graphs, memos.</p>
<p>&gt;&gt;</p>
<p>&gt;&gt;They could indeed. The underlying framework doesn't differentiate</p>
<p>&gt;&gt;between data nor have any realtime aspect embedded in the system</p>
<p>&gt;&gt;at present. Just because we're focussing on systems that have a realtime</p>
<p>&gt;&gt;element and are multimedia based, this does not mean the system is</p>
<p>&gt;&gt;limited to that.</p>
<p>&gt; </p>
<p>&gt; Again, this makes me think I've misunderstood the project.</p>
<p></p>
<p>Realtime systems are a subset of all systems that are interesting in terms</p>
<p>of network delivery &amp; multimedia systems. Realtime scheduling is a well</p>
<p>known area and if/when this becomes an issue, we'll look at adding it into</p>
<p>the mix. The real problem is dealing with concurrency and making it simple</p>
<p>to work with. Making realtime concurrent systems easy to work with strikes</p>
<p>me as running before you can walk.</p>
<p></p>
<p>(Network systems are naturally concurrent, so if you're aiming to make</p>
<p>network systems easy to build you're really talking about making concurrent</p>
<p>systems easy to build.)</p>
<p></p>
<p>&gt;&gt;&gt; OK, I get the straming part of it. But what asbout non-streaming</p>
<p>&gt;&gt;&gt; stuff? What other protocols are necessary?</p>
<p>&gt;&gt;</p>
<p>&gt;&gt;One example is peer to peer mesh setup. People normally</p>
<p>&gt;&gt;think of P2P as a distribution mechanism. However, the underlying</p>
<p>&gt;&gt;approach also very good at setting up communications meshes.</p>
<p>&gt; </p>
<p>&gt; When you say a mesh, what do you mean?</p>
<p></p>
<p>I mean a mesh. (see below)</p>
<p></p>
<p>&gt;&gt;This could be of use in many areas, such as GRID based systems</p>
<p>&gt;&gt;for distributed rendering, application layer multicast, and network</p>
<p>&gt;&gt;multicast island joining.</p>
<p>&gt; Unpack, please.</p>
<p></p>
<p>They're all big systems, all of which utilise networks of collaborating</p>
<p>systems for different purposes.</p>
<p></p>
<p>Grid starting point:</p>
<p>   * http://en.wikipedia.org/wiki/Grid_computing</p>
<p></p>
<p>*short* introduction to application level multicast (has many names,</p>
<p>including overlay multicast):</p>
<p>   * http://www.mnlab.cs.depaul.edu/seminar/fall2002/Overcast.pdf</p>
<p>   * Also puts the term &quot;mesh&quot; in context.</p>
<p></p>
<p>Multicast island joining is a special case and is exactly what it says -</p>
<p>joining multicast islands together.</p>
<p></p>
<p>&gt;&gt;Due to the illegal /uses/ of P2P, much work in this area is difficult to</p>
<p>&gt;&gt;reuse due to defensive coding.</p>
<p>&gt; </p>
<p>&gt; Oh. Could you give an example?</p>
<p></p>
<p>How many RFCs have you seen documenting the protocols used by (say)</p>
<p>Napster, Bit Torrent, Gnutella, Limewire, Freenet? The legitimate uses of</p>
<p>Bit Torrent for example tend to get ignored by certain large companies</p>
<p>when trying to shut down systems.</p>
<p></p>
<p>&gt;&gt;We also have to be able to demonstrate system to other people</p>
<p>&gt;&gt;inside the BBC in a way non-technical people understand. That means</p>
<p>&gt;&gt;showing structures in a friendly dynamic way, showing pictures,</p>
<p>&gt;&gt;playing sounds (hence visualisation - looking inside running systems). </p>
<p>&gt; </p>
<p>&gt; Visualisation, if done properly, ought to be useful to technical</p>
<p>&gt; people too.</p>
<p></p>
<p>It is (as mention on the page describing the visualisation tool).</p>
<p></p>
<p>-------------------------------------------------------------------------------------------------------</p>
<p>&gt;&gt;Which aside from other things means you can't build (say) a video</p>
<p>&gt;&gt;&amp; SMIL playback system trivially, yet.</p>
<p>&gt; </p>
<p>&gt; Isn't SMIL something that's goinhg to go into web browsers? In which</p>
<p>&gt; case, you'd presumably not want to build one yourself, I imagine?</p>
<p></p>
<p>SMIL was used as an example to be illustrative of a class of networked</p>
<p>applications that require visual support. A more direct example</p>
<p>would be MHEG (not mpeg) decoding and display systems, which</p>
<p>have similarities to SMIL systems in terms of capabilities required.</p>
<p></p>
<p>&gt;&gt;It's designed to make bolting things together to make these sorts of</p>
<p>&gt;&gt;system simpler and easier.</p>
<p>&gt; </p>
<p>&gt; What you say &quot;bolting things together&quot; do you mean writing Python</p>
<p>&gt; code? </p>
<p></p>
<p>Yes.</p>
<p></p>
<p>&gt; Or will there be some other way? </p>
<p></p>
<p>A clicky pointy approach would be nice. (There's two sorts of interface in</p>
<p>the world IMO - &quot;tappity tappity&quot; and &quot;clicky pointy&quot; - if being equally</p>
<p>playfully disdainful :) Unix shell systems are very &quot;tappity tappity&quot;, and whilst I</p>
<p>can do &quot;tappity tappity&quot;, and have been doing &quot;tappity tappity&quot; for my</p>
<p>entiring working life, I do prefer &quot;clicky pointy&quot; systems.)</p>
<p></p>
<p>Though building systems using AR Toolkit type systems would be the ideal.</p>
<p>( http://www.hitl.washington.edu/people/poup/research/ar.htm#artoolkit )</p>
<p>That's probably a couple of years off though (at least).</p>
<p></p>
<p>&gt; What I have in mind is something like a project I worked on some</p>
<p>&gt; time ago, where a program could be written by drawing boxes on a GUI</p>
<p>&gt; application, and drawing lines (representing data flow) to connect</p>
<p>&gt; the boxes. So one half of a VoIP application might look like:</p>
<p>&gt; </p>
<p>&gt;   +----------+     +------------+     +-----------+</p>
<p>&gt;   | listen   |     | convert to |     | volume    |</p>
<p>&gt;   | on udp   |====&gt;| audio      |====&gt;| control + |</p>
<p>&gt;   | port 600 |     | stream     |     | output    |</p>
<p>&gt;   +----------+     +------------+     +-----------+</p>
<p></p>
<p>From example 4:</p>
<p></p>
<p>pipeline(</p>
<p>    Multicast_transceiver(&quot;0.0.0.0&quot;, 1600, &quot;224.168.2.9&quot;, 0),</p>
<p>    detuple(1),</p>
<p>    SRM_Receiver(),</p>
<p>    detuple(1),</p>
<p>    VorbisDecode(),</p>
<p>    AOAudioPlaybackAdaptor(),</p>
<p>).run()</p>
<p></p>
<p>Join multicast group &quot;224.168.2.9&quot;, listen for packets on port 1600, throw</p>
<p>away information relating to who sent it, pass it through a simple reliable</p>
<p>multicast reordering subsystem, throw away the annotation, decode the</p>
<p>vorbis, and playback.</p>
<p></p>
<p>The visual representation of that isn't dissimilar to your diagram above.</p>
<p></p>
<p>&gt; With something like this novel multimedia apps could be prototyped</p>
<p>&gt; quickly (though making them into useful apps would take extra work</p>
<p>&gt; -- in the case of a VoIP application you'd want a phonebook, for</p>
<p>&gt; example).</p>
<p></p>
<p>Agreed.</p>
<p></p>
<p>&gt;&gt;At the same time it's designed to encourage</p>
<p>&gt;&gt;writing code in a way that makes it simpler.</p>
<p>&gt; </p>
<p>&gt; Examples would be useful here. Both of what it can do now, and what</p>
<p>&gt; it will be able to do eventually.</p>
<p></p>
<p>Examples of what can be done now are here:</p>
<p>   * http://kamaelia.sourceforge.net/KamaeliaStatus.html</p>
<p></p>
<p>I'll think about the latter part of that. (I personally loath technologies</p>
<p>that promise much and deliver little. Hence why I like to focus on what</p>
<p>we /can/ do)</p>
<p></p>
<p>&gt;&gt;The natural side effect of</p>
<p>&gt;&gt;this is the  system might make it easier to take advantage of multiple</p>
<p>&gt;&gt;CPU systems as they come online, since it makes a system naturally</p>
<p>&gt;&gt;concurrent. As the original announcement said &quot;Kamaelia is designed as</p>
<p>&gt;&gt;a testbed&quot;. And by testbed I mean testbed as it testing out new ideas,</p>
<p>&gt;&gt;see if they work and see if they pan out. (Not as in a testing suite)</p>
<p>&gt; </p>
<p>&gt; So what it will eventually do is not cast in stone?</p>
<p></p>
<p>The high level goals are to solve the problems in the Challenges document.</p>
<p>We're not particularly wedded to any one particular approach, and Kamaelia</p>
<p>can/should be moulded to solve those problems, not the other way round.</p>
<p></p>
<p>By definition along the way a variety of components will be generated, which</p>
<p>can obviously be put together in an arbitrary fashion, assuming type</p>
<p>adaptors as necessary, to form new interesting systems.</p>
<p></p>
<p>This ability to explore new/interesting systems quickly is something</p>
<p>generally of value to an R&amp;D dept, so there's some people at BBC R&amp;D</p>
<p>interested in using Kamaelia for all sorts of interesting projects. (which I</p>
<p>can't discuss here)</p>
<p></p>
<p>&gt;&gt;Components are object instances of python classes. The data passed</p>
<p>&gt;&gt;between components are object instances.</p>
<p>&gt; </p>
<p>&gt; What sort of objects? </p>
<p></p>
<p>Python objects. Numbers, strings, chunks of audio in a string, chunks of</p>
<p>audio in a binary object wrapped by a python class, etc. Precisely as I</p>
<p>said.</p>
<p></p>
<p>&gt; For example, if an application is audio </p>
<p>&gt; straming, what sort of objects will be passed? </p>
<p></p>
<p>That depends on the level to which you dive inside the audio being</p>
<p>streamed. If you're trying to be a content agnostic streamer then you</p>
<p>don't care what's inside the byte stream (from, say, a file) just what the</p>
<p>bit rate is you're supposed to send at. (for that you can just chop up the</p>
<p>file and send it chunks at a time)</p>
<p></p>
<p>If however you're dealing with variable bit rate data you may wish to look</p>
<p>inside the wrapper to figure out the where data blocks are for a given time</p>
<p>period in order to send those. This (for example in the case of sending MPEG</p>
<p>over RTP) can mean that you need to parse the data stream in order to send</p>
<p>the data. At that point it makes sense to send over a structured object</p>
<p>representing each chunk/block/frame (depending on codec/transport).</p>
<p></p>
<p>&gt; Will there be onre </p>
<p>&gt; object passed for each 10 ms or so of sound, or will there be a</p>
<p>&gt; continuously-set-up object that passes the data throught it a byte</p>
<p>&gt; at a time?</p>
<p></p>
<p>Small messages turn out to be inefficient for what it's worth. (It's more</p>
<p>efficient to send bundles of small message or larger messages)</p>
<p></p>
<p>&gt; And if it's written in Python, will it run fast enough?</p>
<p></p>
<p>I've seen overlay mesh networks implemented in TCL shipping 60Mbit/s</p>
<p>(sustained) in the past, which if we're implementing an overlay joining</p>
<p>multicast islands together would mean multicasting the equivalent of ~200</p>
<p>channels through each node. Scaling is not always about throughput of</p>
<p>course - Bit Torrent's initial implementation was also in python, and scales</p>
<p>very well.</p>
<p></p>
<p>If it doesn't scale sufficiently we can always optimise specific subsystems</p>
<p>when we need to rather than prematurely optimise. Also we have done a</p>
<p>naive (deliberately naive) translation of the ideas into C++, including</p>
<p>generators, so if things don't pan out we have a natural migration path else</p>
<p>where. (After knowing whether the overall approach is workable or not)</p>
<p></p>
<p>&gt;       cdef class test(Axon.Component.component):</p>
<p>&gt;             def mainBody(self):</p>
<p>&gt;                   if self.dataReady(&quot;inbox&quot;):</p>
<p>&gt;                         data = self.recv(&quot;inbox&quot;)</p>
<p>&gt;                         self.send(data, &quot;outbox&quot;)</p>
<p>&gt;                   return 1</p>
<p>&gt; </p>
<p>&gt; My first impressions are that it seems obvious to me what this does:</p>
<p></p>
<p>A line of code is more often read than written, so if it's obvious, that's</p>
<p>good.</p>
<p></p>
<p>&gt; it merely passes its input throught to its output </p>
<p></p>
<p>Correct.</p>
<p></p>
<p>&gt; (no doubt there are places where such a null component is useful).</p>
<p></p>
<p>An echo protocol is one example - a server you connect to that simply echoes</p>
<p>back to you whatever you send it. (an echo server can be useful for all</p>
<p>sorts of network testing in practice)</p>
<p></p>
<p>&gt; Hopefully all code written with Kamaelia will be so clear.</p>
<p></p>
<p>See here for a longer example - which should show that generally speaking</p>
<p>things do tend to remain clear: http://tinyurl.com/dp8n7 (also shows how</p>
<p>you can incrementally develop new components).</p>
<p></p>
<p>&gt; Now I have some questions.</p>
<p>&gt; </p>
<p>&gt; 1. mainBody() is evidently being called at intervals. At what</p>
<p>&gt; frequency are these intervals? For example, if the data stram is</p>
<p>&gt; video data, will mainBody() get called once for each frame?</p>
<p></p>
<p>The scheduler is currently a dumb scheduler with essentially the following</p>
<p>logic:</p>
<p>   for thread in microthreads:</p>
<p>      thread.next()</p>
<p></p>
<p>As a result the time between calls is not guaranteed (nor can it be with</p>
<p>this sort of scheduler). The system does however allow for multiple</p>
<p>schedulers, so you could potentially have a realtime scheduler if it</p>
<p>was found to be necessary, at which point information about how a</p>
<p>component wished to be scheduled would become important.</p>
<p></p>
<p>&gt; 2. what data type is (data) in the code? Or can it be any type?</p>
<p></p>
<p>Any data type python handles. (as indicated above)</p>
<p></p>
<p>In case you're wondering &quot;why doesn't it do everything yet&quot;, I'll</p>
<p>just simply reiterate that we're at version 0.2, and we're getting</p>
<p>to the crawling/walking stage first before the walking/talking/running</p>
<p>stage :-)</p>
<p>---------------------------------------------------------------------------------------------------------------------------------</p>
<p></p>
<p>&gt; It seems as though all components basically have to do busy waiting now.</p>
<p></p>
<p>You are right - components are, for the most part, busy-waiting. Which</p>
<p>is not a good thing!</p>
<p>   * However the scheduler does periodic POSIX sched_yield calls</p>
<p></p>
<p>&gt; So do you plan on including a kind of scheduler-aware blocking</p>
<p>&gt; communication (like the `channels` of the `tasklets` in stackless)?</p>
<p>&gt;</p>
<p>&gt; (as you have a postman already - not a bad idea i think if you compare</p>
<p>&gt; with multi-agent-systems theory (see jade) - it could be responsible for</p>
<p>&gt; alerting the scheduler of box.has_data)</p>
<p></p>
<p>There is basic support for components to block, by calling the</p>
<p>self.pause() method. From the next yield, this blocks further execution</p>
<p>until data arrives on any inbox.</p>
<p></p>
<p>The un-pausing action is actually performed by code within the component</p>
<p>itself, though this is in effect, as you suggested it might be, instigated by</p>
<p>the postman microprocess.</p>
<p></p>
<p>A simple example would be an improved 'consoleEcho' component:</p>
<p></p>
<p>class consoleEchoer(Axon.Component.component):</p>
<p>    ....</p>
<p>    def main(self):</p>
<p>        while 1:</p>
<p>            yield 1</p>
<p>            while self.dataReady(&quot;inbox&quot;):</p>
<p>                print self.recv(&quot;inbox&quot;)</p>
<p>            self.pause()</p>
<p></p>
<p>That said, if you look at the code, you'll see that probably the</p>
<p>majority of components do not make good use of this yet!</p>
<p></p>
<p>There are quite probably better mechanisms around - hence the</p>
<p>distinction, in the code, between microprocesses and components.</p>
<p>We'd be very interested if yourself or other people want to play with</p>
<p>alternative communication &amp; blocking mechanisms.</p>
<p></p>
<p>I'd hope that even if the components and postboxes model doesn't</p>
<p>work out in the long run, the underlying generator based</p>
<p>microprocesses code could still be of some value to others!</p>
<p></p>
</body></html>
