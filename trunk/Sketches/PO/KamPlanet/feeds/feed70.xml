<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/'><id>tag:blogger.com,1999:blog-26152479</id><updated>2008-06-06T01:04:41.066-04:00</updated><title type='text'>mokelly's devlog</title><link rel='alternate' type='text/html' href='http://mjtokelly.blogspot.com/search/label/Python'/><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/posts/default/-/Python'/><author><name>Michael J.T. O'Kelly</name><uri>http://www.blogger.com/profile/14755674713265960802</uri><email>noreply@blogger.com</email></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>5</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-26152479.post-6919496462841788274</id><published>2008-03-15T16:43:00.005-04:00</published><updated>2008-03-15T19:39:48.375-04:00</updated><category scheme='http://www.blogger.com/atom/ns#' term='Python'/><title type='text'>stored_result(): automatic serialization of expensive calculations</title><content type='html'>A very common situation I encounter: "Do [expensive calculation] and pickle the result; unless it's been done before, in which case unpickle the stored result."  This stored_result() utility function makes that very easy, and provides some convenient options for scripting and memory management."&lt;br /&gt;&lt;blockquote&gt;&lt;pre&gt;&lt;br /&gt;def stored_results(pkl_filename, function, overwrite=0, verbose=1,&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;lazy=False, args=[], kwargs={}):&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;"""Returns contents of pickled file 'pkl_filename'.  If file does not exist&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;or is malformed, returns output of function (with args &amp;amp; kwargs) and pickles same&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result to pkl_filename.&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;If overwrite&amp;gt;0, runs function regardless of presence of 'pkl_filename'.&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;If lazy=True, instead outputs a generator that evaluates the rest of the stored_results()&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;call only when its next() method is called."""&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;import cPickle&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if lazy:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;# Create a generator that will eventually retrieve stored result&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;def result_gen():&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result = stored_results(pkl_filename, function, overwrite, verbose,&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;False, args, kwargs)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;while 1:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;yield result&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return result_gen()&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;else:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if not overwrite&amp;gt;0:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;try:&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inf = file(pkl_filename, 'rb')&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result = cPickle.load(inf)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;inf.close()&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if verbose: print pkl_filename, "successfully unpickled"&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return result&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;except (cPickle.UnpicklingError, IOError):&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if verbose: print "Result not stored.  Running function", function.func_name&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;result = function(*args, **kwargs)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;outf = file(pkl_filename, 'wb')&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;cPickle.dump(result, outf, -1)&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;outf.close()&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;if verbose: print "Result pickled to", pkl_filename&lt;br /&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;return result&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;/blockquote&gt;&lt;br /&gt;Typical use:&lt;br /&gt;&lt;span style="font-family: courier new;"&gt;result = stored_results('saved_result.pkl', expensive_function, args=(23, 'sweet'))&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;Advanced use:&lt;br /&gt;To perform the calculation/load the result in a just-in-time fashion:&lt;br /&gt;&lt;span style="font-family: courier new;"&gt;result_gen = stored_results('saved_result.pkl', expensive_function, args=(23, 'sweet'), lazy=True)&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family: courier new;"&gt;[memory-sensitive tasks that may or may not need the result]&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family: courier new;"&gt;result = result_gen.next()&lt;/span&gt;</content><link rel='alternate' type='text/html' href='http://mjtokelly.blogspot.com/2008/03/storedresult-automatic-serialization-of.html' title='stored_result(): automatic serialization of expensive calculations'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=26152479&amp;postID=6919496462841788274&amp;isPopup=true' title='0 Comments'/><link rel='replies' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/6919496462841788274/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/posts/default/6919496462841788274'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/26152479/posts/default/6919496462841788274'/><author><name>Michael J.T. O'Kelly</name><uri>http://www.blogger.com/profile/14755674713265960802</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-26152479.post-7067852223370512648</id><published>2007-05-21T16:01:00.000-04:00</published><updated>2007-05-21T18:51:42.369-04:00</updated><category scheme='http://www.blogger.com/atom/ns#' term='OCR'/><category scheme='http://www.blogger.com/atom/ns#' term='CAPTCHAs'/><category scheme='http://www.blogger.com/atom/ns#' term='PyTesser'/><category scheme='http://www.blogger.com/atom/ns#' term='Python'/><title type='text'>CAPTCHAs and Tesseract</title><content type='html'>&lt;a href="http://en.wikipedia.org/wiki/Captcha"&gt;CAPTCHAs&lt;/a&gt; always seem to come up in &lt;a href="http://developers.slashdot.org/article.pl?sid=06/09/04/2215210"&gt;discussions&lt;/a&gt; of OCR projects like &lt;a href="http://code.google.com/p/tesseract-ocr/"&gt;Tesseract&lt;/a&gt;, so I decided to test Tesseract to see if it was actually the next big thing in spammer technology.&lt;br /&gt;&lt;br /&gt;A commenter pointed me to a Berkeley effort to &lt;a href="http://www.cs.sfu.ca/%7Emori/research/gimpy/"&gt;defeat CAPTCHAs&lt;/a&gt; that handled 92% of a &lt;a href="http://www.cs.sfu.ca/%7Emori/research/gimpy/ez/"&gt;selection of text-images from 2002&lt;/a&gt; using a tailored OCR algorithm.  I used &lt;a href="http://code.google.com/p/pytesser/"&gt;PyTesser&lt;/a&gt; and &lt;a href="http://docs.python.org/lib/module-difflib.html"&gt;difflib&lt;/a&gt; to run through the images and check the results.&lt;br /&gt;&lt;br /&gt;Tesseract read the image correctly for 36 out of 191 images (19%), and was close (within one character) for 5 more.  Here are a few of the harder images it was able to crack:&lt;br /&gt;&lt;br /&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://bp3.blogger.com/_3FemuYC29V4/RlITIcYiSyI/AAAAAAAAAA8/9T8IaWKXICo/s1600-h/117.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://bp3.blogger.com/_3FemuYC29V4/RlITIcYiSyI/AAAAAAAAAA8/9T8IaWKXICo/s320/117.jpg" alt="" id="BLOGGER_PHOTO_ID_5067133566524214050" border="0" /&gt;&lt;/a&gt;&lt;br /&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://bp0.blogger.com/_3FemuYC29V4/RlIRksYiSwI/AAAAAAAAAAs/7DPsNtnuIsI/s1600-h/108.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://bp0.blogger.com/_3FemuYC29V4/RlIRksYiSwI/AAAAAAAAAAs/7DPsNtnuIsI/s320/108.jpg" alt="" id="BLOGGER_PHOTO_ID_5067131852832262914" border="0" /&gt;&lt;/a&gt;&lt;br /&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://bp1.blogger.com/_3FemuYC29V4/RlIRk8YiSxI/AAAAAAAAAA0/UwFUrCZHhOM/s1600-h/141.jpg"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://bp1.blogger.com/_3FemuYC29V4/RlIRk8YiSxI/AAAAAAAAAA0/UwFUrCZHhOM/s320/141.jpg" alt="" id="BLOGGER_PHOTO_ID_5067131857127230226" border="0" /&gt;&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;Tesseract had trouble most frequently on text that was more skewed, had lots of distracting dots, or white or black lines crisscrossing the words.  With a small amount of image preprocessing (removing speckles and narrow lines), it might do much better on this old set.  On modern CAPTCHAs, though, it's probably SOL.</content><link rel='alternate' type='text/html' href='http://mjtokelly.blogspot.com/2007/05/captchas-and-tesseract.html' title='CAPTCHAs and Tesseract'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=26152479&amp;postID=7067852223370512648&amp;isPopup=true' title='3 Comments'/><link rel='replies' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/7067852223370512648/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/posts/default/7067852223370512648'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/26152479/posts/default/7067852223370512648'/><author><name>Michael J.T. O'Kelly</name><uri>http://www.blogger.com/profile/14755674713265960802</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-26152479.post-6626381815452065236</id><published>2007-05-17T22:58:00.001-04:00</published><updated>2007-05-24T16:19:51.157-04:00</updated><category scheme='http://www.blogger.com/atom/ns#' term='OCR'/><category scheme='http://www.blogger.com/atom/ns#' term='PyTesser'/><category scheme='http://www.blogger.com/atom/ns#' term='Python'/><title type='text'>PyTesser: OCR for Python</title><content type='html'>In two years using Python, I never once searched for "Python X" without finding PyX, someone's labor of love making X easy to understand and use.   &lt;a href="http://videocapture.sourceforge.net/"&gt;Many&lt;/a&gt; &lt;a href="http://www.procoders.net/?p=22#pySVM"&gt;examples&lt;/a&gt;&lt;a href="http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/pyem/"&gt; &lt;/a&gt;&lt;a href="http://www.ar.media.kyoto-u.ac.jp/members/david/softwares/pyem/"&gt;come&lt;/a&gt; &lt;a href="http://pymedia.org/"&gt;to&lt;/a&gt; &lt;a href="http://pywinauto.pbwiki.com/"&gt;mind&lt;/a&gt;.  That's what hooked me when I started out: any tool I wanted was at my fingertips in 5 minutes, and &lt;span style="font-style: italic;"&gt;just worked.&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;Optical character recognition was just about the only exception.  So, I got excited when Google released &lt;a href="http://code.google.com/p/tesseract-ocr/"&gt;Tesseract OCR&lt;/a&gt;, a straightforward, relatively accurate OCR package written in C++.  Tesseract didn't have Python bindings, but it didn't take much work with &lt;a href="http://www.pythonware.com/products/pil/"&gt;PIL&lt;/a&gt; and &lt;a href="http://docs.python.org/lib/module-subprocess.html"&gt;subprocess&lt;/a&gt; to make it act like it did.&lt;br /&gt;&lt;br /&gt;Behold!  &lt;a href="http://code.google.com/p/pytesser/"&gt;PyTesser&lt;/a&gt;.&lt;br /&gt;&lt;br /&gt;&lt;a onblur="try {parent.deselectBloggerImageGracefully();} catch(e) {}" href="http://bp3.blogger.com/_3FemuYC29V4/Rk0evsYiSsI/AAAAAAAAAAM/JT55Az1IP38/s1600-h/fnord.GIF"&gt;&lt;img style="margin: 0px auto 10px; display: block; text-align: center; cursor: pointer;" src="http://bp3.blogger.com/_3FemuYC29V4/Rk0evsYiSsI/AAAAAAAAAAM/JT55Az1IP38/s200/fnord.GIF" alt="" id="BLOGGER_PHOTO_ID_5065738960578431682" border="0" /&gt;&lt;/a&gt;&lt;blockquote&gt;&gt;&gt;&gt; from pytesser import *&lt;br /&gt;&gt;&gt;&gt; image = Image.open('fnord.tif')  # Open image object using PIL&lt;br /&gt;&gt;&gt;&gt; print image_to_string(image)     # Run tesseract executable on image&lt;br /&gt;fnord&lt;br /&gt;&gt;&gt;&gt; print image_file_to_string('fnord.tif')&lt;br /&gt;fnord&lt;/blockquote&gt;</content><link rel='alternate' type='text/html' href='http://mjtokelly.blogspot.com/2007/05/pytesser-ocr-for-python.html' title='PyTesser: OCR for Python'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=26152479&amp;postID=6626381815452065236&amp;isPopup=true' title='13 Comments'/><link rel='replies' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/6626381815452065236/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/posts/default/6626381815452065236'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/26152479/posts/default/6626381815452065236'/><author><name>Michael J.T. O'Kelly</name><uri>http://www.blogger.com/profile/14755674713265960802</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-26152479.post-114512399696413310</id><published>2006-04-15T13:59:00.000-04:00</published><updated>2007-05-11T22:35:30.562-04:00</updated><category scheme='http://www.blogger.com/atom/ns#' term='Python'/><title type='text'>ITA Software puzzle: Word Rectangle</title><content type='html'>&lt;p&gt;A few months ago job ads for ITA Software were all over Boston's subways. Each ad said "&lt;a href="http://www.itasoftware.com/careers/eng/job1.php"&gt;Solve this, work here!&lt;/a&gt;" and gave a non-trivial programming puzzle. I'm not about to do better than the people behind Orbitz.com, but some of them looked fun to try.&lt;/p&gt;  &lt;blockquote&gt;&lt;span style=";font-family:Verdana,Arial,Helvetica,sans-serif;font-size:85%;"  &gt;"Write a program to find the largest possible rectangle of letters such that every row forms a word (reading left to right) and every column forms a word (reading top to bottom). Words should appear in this dictionary: &lt;a href="http://www.itasoftware.com/careers/WORD.LST"&gt;WORD.LST&lt;/a&gt; (1.66MB). Heuristic solutions that may not always produce a provably optimal rectangle will be accepted: seek a reasonable tradeoff of efficiency and optimality.&lt;/span&gt;"&lt;br /&gt;&lt;/blockquote&gt;  &lt;p&gt;So a 3x3 solution would be&lt;/p&gt;  &lt;blockquote style="font-family: monospace;"&gt;   &lt;p&gt;cat&lt;br /&gt;ate&lt;br /&gt;tea&lt;/p&gt; &lt;/blockquote&gt;  &lt;p&gt;My algorithm places letters in the matrix one at a time, checking to make sure each new letter forms part of a legitimate word in both the horizontal and vertical directions. That check would take ridiculously long if I had to search through the whole wordlist each time, so I do some preprocessing. The wordlist gets parsed into a tree, with the nth level branching on the nth letter of the word. The top level divides the tree by letter counts, since we know from the beginning how many letters our word should have. It takes a while to create the word tree, but once I have it, answering the question "What are the possible 4th letters of a 6-letter word that starts with 'tur'?" is very fast:&lt;/p&gt;  &lt;blockquote style="font-family: monospace;"&gt;   &lt;p&gt;&gt;&gt;&gt; dictionary[6]['t']['u']['r'].keys()&lt;br /&gt;['a', 'b', 'e', 'g', 'f', 'k', 'n', 'r', 't', 'v']&lt;/p&gt; &lt;/blockquote&gt;  &lt;p&gt;Now if we have a partial 7x7 solution like&lt;/p&gt;  &lt;blockquote&gt;   &lt;p&gt;&lt;span style="font-family:monospace;"&gt;acacias&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;coconut&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;acqui&lt;span style="font-weight: bold;"&gt;?&lt;/span&gt;&lt;br /&gt;&lt;/span&gt;&lt;/p&gt; &lt;/blockquote&gt;  we just find all the letters that can legally follow both 'au' and 'acqui':&lt;br /&gt;&lt;blockquote&gt; &lt;span style="font-family:monospace;"&gt;&gt;&gt;&gt; dictionary[7]['a']['u'].keys()&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;['c', 'b', 'd', 'g', 'k', 'l', 'n', 's', 'r', 't', 'x']&lt;br /&gt;&gt;&gt;&gt; dictionary[7]['a']['c']['q']['u']['i'].keys()&lt;br /&gt;['r', 't']&lt;br /&gt;&lt;/span&gt;&lt;/blockquote&gt;  So the &lt;span style="font-weight: bold;"&gt;?&lt;/span&gt; can be either an 'r' or a 't'.&lt;br /&gt;&lt;br /&gt;I tried making a few improvements on the brute-force approach. You might even call some of them 'heuristic'. First I always try &lt;a href="http://psyco.sourceforge.net/"&gt;Psyco&lt;/a&gt; with this sort of project to see if it has any effect. Psyco is a just-in-time compiler of Python into machine code. Python does some things a lot slower than the equivalent C, especially if you don't know much about its implementation. (E.g., string concatenation can be slow because Python makes an entire new string even if you add just one character to the end of an old one. This is a &lt;a href="http://www.python.org/doc/faq/general/#why-are-python-strings-immutable"&gt;Feature&lt;/a&gt;.)  Just adding &lt;span style="font-family:monospace;"&gt;psyco.full()&lt;/span&gt; to a program can dramatically speed it up, without having to know anything about the Python interpreter.&lt;br /&gt;&lt;br /&gt;Psyco helped with the first few iterations of my code, but once I optimized dictionary access in the inner loop it wasn't really improving matters. Disable it if you want to save a whole lot of memory.&lt;br /&gt;&lt;br /&gt;Next I changed the order in which branches are followed. Before, the letters were tried in whatever order they were kept in the hash table, i.e. arbitrarily. Now I made it follow the "thickest" children first (the ones with the most leaves). That seems to be faster for smaller rectangles.&lt;br /&gt;&lt;br /&gt;Eventually I tried paring down the children, keeping only the &lt;span style="font-style: italic;"&gt;n&lt;/span&gt; thickest at each branch.  For &lt;span style="font-style: italic;"&gt;n&lt;/span&gt;=3 this was really fast up to 7x7, but fails on 8x8.  Of course, with &lt;span style="font-style: italic;"&gt;n&lt;/span&gt;&lt;26 this is no longer guaranteed to find a solution if one exists. Possibly my scoring of the branches could be extended to some sort of A* search, but I think I'll move on to something else first. Anyway, here is the source code:&lt;br /&gt;&lt;br /&gt;&lt;a href="http://www.mit.edu/%7Emokelly/devlog/word_rectangle4.py"&gt;word_rectangle4.py version 0.1&lt;/a&gt;, 4/14/06&lt;br /&gt;&lt;br /&gt;For 7x7--my biggest so far-- it finds&lt;br /&gt;&lt;blockquote&gt;   &lt;span style="font-family:monospace;"&gt;strafer&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;taeniae&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;resters&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;antiflu&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;fiefdom&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;earlobe&lt;/span&gt;&lt;br /&gt;&lt;span style="font-family:monospace;"&gt;resumes&lt;/span&gt;&lt;br /&gt;&lt;/blockquote&gt;  A taeniae is a sort of ribbon.  (I just saved you ten seconds.)&lt;br /&gt;&lt;br /&gt;If you have ideas for improving my code (heuristically!) or have tried this yourself, leave a note.</content><link rel='alternate' type='text/html' href='http://mjtokelly.blogspot.com/2006/04/ita-software-puzzle-word-rectangle.html' title='ITA Software puzzle: Word Rectangle'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=26152479&amp;postID=114512399696413310&amp;isPopup=true' title='3 Comments'/><link rel='replies' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/114512399696413310/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/posts/default/114512399696413310'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/26152479/posts/default/114512399696413310'/><author><name>Michael J.T. O'Kelly</name><uri>http://www.blogger.com/profile/14755674713265960802</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-26152479.post-114512344822384564</id><published>2006-04-11T13:43:00.000-04:00</published><updated>2007-05-11T22:35:30.563-04:00</updated><category scheme='http://www.blogger.com/atom/ns#' term='Python'/><title type='text'>Bootstrap statistics in Python</title><content type='html'>&lt;p style="font-family: arial;"&gt;&lt;a href="http://www.mit.edu/%7Emokelly/devlog/bootstrap.py"&gt;bootstrap.py version 0.1&lt;/a&gt;, 3/08/06&lt;/p&gt;  &lt;p style="font-family: arial;"&gt;Python &lt;a href="http://www.google.com/search?hl=en&amp;q=python+bootstrap+statistics&amp;amp;btnG=Google+Search"&gt;didn't seem to have&lt;/a&gt; a straightforward published bootstrap statistics module, so here is my effort. &lt;/p&gt;  &lt;p style="font-family: arial;"&gt;Suppose you had 40 measurements&lt;/p&gt;  &lt;blockquote style="font-family: arial;"&gt;&lt;p style="font-family: courier new;"&gt;&gt;&gt;&gt; dist&lt;br /&gt;array([  9.95587335,  11.14893547,  12.07186714,   9.06794986,&lt;br /&gt;10.66503852,  10.7564387 ,  11.42936871,   9.72575509, …&lt;br /&gt;…11.41262324,   9.28556988,   8.01210309,   9.98832624])&lt;/p&gt;&lt;blockquote&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;/p&gt;&lt;/blockquote&gt;  &lt;p style="font-family: arial;"&gt;with standard deviation 0.912. What is the uncertainty in your measurement of std=.912? Might the underlying distribution have sigma=1? (There is an exact formula in this case for Gaussian samples, but that won't always be so; and besides, it's &lt;a href="http://mathworld.wolfram.com/StandardDeviationDistribution.html" title="a pain"&gt;a pain&lt;/a&gt;.)&lt;/p&gt;  &lt;p style="font-family: arial;"&gt;Bootstrap statistics assumes that our 40 data points completely describe the underlying distribution–a "non-parametric" distribution. This assumption gets better the more points we have, but has &lt;a href="http://mathworld.wolfram.com/BootstrapMethods.html"&gt;good statistical properties&lt;/a&gt; all the time.&lt;/p&gt;  &lt;p style="font-family: arial;"&gt;If the 40 points fully chararacterize our distribution, we can essentially do our experiment over and over again by resampling from those 40 points with replacement. Bootstrap.py does this very quickly using &lt;a href="http://www.scipy.org/"&gt;SciPy&lt;/a&gt;.  Given distribution &lt;i&gt;dist &lt;/i&gt;and an estimation function that takes a distribution and returns a number–such as &lt;i&gt;scipy.std()&lt;/i&gt;–bootstrap.py resamples &lt;i&gt;dist &lt;/i&gt;many many times and returns the mean and standard deviation of the estimate distribution.&lt;/p&gt;  &lt;blockquote style="font-family: courier new;"&gt;&lt;p&gt;&gt;&gt;&gt; import bootstrap&lt;br /&gt;&gt;&gt;&gt; print scipy.std(dist)&lt;br /&gt;0.911973669727&lt;br /&gt;&gt;&gt;&gt; print bootstrap.fast_bootstrap(scipy.std, dist)&lt;br /&gt;(0.89697434867588222, 0.10347317195461153)&lt;/p&gt;&lt;/blockquote&gt;  &lt;p style="font-family: arial;" align="left"&gt;What does this mean? If we had 1,000,000 data points, rather than just 40, then their standard deviation would most likely be in the interval 0.897 +- 0.103. This is consistent with sigma=1, which, you might have guessed, I used to generate the data.&lt;/p&gt;  &lt;ul style="font-family: arial;"&gt; &lt;li&gt;Bootstrap.py also lets you set error tolerance and a few other parameters.&lt;/li&gt;&lt;li&gt;Are you enticed?  Let me know if this was useful to you, or failed spectacularly.&lt;/li&gt;&lt;li&gt;Thanks to &lt;a href="http://gumuz.looze.net/"&gt;gumuz' devlog&lt;/a&gt; for making me want to share.&lt;/li&gt; &lt;/ul&gt;</content><link rel='alternate' type='text/html' href='http://mjtokelly.blogspot.com/2006/04/bootstrap-statistics-in-python.html' title='Bootstrap statistics in Python'/><link rel='replies' type='text/html' href='http://www.blogger.com/comment.g?blogID=26152479&amp;postID=114512344822384564&amp;isPopup=true' title='2 Comments'/><link rel='replies' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/114512344822384564/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://mjtokelly.blogspot.com/feeds/posts/default/114512344822384564'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/26152479/posts/default/114512344822384564'/><author><name>Michael J.T. O'Kelly</name><uri>http://www.blogger.com/profile/14755674713265960802</uri><email>noreply@blogger.com</email></author></entry></feed>