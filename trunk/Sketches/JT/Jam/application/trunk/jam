#! /usr/bin/env python
"""

Flow diagram
------------

          {Other Jam Instances}
                    |
              [UDP Receiver]
                    |
                 [DeOsc]
                    |
                [Splitter] => Send the right OSC messages to the right UI
                 |      |     elements, either throught a seperate component or
                 |      |     clever linkages
                 |      |
             [GUI Components]
              |            | 
 [Osc (Music Data)]    [Osc (Change Data)] => For example "Play a note now" is
        |                     |               music data, whereas "Joe User
        |                     |               inserted a note" is change data
        |                     |
   [UDP Sender]          [UDP Sender]
        |                     |
   {Music App}      {Other Jam Instances}

"""

try:
    import pypm
except ImportError:
    MIDI_AVAILABLE = False
else:
    MIDI_AVAILABLE = True

from optparse import OptionParser

from Kamaelia.Chassis.Graphline import Graphline
from Kamaelia.Chassis.Pipeline import Pipeline
from Kamaelia.Util.Clock import CheapAndCheerfulClock as Clock
from Kamaelia.Util.Backplane import Backplane, PublishTo, SubscribeTo
from Kamaelia.Util.Fanout import Fanout
from Kamaelia.Util.OneShot import OneShot
from Kamaelia.Util.Console import ConsoleEchoer

from Kamaelia.Apps.Jam.Protocol.Osc import Osc, DeOsc
from Kamaelia.Apps.Jam.Internet.NewDP import UDPReceiver, UDPSender, PostboxPeer
from Kamaelia.Apps.Jam.Internet.UDPDispatcher import UDPDispatcher
from Kamaelia.Apps.Jam.UI.XYPad import XYPad
from Kamaelia.Apps.Jam.Util.PeerSelector import PeerSelector

FPS = 60

#TODO: Move filters
#TODO: Filters should exit

import Axon
import sets

class AddPeerFilter(Axon.Component.component):
    def main(self):
        while 1:
            if self.dataReady("inbox"):
                data = self.recv("inbox")
                # Data is of the form ((oscAddr, oscArgs, timeTag),
                #                      (address, port))
                # oscArgs is either [port], or [address, port]
                if data[0][0].split("/")[-1] == "Connect":
                    oscArgs = data[0][1]
                    if len(oscArgs) == 1:
                        # oscArgs == [port]
                        address = data[1][0]
                        port = oscArgs[0]
                    else:
                        # oscArgs == [address, port]
                        address = oscArgs[0]
                        port = oscArgs[1]
                self.send((address, port), "outbox")
            if not self.anyReady():
                self.pause()
            yield 1

class XYFilter(Axon.Component.component):
    def __init__(self, padNumber=1):
        super(XYFilter, self).__init__()
        self.padNumber = padNumber

    def main(self):
        while 1:
            if self.dataReady("inbox"):
                data = self.recv("inbox")
                if data[0][0].find("/XY/%i/" % self.padNumber) >= 0:
                    self.send(data[0])
            if not self.anyReady():
                self.pause()
            yield 1

class PeerListFilter(Axon.Component.component):
    def main(self):
        while 1:
            if self.dataReady("inbox"):
                data = self.recv("inbox")
                if data[0][0].split("/")[-1] == "PeerList":
                    # OSC message flattens the peer list, so we need to group
                    # them into (address, port) tuples again
                    peerList = sets.Set()
                    for i in enumerate(data[0][1]):
                        # FIXME: Boy is this ugly...
                        if not i[0] % 2:
                            peerList.add((i[1], data[0][1][i[0]+1]))
                    self.send(peerList, "outbox")
            if not self.anyReady():
                self.pause()
            yield 1
            

        



if __name__ == "__main__":
    parser = OptionParser()
    parser.add_option("-a", "--osc-address", dest="oscAddress",
                help="The IP address to send OSC data to (default=127.0.0.1)")
    parser.add_option("-p", "--osc-port", dest="oscPort", type="int",
            help="The UDP port number to send OSC data to (default=2000)")
    parser.add_option("--listen-address", dest="listenAddress",
                      help="The IP address to listen for other connecting Jam clients on (default=127.0.0.1)")
    parser.add_option("--listen-port", dest="listenPort", type="int",
                      help="The UDP port number to listen for other connecting Jam clients on (default=2001)")
    parser.add_option("--remote-address", dest="remoteAddress",
                      help="The IP address of another Jam client to connect to (default=None)")
    parser.add_option("--remote-port", dest="remotePort", type="int",
                      help="The UDP port number of another Jam client to connect to (default=None)")
    parser.set_defaults(oscAddress="127.0.0.1", oscPort=2000,
                        listenAddress="127.0.0.1", listenPort=2001,
                        remoteAddress=None, remotePort=None)

    options, args = parser.parse_args()

    Pipeline(UDPReceiver(localaddr=options.listenAddress,
                         localport=options.listenPort),
             DeOsc(index=0),
             PublishTo("dataIn")).activate()

    Pipeline(Clock(float(1)/FPS),
             PublishTo("frameRateClock")).activate()

    Graphline(dataSub = SubscribeTo("dataIn"),
              fanout = Fanout(["addPeer", "peerList"]),
              addPeerFilter = AddPeerFilter(),
              peerListFilter = PeerListFilter(),
              osc = Osc("/Jam", 2),
              peerSelector = PeerSelector(options.listenPort),
              sender = PostboxPeer(),
              linkages = {("dataSub", "outbox"):("fanout", "inbox"),
                          ("fanout", "addPeer"):("addPeerFilter", "inbox"),
                          ("addPeerFilter","outbox"):("peerSelector", "addPeer"),
                          ("fanout", "peerList"):("peerListFilter", "inbox"),
                          ("peerListFilter", "outbox"):("peerSelector", "peerSet"),
                          ("peerSelector", "outbox"):("osc", "inbox"),
                          ("osc", "outbox"):("sender", "inbox")
                          }
              ).activate()

    Graphline(clockSub = SubscribeTo("frameRateClock"),
              xyPad = XYPad(messagePrefix = "/XY/1/", position = (0, 0)),
              localPub = PublishTo("localDataOut"),
              remotePub = PublishTo("remoteDataOut"),
              linkages = {("clockSub", "outbox"):("xyPad", "newframe"),
                          ("xyPad", "outbox"):("localPub", "inbox"),
                          ("xyPad", "localChanges"):("remotePub", "inbox")}
              ).activate()

    Graphline(dataSub = SubscribeTo("dataIn"),
              clockSub = SubscribeTo("frameRateClock"),
              xyFilter = XYFilter(1),
              xyPad = XYPad(messagePrefix = "/XY/2/", editable=False,
                            position=(120, 0)),
              localPub = PublishTo("localDataOut"),
              linkages = {("dataSub", "outbox"):("xyFilter", "inbox"),
                          ("xyFilter", "outbox"):("xyPad", "remoteChanges"),
                          ("clockSub", "outbox"):("xyPad", "newframe"),
                          ("xyPad", "outbox"):("localPub", "inbox")}
              ).activate()

    Pipeline(SubscribeTo("localDataOut"), Osc("/Jam"),
             UDPSender(receiver_addr=options.oscAddress,
                       receiver_port=options.oscPort)).activate()

    Graphline(remoteSub = SubscribeTo("remoteDataOut"),
              dataSub = SubscribeTo("dataIn"),
              fanout = Fanout(["addPeer", "peerList"]),
              addPeerFilter = AddPeerFilter(),
              osc = Osc("/Jam"),
              dispatcher = UDPDispatcher(),
              linkages = {("remoteSub", "outbox"):("osc", "inbox"),
                          ("osc", "outbox"):("dispatcher", "inbox"),
                          ("dataSub", "outbox"):("fanout", "inbox"),
                          ("fanout", "addPeer"):("addPeerFilter", "inbox"),
                          ("addPeerFilter","outbox"):("dispatcher", "addPeer"),
                          ("fanout", "peerList"):("peerListFilter", "inbox"),
                          ("peerListFilter", "outbox"):("dispatcher", "peerSet")
                          }
              ).activate()

    Backplane("dataIn").activate()
    Backplane("frameRateClock").activate()
    Backplane("localDataOut").activate()
    Backplane("remoteDataOut").activate()

    if options.remoteAddress and options.remotePort:
        Pipeline(OneShot(("/Jam/Connect", (options.listenPort))), Osc(),
                 UDPSender(receiver_addr=options.remoteAddress,
                           receiver_port=options.remotePort)
                ).activate()

    Axon.Scheduler.scheduler.run.runThreads()

    
             
