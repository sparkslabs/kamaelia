<html><head><meta name="qrichtext" content="1" /></head><body style="font-size:10pt;font-family:Sans Serif">
<p><a href="http://kamaelia.sourceforge.net/"><img align="right" src="cat.gif" alt="Kamaelia - BBC Open Source Network Platform"></a></p>
<p><span style="font-size:21pt">Axon.</span><span style="font-size:21pt;font-weight:600">Scheduler.py</span></p>
<p>Version: Axon 1.0</p>
<p><span style="font-weight:600">TODO: </span>Needs better test suite</p>
<p>You provide the scheduler with microthreads of microprocesses, and it runs them, clean and simple. This is usually handled by the component system via returning a newComponent value. An alternative is to call the component's activate method.</p>
<p>It also has a slow motion mode designed to help with debugging &amp; testing.</p>
<p></p>
<p><span style="font-size:14pt;font-weight:600">Pydoc Style Documentation</span></p>
<p>class scheduler(Axon.Microprocess.microprocess)</p>
<p>Method resolution order:</p>
<ul type="disc"><li>scheduler</li>
<li>Axon.Microprocess.microprocess</li>
<li>Axon.Axon.AxonObject</li>
<li>__builtin__.object</li></ul>
<p>Data and other attributes defined here:</p>
<ul type="disc"><li>run = &lt;Axon.Scheduler.scheduler object&gt; - this is the default scheduler</li></ul>
<p>Methods defined here:</p>
<p><span style="font-weight:600">__init__(self)</span></p>
<ul type="disc"><li>Creates a scheduler object. If scheduler.run has not been set, sets it. Class initialisation ensures that this object/class attribute is initialised - client modules always have access to a standalone scheduler.<br />Internal attributes:</li>
<ul type="disc"><li>time = time when this object was last active.</li>
<li>threads = list of threads to run.</li></ul>
<div>Whilst there can be more than one scheduler active in the general case you will NOT want to create a custom scheduler.</div></ul>
<p></p>
<p><span style="font-weight:600">main(self, slowmo=0)</span></p>
<ul type="disc"><li>This is the meat of the scheduler  - this actively loops round the threads that it has available to run, and runs them. The only control over the scheduler at present is a means to slow it down - ie run in slow motion.</li>
<div>The way this is run is as follows:</div>
<ul type="disc"><div>scheduler.run.runThreads(slowmo=/delay/)</div></ul>
<div></div>
<div>where delay is in seconds. If the delay is 0, the the system runs all the threads as fast as it can. If the delay is non zero - eg 0.5, then the system runs all the threads for one &quot;cycle&quot;, waits until the delay has passed, and then times again. Note : the delay is between the start points of cycles, and not between the start and end points of cycles. The delay is NOT 100% accurate nor guaranteed and can be extended by threads that take too long to complete. (Think of it as a &quot;hello world&quot; of soft-real time scheduling)</div></ul>
<p></p>
<p><span style="font-weight:600">runThreads(self, slowmo=0)</span></p>
<p></p>
<p><span style="font-size:14pt;font-weight:600">Testdoc Documentation</span></p>
<p>Needs major work. (See todo above!)</p>
<p></p>
<p></p>
<p>Michael, December 2004</p>
<p></p>
<p><hr></p>
<p><a href="http://www.opensource.org/docs/definition.php"> <img align=right border=0 height=31 src=http://opensource.org/trademarks/open_source_button.png width=88 ></a><a href="http://sourceforge.net"> <img align=right alt="SourceForge.net Logo" border=0 height=31 src=http://sourceforge.net/sflogo.php?group_id ></a></p>
</body></html>
