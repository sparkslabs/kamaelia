Index: Apps/GSOC_JMB_Publish/Gateway/scripts/__init__.py
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/scripts/__init__.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/scripts/__init__.py	(revision 6484)
@@ -0,0 +1,5 @@
+#
+# JMB_PUBLISH_GATEWAY
+#
+BPLANE_INBOX = 'INTERFACE_INBOX'
+BPLANE_CONTROL = 'INTERFACE_CONTROL'

Property changes on: Apps/GSOC_JMB_Publish/Gateway/scripts/__init__.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/scripts/http.py
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/scripts/http.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/scripts/http.py	(revision 6484)
@@ -0,0 +1,50 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+# Licensed to the BBC under a Contributor Agreement: JMB
+
+from Kamaelia.Chassis.ConnectedServer import ServerCore
+from Kamaelia.Support.Protocol.HTTP import HTTPProtocol
+from Kamaelia.Support.Protocol.HTTP import ReqTranslatorFactory
+from Kamaelia.Support.Protocol.HTTP import WSGILikeTranslator
+from Kamaelia.Protocol.HTTP.Handlers.Minimal import Minimal
+
+from Kamaelia.Apps.JMB.Publish.Gateway.translator import Translator
+
+import socket
+
+def constructHTTPServer(Config):
+    class StaticServer(Minimal):
+        indexfilename=Config.static.index
+        homedirectory=Config.static.homedirectory
+        def __init__(self, request):
+            super(StaticServer, self).__init__(request)
+    
+    routing = [[Config.static.url, StaticServer],
+               #FIXME:one of the translators will have to change its name
+               ['/', ReqTranslatorFactory(Translator, WSGILikeTranslator)]]
+    return ServerCore(
+        protocol=HTTPProtocol(routing),
+        port = 8080,
+        socketOptions=(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1),
+    )

Property changes on: Apps/GSOC_JMB_Publish/Gateway/scripts/http.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/scripts/interface.py
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/scripts/interface.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/scripts/interface.py	(revision 6484)
@@ -0,0 +1,234 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+"""
+This component is the interface between the HTTP code and the XMPP code in the
+Kamaelia Publish Gateway.  All messages it receives from the HTTP code will come
+in on the backplanes named in gate.__init__ (BPLANE_INBOX and BPLANE_CONTROL).
+
+A translator will register itself by sending a newBatch signal to the interface.
+Once the translator has registered, it will receive incoming messages from the
+peer it is communicating with.  The interface will continue to listen for incoming
+messages from that peer until the translator sends it a batchDone signal.
+
+The interface also serves to forward messages from translators to headstock
+to be sent to peers.  Since it currently just passes the messages on, BPLANE_INBOX
+may eventually be set up to forward messages to headstock directly.
+
+FIXME:  This component needs a timeout mechanism.  It will currently wait indefinitely
+until it receives a response.
+"""
+
+import Axon
+from Axon.CoordinatingAssistantTracker import coordinatingassistanttracker as cat
+
+from Axon.ThreadedComponent import threadedcomponent, threadedadaptivecommscomponent
+from Kamaelia.Util.Backplane import Backplane, SubscribeTo
+from Kamaelia.Chassis.Graphline import Graphline
+from Kamaelia.Apps.JMB.Common.IPC import userLoggedOut, batchDone, newBatch
+from Kamaelia.Apps.JMB.Common.Console import debug, info, warning
+from Kamaelia.Apps.JMB.Publish.Gateway.consts import BPLANE_INBOX, BPLANE_CONTROL
+from Kamaelia.Apps.JMB.Publish.Gateway.JIDLookup import setUserStatus
+
+from headstock.api.im import Message
+from headstock.api.jid import JID
+
+from BoxManager import BoxManager
+
+_logger_suffix = '.publish.gateway.interface'
+
+from Kamaelia.Util.Backplane import SubscribeTo
+from Kamaelia.Util.Console import ConsoleEchoer
+from Kamaelia.Chassis.Pipeline import Pipeline
+
+#  This component is a replacement for DummyMessageHandler in headstock's simplechat example
+
+class Interface(threadedadaptivecommscomponent):
+    ThisJID = None
+    Inboxes = {
+        'inbox' : 'Receive messages from a translator.'\
+                'Connected to the service named by BPLANE_NAME',
+        'control' : 'Receive shutdown messages from a translator',
+        'xmpp.inbox' : 'Receive messages from the XMPP message dispatcher',
+        'xmpp.control' : 'Receive signals from the XMPPHandler',
+        'xmpp.available' : 'Receive notification when a user becomes available',
+        'xmpp.unavailable' : 'Receive notification when a user becomes unavailable',
+    }
+    Outboxes = {
+        'xmpp.signal' : 'Send signals to the XMPPHandler',
+        'xmpp.outbox' : 'Send messages to the XMPPHandler to be sent out',
+        '_bplane_signal_in' : 'Send shutdown messages to the in backplane',
+        '_bplane_signal_control' : 'Send shutdown messages to the control backplane',
+        '_subscriber_signal_in' : 'Send shutdown messages to the in subscriber',
+        '_subscriber_signal_control' : 'Send shutdown messages to the control subscriber'
+    }
+    def __init__(self, **argd):
+        super(Interface, self).__init__(**argd)
+        self.transactions = {}
+        self.jids = {}
+        self.not_done = True
+    
+    def createSubcomponents(self):
+        """
+        This creates the necessary subcomponents to have messages sent to this component's
+        inbox and control box via a backplane.
+        """
+
+        self.bplane_in = Backplane(BPLANE_INBOX).activate()
+        self.bplane_control = Backplane(BPLANE_CONTROL).activate()
+        self.subscriber_in = SubscribeTo(BPLANE_INBOX).activate()
+        self.subscriber_control = SubscribeTo(BPLANE_CONTROL).activate()
+
+        Pipeline(
+            SubscribeTo(BPLANE_INBOX),
+            ConsoleEchoer(),
+        ).activate()
+
+        
+        self.link((self.subscriber_in, 'outbox'), (self, 'inbox'))
+        self.link((self.subscriber_control, 'outbox'), (self, 'control'))
+        
+        self.link((self, '_bplane_signal_in'), (self.bplane_in, 'control'))
+        self.link((self, '_bplane_signal_control'), (self.bplane_control, 'control'))
+        self.link((self, '_subscriber_signal_in'), (self.subscriber_in, 'control'))
+        self.link((self, '_subscriber_signal_control'), (self.subscriber_control, 'control'))
+    
+    def main(self):        
+        self.createSubcomponents()
+        
+
+        myjid = cat.getcat().retrieveValue("MYJID")
+        self.ThisJID = myjid
+
+        while self.not_done:
+            for msg in self.Inbox('control'):
+                self.handleMainControlBox(msg)
+                
+            for msg in self.Inbox('inbox'):
+                print "Message to send, I think"
+                self.handleMainInbox(msg)
+                
+            for msg in self.Inbox('xmpp.inbox'):
+                #The interface has a new message from a serving peer.  Get the bundle
+                #associated with the thread's translator and forward the message.
+                box_manager = self.transactions.get(unicode(msg.thread))
+                if box_manager:
+                    box_manager.send(msg, 'outbox')
+                else:
+                    warning('%s received with no box manager.' %  (msg),
+                            _logger_suffix)
+                    print dir(msg)
+                    for A in ['bodies', 'error', 'event', 'foreign', 'from_element', 'from_jid', 'lang', 'stanza_id', 'subjects', 'swap_jids', 'thread', 'timestamp', 'to_element', 'to_jid', 'type', 'wasOnError']:
+                        print A, "|",getattr(msg, A)
+                    for f in msg.foreign:
+                        print f.e
+
+
+            for msg in self.Inbox('xmpp.available'):
+                if msg.from_jid.nodeid() != self.ThisJID.nodeid():
+                    debug('%s available.' % (msg.from_jid), _logger_suffix)
+                    self.handleAvailable(msg)
+                else:
+                    debug('%s available.  No action taken.' % (msg.from_jid), _logger_suffix)
+            for msg in self.Inbox('xmpp.unavailable'):
+                self.handleUnavailable(msg)
+                info('User %s logged out.' % (msg.from_jid.nodeid()), _logger_suffix)
+                
+            if not self.anyReady() and self.not_done:
+                self.pause()
+        
+        self.sendSignals()
+    
+    def handleMainInbox(self, msg):
+        """This function will monitor the incoming inbox for new messages.  If the
+        message is an instance of InitialMessage, it will create a BoxManager that
+        will create the necessary outboxes and track the translator.  If it is a
+        headstock message, it will be forwarded out to be sent via XMPP."""
+        print "Message to send", msg
+        if isinstance(msg, Message):
+            #Forward the message on to headstock
+            print "FORWARDING TO HEADSTOCK", msg
+            self.send(msg, 'xmpp.outbox')
+        else:
+            warning('Unknown message %s received at interface.  Ignoring'
+                    % (msg), _logger_suffix)
+            
+    def handleMainControlBox(self, msg):
+        """This will handle incoming messages from various translators to signal that
+        they are done.  This will unlink this component from them and destroy all
+        associated boxes."""
+        if isinstance(msg, batchDone) and self.transactions.get(msg.batch_id):
+            bman.kill()
+            del self.transactions[msg.thread]
+            debug('Batch %s done.' % (msg.thread), _logger_suffix)
+        elif isinstance(msg, newBatch):
+            bman=BoxManager(self, msg.bundle, msg.batch_id)
+            self.transactions[msg.batch_id] = bman
+            bman.createBoxes(inboxes=None, outboxes=['outbox', 'signal'])
+            self.link((self, bman.outboxes['outbox']), (msg.bundle, 'xmpp_in'))
+            self.link((self, bman.outboxes['signal']), (msg.bundle, 'xmpp_control'))
+            
+            to_jid = msg.to_jid
+            if isinstance(to_jid, JID):
+                to_jid = to_jid.node_id()
+            elif not isinstance(to_jid, unicode):
+                to_jid = unicode(to_jid)
+            
+            self.jids[to_jid].append(msg.batch_id)
+        else:
+            warning('Unknown signal %s received at interface.  Ignoring'
+                    % (msg), _logger_suffix)
+            
+    def handleAvailable(self, pres):
+        """This function is called when a user comes online.  It will create an
+        entry in the JIDs dict that will associate threads with their JID."""
+        jid = pres.from_jid.nodeid()
+        self.jids[jid] = []
+        setUserStatus(jid, active=True)
+    
+    def handleUnavailable(self, pres):
+        """This function will be called when a user goes offline.  It will remove
+        all tracked resources associated with that user and set the user's status
+        in the database."""
+        jid = pres.from_jid.nodeid()
+        batches = self.jids.get(jid, None)
+        if not (batches is None):
+            for batch_id in batches:
+                bundle = self.transactions[batch_id]
+                bundle.send(userLoggedOut(batch_id), 'signal')
+                bundle.kill()
+                del self.transactions[batch_id]
+            del self.jids[jid]
+        else:
+            warning('JID %s went unavailable but is not logged in' \
+                    % (unicode(jid)), _logger_suffix)
+        setUserStatus(pres.from_jid, active=False)
+        
+    def sendSignals(self):
+        """Send out the signals to various components to indicate that this component
+        is shuttind down."""
+        self.send(self.signal, '_bplane_signal_in')
+        self.send(self.signal, '_bplane_signal_control')
+        self.send(self.signal, '_subscriber_signal_in')
+        self.send(self.signal, '_subscriber_signal_control')

Property changes on: Apps/GSOC_JMB_Publish/Gateway/scripts/interface.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/scripts/BoxManager.py
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/scripts/BoxManager.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/scripts/BoxManager.py	(revision 6484)
@@ -0,0 +1,113 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+
+class _BoxManager(object):
+    """
+    This object is used to represent a set of boxes in an adaptive comms component.
+    It may also store metadata about the transaction.
+    """
+    SendMethod=None
+    RecvMethod=None
+    DataReadyMethod=None
+    InboxAddMethod=None
+    InboxRmMethod=None
+    OutboxAddMethod=None
+    OutboxRmMethod=None
+    UnlinkMethod=None
+    
+    thread = None
+    
+    Translator = None
+    def __init__(self, **argd):
+        self.__dict__.update(**argd)
+        self.inboxes = {}
+        self.outboxes = {}
+
+    def createBoxes(self, inboxes=('inbox', 'control'), outboxes=('outbox', 'signal')):
+        """Create a set of inboxes and outboxes.  You will be responsible for linking
+        them."""
+        thread = self.thread
+        BOX_TEMPLATE='THREAD_%s_%s'
+        for box in inboxes or []:
+            self.inboxes[box] = self.InboxAddMethod(BOX_TEMPLATE % (thread, box))
+        for box in outboxes or []:
+            self.outboxes[box] = self.OutboxAddMethod(BOX_TEMPLATE % (thread, box))
+    def kill(self):
+        """Destroy and unlink all boxes that are managed by this box manager."""
+        self.UnlinkMethod(self.Translator)
+        self._destroy_boxes()
+    def recv(self, boxname):
+        """Receive a message from an inbox.  Maps a human-friendly boxname
+        to an AdaptiveCommsComponent boxname."""
+        return self.RecvMethod(self.inboxes[boxname])
+    def Inbox(self, boxname):
+        """Iterate over the messages in an inbox."""
+        while self.dataReady(boxname):
+            yield self.recv(boxname)
+    def dataReady(self, boxname):
+        """Checks to see if a box has ready data.  Maps a human-friendly boxname
+        to an AdaptiveCommsComponent boxname."""
+        return self.DataReadyMethod(self.inboxes[boxname])
+    def send(self, msg, boxname):
+        """Maps send a message using a human-friendly boxname that translates to
+        an AdaptiveCommsComponent boxname."""
+        self.SendMethod(msg, self.outboxes[boxname])
+    def __repr__(self):
+        return '<BoxManager for thread %s>' % (self.thread)        
+    def _get_done(self):
+        """Returns true if the managed translator is stopped.  Intended to be called
+        via the property done."""
+        return self.Translator._isStopped()
+    done = property(fget=_get_done)
+    def _destroy_boxes(self):
+        """Destroys all managed boxes without unlinking them."""
+        for box in self.inboxes:
+            self.InboxRmMethod(self.inboxes[box])
+        for box in self.outboxes:
+            self.OutboxRmMethod(self.outboxes[box])
+        #Recreate the box dictionaries in case we need to reuse this object
+        self.inboxes={}
+        self.outboxes={}
+
+def BoxManager(adap, translator=None, thread=None):
+    """This factory function will create a new box bundle with all the necessary
+    info about a component.  This is done this way to prevent circular references.
+    (the alternative would be to pass the adaptive comms component directly to the
+    box bundle)."""
+    if not isinstance(thread, str):
+        thread = str(thread)
+    bman = _BoxManager(
+        SendMethod = adap.send,
+        RecvMethod = adap.recv,
+        DataReadyMethod = adap.dataReady,
+        InboxAddMethod = adap.addInbox,
+        InboxRmMethod = adap.deleteInbox,
+        OutboxAddMethod = adap.addOutbox,
+        OutboxRmMethod = adap.deleteOutbox,
+        UnlinkMethod=adap.unlink,
+        thread = thread,
+        Translator=translator,
+    )
+    return bman

Property changes on: Apps/GSOC_JMB_Publish/Gateway/scripts/BoxManager.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/scripts/main.py
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/scripts/main.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/scripts/main.py	(revision 6484)
@@ -0,0 +1,56 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+# Licensed to the BBC under a Contributor Agreement: JMB
+
+from Kamaelia.Apps.JMB.Common.ConfigFile import DictFormatter, ParseConfigFile
+from Kamaelia.Apps.JMB.Common.Structs import ConfigObject
+from Kamaelia.Apps.JMB.Common.ServerSetup import initializeLogger
+
+from jabber import constructXMPPClient
+from http import constructHTTPServer
+from Kamaelia.Apps.JMB.Publish.Gateway.JIDLookup import connectToDB
+import optparse
+
+def main():
+    ConfigDict = ParseConfigFile('~/kpgate.ini', DictFormatter())
+    options = parseCmdOpts()
+    #print options
+    
+    Config = ConfigObject(ConfigDict, options)
+    initializeLogger()
+    
+    server = constructHTTPServer(Config)    
+    xmpp = constructXMPPClient(Config)
+    connectToDB(Config)
+    
+    xmpp.activate()
+    server.run()
+    
+def parseCmdOpts():
+    parser = optparse.OptionParser()
+    parser.add_option('-x', '--xmpp-verbose', dest='xmpp_verbose', action='store_true',
+                      help='Use this option to view each incoming and outgoing XMPP message')
+    (options, args) = parser.parse_args()
+    return options

Property changes on: Apps/GSOC_JMB_Publish/Gateway/scripts/main.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/scripts/jabber.py
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/scripts/jabber.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/scripts/jabber.py	(revision 6484)
@@ -0,0 +1,720 @@
+# -*- coding: utf-8 -*-
+#
+# JMB_PUBLISH_GATEWAY
+#
+"""
+This is an adapted version of Sylvain Hellegouarch's simplechat example.  It is used
+as the basis for Kamaelia Publish's XMPP code.  The original documentation is reproduced
+below.
+
+The majority of the code that needs to be read to understand this is in the Client
+component.
+
+Original documentation
+------------------------
+
+This module is a simple XMPP chat client demonstrating the use of headstock.
+Many Kamaelia components are created to manage different XMPP kind of stanzas.
+
+* RosterHandler:
+  * querying the server for the roster list
+  * if supported by server, asking for the last activity of each contact
+
+* DummyMessageHandler:
+  * sending a message typed into the console window
+  * printing to the console any received messages
+
+* DiscoHandler: 
+  * querying for the supported features by the server
+  * dispatching the result of the previous query to components interested in that event
+
+* ActivityHandler:
+  * dispatching to the RosterHandler the fact the server supports the feature
+
+* RegisterHandler:
+  * registring a new user using in-band registration if supported
+
+The actual XMPP client is the Client component that sets up the different
+dispatchers and handlers involved by liking each inbox to the expected outbox and
+vcie versa.
+
+FIXME
+---------
+This code desperately needs to be refactored and needs to have uneccessary functionality
+removed.  The code is good for an example, but not a production system.
+"""
+import re
+
+import Axon
+from Axon.CoordinatingAssistantTracker import coordinatingassistanttracker as cat
+
+from Axon.Component import component
+from Axon.AdaptiveCommsComponent import AdaptiveCommsComponent
+from Kamaelia.Chassis.Graphline import Graphline
+from Kamaelia.Chassis.Pipeline import Pipeline
+from Kamaelia.Util.Backplane import Backplane
+from Kamaelia.Util.Backplane import PublishTo, SubscribeTo
+from Kamaelia.Internet.TCPClient import TCPClient
+from Kamaelia.Util.Console import ConsoleReader
+from Axon.Ipc import shutdownMicroprocess, producerFinished
+
+from Kamaelia.Util.NullSink import nullSinkComponent
+from interface import Interface
+    
+from headstock.protocol.core.stream import ClientStream, StreamError, SaslError
+from headstock.protocol.core.presence import PresenceDispatcher
+from headstock.protocol.core.roster import RosterDispatcher, RosterNull
+from headstock.protocol.core.message import MessageDispatcher, MessageEchoer
+from headstock.protocol.extension.register import RegisterDispatcher
+from headstock.protocol.extension.activity import ActivityDispatcher
+from headstock.protocol.extension.discovery import DiscoveryDispatcher
+from headstock.protocol.extension.discovery import FeaturesDiscovery
+from headstock.api.jid import JID
+from headstock.api.im import Message, Body, Event
+from headstock.api.contact import Presence, Roster, Item
+from headstock.api import Entity
+from headstock.api.activity import Activity
+from headstock.api.registration import Registration
+from headstock.lib.parser import XMLIncrParser
+from headstock.lib.logger import Logger
+from headstock.lib.utils import generate_unique
+
+from bridge import Element as E
+from bridge.common import XMPP_CLIENT_NS, XMPP_ROSTER_NS, \
+    XMPP_LAST_NS, XMPP_DISCO_INFO_NS, XMPP_IBR_NS
+
+__all__ = ['Client']
+
+class RosterHandler(component):    # Now identical to headstock's simple chat example
+    Inboxes = {"inbox"        : "headstock.api.contact.Roster instance",
+               "control"      : "stops the component",
+               "pushed"       : "roster stanzas pushed by the server",
+               "jid"          : "headstock.api.jid.JID instance received from the server",
+               "ask-activity" : "request activity status to the server for each roster contact"}
+    
+    Outboxes = {"outbox"      : "UNUSED",
+                "signal"      : "Shutdown signal",
+                "message"     : "Message to send",
+                "result"      : "", 
+                "activity"    : "headstock.api.activity.Activity instance to send to the server"}
+
+    def __init__(self, from_jid):
+        super(RosterHandler, self).__init__() 
+        self.from_jid = from_jid
+        self.roster = None
+        print "NEW MYJID", self.from_jid
+        try:
+            cat.getcat().trackValue("MYJID", from_jid)
+        except Axon.AxonExceptions.NamespaceClash:
+            cat.getcat().updateValue("MYJID", self.from_jid)
+            print "MYJID", cat.getcat().retrieveValue("MYJID")
+
+    def initComponents(self):
+        # We subscribe to the JID backplane component
+        # that will inform us when the server has
+        # returned the per-session jid
+        sub = SubscribeTo("JID")
+        self.link((sub, 'outbox'), (self, 'jid'))
+        self.addChildren(sub)
+        sub.activate()
+
+        return 1
+
+    def main(self):
+        yield self.initComponents()
+
+        while 1:
+            while self.dataReady("control"):
+                mes = self.recv("control")
+                
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            if self.dataReady("jid"):
+                self.from_jid = self.recv('jid')
+                print "NEW MYJID", self.from_jid
+                try:
+                    cat.getcat().trackValue("MYJID", self.from_jid)
+                except Axon.AxonExceptions.NamespaceClash:
+                    cat.getcat().updateValue("MYJID", self.from_jid)
+                    print "MYJID", cat.getcat().retrieveValue("MYJID")
+
+            
+            if self.dataReady("pushed"):
+                roster = self.recv('pushed')
+                for nodeid in roster.items:
+                    self.send(Roster(from_jid=self.from_jid, to_jid=nodeid,
+                                     type=u'result', stanza_id=generate_unique()), 'result')
+                
+            if self.dataReady("inbox"):
+                roster = self.recv("inbox")
+                self.roster = roster
+                print "Your contacts:"
+                for nodeid in roster.items:
+                    contact = roster.items[nodeid]
+                    print "  ", contact.jid
+                    
+            if self.dataReady('ask-activity'):
+                self.recv('ask-activity')
+                if self.roster:
+                    for nodeid in self.roster.items:
+                        contact = roster.items[nodeid]
+                        a = Activity(unicode(self.from_jid), unicode(contact.jid))
+                        self.send(a, 'activity')
+
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+class WebMessageHandler(component): # NOT USED - REPLACED BY 'Interface' -- from interface import Interface
+    Inboxes = {"inbox"    : "headstock.api.contact.Message instance received from a peer",
+               "trans_inbox" : "Receive messages from the inbound translator",
+               "jid"      : "headstock.api.jid.JID instance received from the server",
+               "control"  : "stops the component",}
+    
+    Outboxes = {"outbox"  : "headstock.api.im.Message to send to the client",
+                "trans_outbox" : "Send messages to the outbound translator",
+                "signal"  : "Shutdown signal",
+                "proto" : "Send messages to the protocol manager",}
+
+    def __init__(self):
+        super(WebMessageHandler, self).__init__() 
+        self.from_jid = None
+
+    def initComponents(self):
+        sub = SubscribeTo("JID")
+        self.link((sub, 'outbox'), (self, 'jid'))
+        self.addChildren(sub)
+        sub.activate()
+
+    def main(self):
+        self.initComponents()
+        yield 1
+
+        while 1:
+            while self.dataReady("control"):
+                mes = self.recv("control")
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            if self.dataReady("jid"):
+                self.from_jid = self.recv('jid')
+                print "NEW MYJID", self.from_jid
+                try:
+                    cat.getcat().trackValue("MYJID", self.from_jid)
+                except Axon.AxonExceptions.NamespaceClash:
+                    cat.getcat().updateValue("MYJID", self.from_jid)
+                    print "MYJID", cat.getcat().retrieveValue("MYJID")
+
+            # Assumes that messages to/from translator are already fully formed headstock messages. (maybe valid)
+            for msg in self.Inbox('inbox'):       self.send(msg, 'trans_outbox')
+            for msg in self.Inbox('trans_inbox'): self.send(msg, 'outbox')
+
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+class DiscoHandler(component):
+    Inboxes = {"inbox"          : "UNUSED",
+               "control"        : "stops the component", 
+               "initiate"       : "event informing the component the client session is active",
+               "jid"            : "headstock.api.jid.JID instance received from the server",
+               "features.result": "headstock.api.discovery.FeaturesDiscovery instance from the server",}
+    
+    Outboxes = {"outbox"           : "UNUSED",
+                "signal"           : "Shutdown signal",
+                "features-disco"   : "headstock.api.discovery.FeaturesDiscovery query to the server",  
+                "features-announce": "headstock.api.discovery.FeaturesDiscovery informs"\
+                    "the other components about the features instance received from the server"}
+
+    def __init__(self, from_jid, to_jid):
+        super(DiscoHandler, self).__init__() 
+        self.from_jid = from_jid
+        self.to_jid = to_jid
+        print "NEW MYJID", self.from_jid
+        try:
+            cat.getcat().trackValue("MYJID", from_jid)
+        except Axon.AxonExceptions.NamespaceClash:
+            cat.getcat().updateValue("MYJID", self.from_jid)
+            print "MYJID", cat.getcat().retrieveValue("MYJID")
+
+    def initComponents(self):
+        sub = SubscribeTo("JID")
+        self.link((sub, 'outbox'), (self, 'jid'))
+        self.addChildren(sub)
+        sub.activate()
+
+        pub = PublishTo("DISCO_FEAT")
+        self.link((self, 'features-announce'), (pub, 'inbox'))
+        self.addChildren(pub)
+        pub.activate()
+
+        sub = SubscribeTo("BOUND")
+        self.link((sub, 'outbox'), (self, 'initiate'))
+        self.addChildren(sub)
+        sub.activate()
+
+        return 1
+
+    def main(self):
+        yield self.initComponents()
+
+        while 1:
+            if self.dataReady("control"):
+                mes = self.recv("control")
+                
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            if  self.dataReady("jid"):
+                self.from_jid = self.recv('jid')
+                print "NEW MYJID", self.from_jid
+                try:
+                    cat.getcat().trackValue("MYJID", self.from_jid)
+                except Axon.AxonExceptions.NamespaceClash:
+                    cat.getcat().updateValue("MYJID", self.from_jid)
+                    print "MYJID", cat.getcat().retrieveValue("MYJID")
+            
+            # When this box has some data, it means
+            # that the client is bound to the server
+            # Let's ask for its supported features then.
+            if self.dataReady("initiate"):
+                self.recv("initiate")
+                d = FeaturesDiscovery(unicode(self.from_jid), self.to_jid)
+                self.send(d, "features-disco")
+
+            # The response to our discovery query
+            # is a a headstock.api.discovery.FeaturesDiscovery instance.
+            # What we immediatly do is to notify all handlers
+            # interested in that event about it.
+            while self.dataReady('features.result'):
+                disco = self.recv('features.result')
+                print "Supported features:"
+                for feature in disco.features:
+                    print "  ", feature.var
+                self.send(disco, 'features-announce')
+
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+class ActivityHandler(component):
+    Inboxes = {"inbox"   : "headstock.api.discovery.FeaturesDiscovery instance",
+               "control" : "stops the component",
+               }
+    
+    Outboxes = {"outbox"            : "UNUSED",
+                "signal"            : "Shutdown signal",
+                "activity-supported": "when used this tells the RosterHandler it needs"\
+                    "to request the server for each contact's activity."\
+                    "This is only used when the server supports the feature",
+                }
+
+    def __init__(self):
+        super(ActivityHandler, self).__init__() 
+
+    def initComponents(self):
+        sub = SubscribeTo("DISCO_FEAT")
+        self.link((sub, 'outbox'), (self, 'inbox'))
+        self.addChildren(sub)
+        sub.activate()
+        
+        return 1
+
+    def main(self):
+        yield self.initComponents()
+
+        while 1:
+            if self.dataReady("control"):
+                mes = self.recv("control")
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            if self.dataReady("inbox"):
+                disco = self.recv("inbox")
+                support = disco.has_feature(XMPP_LAST_NS)
+                print "Activity support: ", support
+                if support:
+                    self.send('', "activity-supported")
+
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+class PresenceHandler(component):
+    Inboxes = {"inbox"       : "headstock.api.contact.Presence instance",
+               "control"     : "Shutdown the client stream",
+               "subscribe"   : "",
+               "unsubscribe" : "",
+'unavailable' : 'Receive notifications when another client becomes unavailable', #notinheadstock #unused
+'available': 'Receive notifications when another client becomes available'}      #notinheadstock #unused
+    
+    Outboxes = {"outbox" : "headstock.api.contact.Presence instance to return to the server",
+                "signal" : "Shutdown signal",
+                "roster" : "",
+                "log"    : "log",}
+    
+    def __init__(self):
+        super(PresenceHandler, self).__init__()
+
+    def main(self):
+        while 1:
+            if self.dataReady("control"):
+                mes = self.recv("control")
+                
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            if self.dataReady("subscribe"):
+                p = self.recv("subscribe")
+                p.swap_jids()
+
+                # Automatically accept any subscription requests
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'subscribed')
+                self.send(p, "outbox")
+                
+                # Automatically subscribe in return as well
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'subscribe')
+                self.send(p, "outbox")
+                
+            if self.dataReady("unsubscribe"):
+                p = self.recv("unsubscribe")
+                p.swap_jids()
+                
+                # We stop our subscription to the other user
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'unsubscribed')
+                self.send(p, "outbox")
+                
+                # We stop the other user's subscription
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'unsubscribe')
+                self.send(p, "outbox")
+
+                # We remove this user from our roster list
+                r = Roster(from_jid=p.from_jid, type=u'set')
+                i = Item(p.to_jid)
+                i.subscription = u'remove'
+                r.items[unicode(p.to_jid)] = i
+                self.send(r, 'roster')
+
+                # We tell the other user we're not available anymore
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'unavailable')
+                self.send(p, "outbox")
+            if self.dataReady('available'): # Changed to match logic of rest, but #notinheadstock
+                #print 'Presence handler received:'                               #notinheadstock
+                self.recv('available             ')                               #notinheadstock
+            if self.dataReady('unavailable'):                                     #notinheadstock
+                #print 'Presence handler received:'                               #notinheadstock
+                self.recv('unavailable')                                          #notinheadstock
+                
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+    
+
+class RegistrationHandler(component):
+    Inboxes = {"inbox"   : "headstock.api.registration.Registration",
+               "error"   : "headstock.api.registration.Registration",
+               "control" : "Shutdown the client stream",}
+    
+    Outboxes = {"outbox" : "headstock.api.registration.Registration",
+                "signal" : "Shutdown signal",
+                "log"    : "log",}
+    
+    def __init__(self, username, password):
+        super(RegistrationHandler, self).__init__()
+        self.username = username
+        self.password = password
+        self.registration_id = None
+
+    def main(self):
+        while 1:
+            if self.dataReady("control"):
+                mes = self.recv("control")
+                
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            if self.dataReady("inbox"):
+                r = self.recv('inbox')
+                if r.registered:
+                    print "'%s' is already a registered username." % self.username
+                elif self.registration_id == r.stanza_id:
+                    print "'%s' is now a registered user."\
+                        "Please restart the client without the register flag." % self.username
+                else:
+                    if 'username' in r.infos and 'password' in r.infos:
+                        self.registration_id = generate_unique()
+                        r = Registration(type=u'set', stanza_id=self.registration_id)
+                        r.infos[u'username'] = self.username
+                        r.infos[u'password'] = self.password
+                        self.send(r, 'outbox')
+                
+            if self.dataReady("error"):
+                r = self.recv('error')
+                print r.error
+
+            if not self.anyReady():
+                self.pause()
+
+            yield 1
+
+class Client(component):
+    Inboxes = {"inbox"      : "",
+               "jid"        : "",
+               "streamfeat" : "",
+               "control"    : "Shutdown the client stream",
+               "http-inbox" : "Receive messages to an HTTP Server",                #notinheadstock
+               "output" : "Forward messages to the WebMessageHandler"}             #notinheadstock
+    
+    Outboxes = {"outbox"  : "",
+                "forward" : "",
+                "log"     : "",
+                "doauth"  : "",
+                "signal"  : "Shutdown signal",
+                "lw-signal" : "Shutdown signal for WsgiLogWritable",             #notinheadstock
+                "doregistration" : ""}
+
+    def __init__(self, Config):                 #notinheadstock, perhaps more logical
+        super(Client, self).__init__() 
+        self.cfg = Config              # notinheadstock
+        self.jid = JID(
+            Config.xmpp.username,
+            Config.xmpp.domain,
+            Config.xmpp.resource)
+        self.username = Config.xmpp.username
+        self.password = Config.xmpp.password
+        self.server = Config.xmpp.server
+        self.port = Config.xmpp.port
+        self.client = None
+        self.graph = None
+        self.domain = Config.xmpp.domain
+        self.usetls = Config.xmpp.usetls
+        self.register = False         #notinheadstock - differnet logic-prevents register message
+        self.use_std_out = Config.options.xmpp_verbose    #notinheadstock
+
+    def passwordLookup(self, jid):
+        return self.password
+
+    def shutdown(self):
+        self.send(Presence.to_element(Presence(self.jid, type=u'unavailable')), 'forward')
+        self.send('OUTGOING : </stream:stream>', 'log')
+        self.send('</stream:stream>', 'outbox') 
+
+    def abort(self):
+        self.send('OUTGOING : </stream:stream>', 'log')
+        self.send('</stream:stream>', 'outbox')
+
+    def setup(self):
+        # Backplanes are like a global entry points that
+        # can be accessible both for publishing and
+        # recieving data. 
+        # In other words, a component interested
+        # in advertising to many other components that
+        # something happened may link one of its outbox
+        # to a PublishTo component's inbox.
+        # A component wishing to receive that piece of
+        # information will link one of its inbox
+        # to the SubscribeTo component's outbox.
+        # This helps greatly to make components more
+        # loosely connected but also allows for some data
+        # to be dispatched at once to many (such as when
+        # the server returns the per-session JID that
+        # is of interest for most other components).
+        Backplane("CONSOLE").activate()
+        Backplane("JID").activate()
+        # Used to inform components that the session is now active
+        Backplane("BOUND").activate()
+        # Used to inform components of the supported features
+        Backplane("DISCO_FEAT").activate()
+        
+
+        sub = SubscribeTo("JID")
+        self.link((sub, 'outbox'), (self, 'jid'))
+        self.addChildren(sub)
+        sub.activate()
+        
+        if self.use_std_out:                             #notinheadstock - unlikely to be an issue
+            log = Logger(stdout=True, name='XmppLogger') #notinheadstock
+        else:                                            #notinheadstock
+            log = nullSinkComponent()                    #notinheadstock
+        
+        # We pipe everything typed into the console
+        # directly to the console backplane so that
+        # every components subscribed to the console
+        # backplane inbox will get the typed data and
+        # will decide it it's of concern or not.
+        Pipeline(ConsoleReader(), PublishTo('CONSOLE')).activate()
+
+        #FIXME: This actually looks potentially a bust (changes class for all new instances)
+        #FIXME: That said, it's in headstock's example, so it shouldn't be a major issue...
+        # Add two outboxes ro the ClientSteam to support specific extensions.
+        ClientStream.Outboxes["%s.query" % XMPP_IBR_NS] = "Registration"
+        ClientStream.Outboxes["%s.query" % XMPP_LAST_NS] = "Activity"
+        ClientStream.Outboxes["%s.query" % XMPP_DISCO_INFO_NS] = "Discovery"
+
+        self.client = ClientStream(self.jid, self.passwordLookup, use_tls=self.usetls)
+
+        self.graph = Graphline(client = self,                                    # SAME
+                               console = SubscribeTo('CONSOLE'),                 # SAME
+                               logger = log,                                     # SAME*
+                               tcp = TCPClient(self.server, self.port),          # SAME
+                               xmlparser = XMLIncrParser(),                      # SAME
+                               xmpp = self.client,                               # SAME
+                               streamerr = StreamError(),                        # SAME
+                               saslerr = SaslError(),                            # SAME
+                               discohandler = DiscoHandler(self.jid, self.domain),# SAME
+                               activityhandler = ActivityHandler(),              # SAME
+                               rosterhandler = RosterHandler(self.jid),          # SAME
+                               registerhandler = RegistrationHandler(self.username, self.password),              # SAME
+                               # CHANGE (was DummyMessageHander)
+                               presencehandler = PresenceHandler(),              # SAME
+                               presencedisp = PresenceDispatcher(),              # SAME
+                               rosterdisp = RosterDispatcher(),                  # SAME
+                               msgdisp = MessageDispatcher(),                    # SAME
+                               discodisp = DiscoveryDispatcher(),                # SAME
+                               activitydisp = ActivityDispatcher(),              # SAME
+                               registerdisp = RegisterDispatcher(),              # SAME
+                               pjid = PublishTo("JID"),                          # SAME
+                               pbound = PublishTo("BOUND"),                      # SAME
+                               webhandler=Interface(ThisJID=self.jid), # EXTRA (replaces dummy)
+
+                                             # First set same as headstock simplechat example
+                               linkages = {('xmpp', 'terminated'): ('client', 'inbox'),
+                                           ('console', 'outbox'): ('client', 'control'),
+                                           ('client', 'forward'): ('xmpp', 'forward'),
+                                           ('client', 'outbox'): ('tcp', 'inbox'),
+                                           ('client', 'signal'): ('tcp', 'control'),
+                                           ("tcp", "outbox") : ("xmlparser", "inbox"),
+                                           ("xmpp", "starttls") : ("tcp", "makessl"),
+                                           ("tcp", "sslready") : ("xmpp", "tlssuccess"),
+                                           ("xmlparser", "outbox") : ("xmpp" , "inbox"),
+                                           ("xmpp", "outbox") : ("tcp" , "inbox"),
+                                           ("xmpp", "reset"): ("xmlparser", "reset"),
+                                           ("client", "log"): ("logger", "inbox"),
+                                           ("xmpp", "log"): ("logger", "inbox"),
+                                           ("xmpp", "jid"): ("pjid", "inbox"),
+                                           ("xmpp", "bound"): ("pbound", "inbox"),
+                                           ("xmpp", "features"): ("client", "streamfeat"),
+                                           ("client", "doauth"): ("xmpp", "auth"),
+                                           
+                                           # Registration - Same as headstock simplechat example
+                                           ("xmpp", "%s.query" % XMPP_IBR_NS): ("registerdisp", "inbox"),
+                                           ("registerdisp", "log"): ('logger', "inbox"),
+                                           ("registerdisp", "xmpp.error"): ("registerhandler", "error"),
+                                           ("registerdisp", "xmpp.result"): ("registerhandler", "inbox"),
+                                           ("registerhandler", "outbox"): ("registerdisp", "forward"),
+                                           ("client", "doregistration"): ("registerdisp", "forward"),
+                                           ("registerdisp", "outbox"): ("xmpp", "forward"),
+                                           
+                                           # Presence - DIFFERENCES FROM HEADSTOCK SIMPLE CHAT EXAMPLE NOTED BELOW.
+                                           ("xmpp", "%s.presence" % XMPP_CLIENT_NS): ("presencedisp", "inbox"),
+                                           ("presencedisp", "log"): ('logger', "inbox"),
+                                           ("presencedisp", "xmpp.subscribe"): ("presencehandler", "subscribe"),
+                                           ("presencedisp", "xmpp.unsubscribe"): ("presencehandler", "unsubscribe"),
+                                           ("presencehandler", "outbox"): ("presencedisp", "forward"),
+                                           ("presencehandler", "roster"): ("rosterdisp", "forward"),
+                                           ("presencedisp", "outbox"): ("xmpp", "forward"),
+                                           ("presencedisp", "xmpp.available") : ('webhandler', 'xmpp.available'),# ADDITION
+                                           ("presencedisp", 'xmpp.unavailable') : ('webhandler', 'xmpp.unavailable'),# ADDITION
+
+                                           # Roster - Same as headstock simplechat example
+                                           ("xmpp", "%s.query" % XMPP_ROSTER_NS): ("rosterdisp", "inbox"),
+                                           ("rosterdisp", "log"): ('logger', "inbox"),
+                                           ('rosterdisp', 'xmpp.set'): ('rosterhandler', 'pushed'),
+                                           ('rosterdisp', 'xmpp.result'): ('rosterhandler', 'inbox'),
+                                           ('rosterhandler', 'result'): ('rosterdisp', 'forward'),
+                                           ("rosterdisp", "outbox"): ("xmpp", "forward"),
+
+                                           # Discovery - Same as headstock simplechat example
+                                           ("xmpp", "%s.query" % XMPP_DISCO_INFO_NS): ("discodisp", "features.inbox"),
+                                           ("discodisp", "log"): ('logger', "inbox"),
+                                           ("discohandler", "features-disco"): ('discodisp', "features.forward"),
+                                           ("discodisp", "out.features.result"): ('discohandler', "features.result"),
+                                           ("discodisp", "outbox"): ("xmpp", "forward"),
+
+                                           # Message - DIFFERENCES FROM HEADSTOCK SIMPLE CHAT EXAMPLE NOTED BELOW.
+                                           ("xmpp", "%s.message" % XMPP_CLIENT_NS): ("msgdisp", "inbox"),
+                                           ("msgdisp", "log"): ('logger', "inbox"),
+                                           ("msgdisp", "xmpp.chat"): ('webhandler', 'xmpp.inbox'),          # CHANGE
+                                           ("webhandler", "xmpp.outbox"): ('msgdisp', 'forward'),           # CHANGE
+                                           ("msgdisp", "outbox"): ("xmpp", "forward"),
+
+                                           # Activity - Same as headstock simplechat example
+                                           ("xmpp", "%s.query" % XMPP_LAST_NS): ("activitydisp", "inbox"),
+                                           ("activitydisp", "log"): ('logger', "inbox"),
+                                           ("activitydisp", "outbox"): ("xmpp", "forward"),
+                                           ("activityhandler", 'activity-supported'): ('rosterhandler', 'ask-activity'),
+                                           ("rosterhandler", 'activity'): ('activitydisp', 'forward'),
+                                           }
+                               )
+        self.addChildren(self.graph)
+        self.graph.activate()
+
+        return 1
+
+    def main(self):
+        yield self.setup()
+
+        while 1:
+            if self.dataReady("control"):
+                mes = self.recv("control")
+
+                if isinstance(mes, str):
+                    if mes.strip() == 'quit':
+                        self.shutdown()
+                elif isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(mes, "signal")
+                    break
+
+            if self.dataReady("inbox"):
+                msg = self.recv('inbox')
+                if msg == "quit":
+                    self.send(shutdownMicroprocess(), "signal")
+                    yield 1
+                    break
+
+            if self.dataReady("streamfeat"):
+                feat = self.recv('streamfeat')
+                if feat.register and self.register:
+                    self.send(Registration(), 'doregistration')
+                elif self.register and not feat.register:
+                    print "The server does not support in-band registration. Closing connection."
+                    self.abort()
+                else:
+                    self.send(feat, 'doauth')
+                
+            if self.dataReady("jid"):
+                self.jid = self.recv('jid')
+                
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+        yield 1
+        self.stop()
+        print "You can hit Ctrl-C to shutdown all processes now." 
+
+def constructXMPPClient(Config): #FIXME: Irrelevant factory function
+    return Client(Config)
+
+print __name__
+
+if __name__ == '__main__':
+    main()

Property changes on: Apps/GSOC_JMB_Publish/Gateway/scripts/jabber.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/make-unix.sh
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/make-unix.sh	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/make-unix.sh	(revision 6484)
@@ -0,0 +1,58 @@
+#!/bin/sh
+#
+# JMB_PUBLISH_GATEWAY
+#
+#make-unix.sh
+#usage:  ./make-unix.sh [clean] [include-files]
+#This script will first run scripts/publish.prepare.sh to assemble all of the relevant
+#files into the assembly directory and strip the .svns from them.  It will then remove
+#every pyc from the assembly directory.  Once this is finished, it will zip all the
+#source files, byte compiled modules, and optimized modules as well as any other
+#files that were named in include-files at the command line.  After this, the script
+#will concatenate this zip file with zipheader.unix creating the executable (which
+#will be moved to the zip directory).
+#
+#If clean was specified at the command line, the script will remove the assembly directory
+#once it is finished.  It is recommended that you remove the assembly directory prior to
+#running this script again.
+
+./prepare.sh #assemble everything we need in the assembly directory
+#python byte-compile.py urls.py main.py ServerConfig.py
+
+if [ "$1" = "clean" ]
+then
+    CLEANUP=$1
+    shift 1
+else
+    CLEANUP="empty"
+fi
+
+
+
+(
+cd assembly
+echo ">Removing any previously compiled modules"
+rm -rfv assembly/*.pyc
+echo ">Creating executable"
+find . -name "*.py"|zip -@ kpublish.zip
+find . -name "*.cfg"|zip -@g9 kpublish.zip
+find . -name "*.ini"|zip -@g9 kpublish.zip
+find . -name "*.tar" | zip -@g9 kpublish.zip
+#find . -name "*.pyc"|zip -@g kpublish.zip
+#find . -name "*.pyo"|zip -@g kpublish.zip
+cat zipheader.unix kpublish.zip > kpublish
+
+if [ ! -d ../dist ]
+then
+    mkdir ../dist
+fi
+
+mv kpublish ../dist
+chmod a+x ../dist/kpublish
+)
+
+if [ "$CLEANUP" = "clean" ]
+then
+    echo ">Cleaning up!"
+    rm -rf assembly
+fi

Property changes on: Apps/GSOC_JMB_Publish/Gateway/make-unix.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/prepare.sh
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/prepare.sh	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/prepare.sh	(revision 6484)
@@ -0,0 +1,39 @@
+#!/bin/sh
+#
+# JMB_PUBLISH_GATEWAY
+#
+#This shell script will check to see if an assemly directory already exits and create
+#one if not.  It will then copy all of the relevant files over to the assembly directory.
+
+echo "Creating staging area for building"
+if [ ! -d assembly ]
+then
+    mkdir assembly
+else
+    rm -rf assembly
+    mkdir assembly
+fi
+echo "----------------------------------------------------"
+echo "Assembling Axon/Kamaelia files"
+echo "----------------------------------------------------"
+
+echo "Copying Axon from branch to assembly directory"
+cp -R ../../../Axon/Axon/ assembly/Axon
+echo "Copying Kamaelia from branch to assembly directory"
+cp -R ../../../Kamaelia/Kamaelia/ assembly/Kamaelia
+echo "Copying zipheader.unix to assembly directory"
+cp zipheader.unix assembly/zipheader.unix
+echo "Copying scripts into the assembly directory"
+cp -R scripts/* assembly
+echo "Copying plugins to the assembly directory"
+cp -R plugins assembly/plugins
+echo "Tarring configuration data."
+(
+    cd data
+    mkdir ../assembly/data
+    tar -cvvf ../assembly/data/kpuser.tar kpuser kp.ini --exclude=.svn
+)
+
+echo "----------------------------------------------------"
+echo "Done preparing!"
+echo "----------------------------------------------------"

Property changes on: Apps/GSOC_JMB_Publish/Gateway/prepare.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/data/kp.ini
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/data/kp.ini	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/data/kp.ini	(revision 6484)
@@ -0,0 +1,41 @@
+#
+# JMB_PUBLISH_GATEWAY
+#
+# This file needs to be moved to:
+#
+#   ~/kpgate.ini
+#
+
+[SERVER]
+PORT: 8080
+#Uncomment the below line if you want to use custom routing
+PYPATH_APPEND: ~/kpuser:~/kpuser/Apps
+LOG: ~/kpuser/kp.log
+# This needs to be a valid path to a valid sqllite (or similar) database.
+# Needs a tool for creating it tbh
+db: sqlite:///kpgate.db
+
+[STATIC]
+url: /static
+homedirectory: ~/kpuser/www
+index: index.html
+
+[WSGI]
+SERVER_SOFTWARE: Kamaelia Publish v 0.0.1
+SERVER_ADMIN: Jason Baker
+WSGI_VER: 1.0
+URL_LIST: ~/kpuser/urls.ini
+LOG: ~/kpuser/kp.log
+
+#
+# Uncomment the following sections to set up your XMPP account. For
+# simplicity's sake, this section assumes you're going to use your google
+# talk account. This may be invalid. I don't know.
+#
+[XMPP]
+username: the_bit_before_the_at_symbol
+domain: gmail.com
+address: talk.google.com:5222
+password: this_is_your_password_in_plain_text
+#uncomment the following line if your server uses tls
+usetls: True

Property changes on: Apps/GSOC_JMB_Publish/Gateway/data/kp.ini
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/data/kpuser/urls.ini
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/data/kpuser/urls.ini	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/data/kpuser/urls.ini	(revision 6484)
@@ -0,0 +1,32 @@
+#
+# JMB_PUBLISH_GATEWAY
+#
+#This is the default url list.  The items here are generally in the form:
+#[section_name]
+#regex:  application regex pattern (will be split by '/')
+#import_path:  path to import object from
+#app_object:  Attribute name of the WSGI application object in the given module
+#
+#Please note that this file MUST contain a section error_404 and that section
+#MUST NOT contain a regex.  It will be assigned a regex of '.*' automatically
+#by the UrlList parser.
+#
+#Also, please note that order IS important here.  You must put your applications
+#in the order you want them evaluated (error_404 will always be handled last no
+#matter what).
+
+[static_files]
+regex: static
+import_path: Kamaelia.Support.WsgiApps.Static
+app_object: static_app
+static_path: ~/www
+index_file: index.html
+
+[simple_app]
+regex: simple
+import_path: Kamaelia.Support.WsgiApps.Simple
+app_object: simple_app
+
+[error_404]
+import_path: Kamaelia.Support.WsgiApps.ErrorHandler
+app_object: application

Property changes on: Apps/GSOC_JMB_Publish/Gateway/data/kpuser/urls.ini
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/data/kpuser/kp.log
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/data/kpuser/kp.log	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/data/kpuser/kp.log	(revision 6484)
@@ -0,0 +1,5 @@
+#
+# JMB_PUBLISH_GATEWAY
+#
+==Kamaelia Publish Log==
+

Property changes on: Apps/GSOC_JMB_Publish/Gateway/data/kpuser/kp.log
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/util/kpgate.db
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: Apps/GSOC_JMB_Publish/Gateway/util/kpgate.db
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream

Index: Apps/GSOC_JMB_Publish/Gateway/util/kpgate.ini
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/util/kpgate.ini	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/util/kpgate.ini	(revision 6484)
@@ -0,0 +1,41 @@
+#
+# JMB_PUBLISH_GATEWAY
+#
+# This file needs to be moved to:
+#
+#   ~/kpgate.ini
+#
+
+[SERVER]
+PORT: 8080
+#Uncomment the below line if you want to use custom routing
+PYPATH_APPEND: ~/kpuser:~/kpuser/Apps
+LOG: ~/kpuser/kp.log
+# This needs to be a valid path to a valid sqllite (or similar) database.
+# Needs a tool for creating it tbh
+db: sqlite:///kpgate.db
+
+[STATIC]
+url: /static
+homedirectory: ~/kpuser/www
+index: index.html
+
+[WSGI]
+SERVER_SOFTWARE: Kamaelia Publish v 0.0.1
+SERVER_ADMIN: Jason Baker
+WSGI_VER: 1.0
+URL_LIST: ~/kpuser/urls.ini
+LOG: ~/kpuser/kp.log
+
+#
+# Uncomment the following sections to set up your XMPP account. For
+# simplicity's sake, this section assumes you're going to use your google
+# talk account. This may be invalid. I don't know.
+#
+[XMPP]
+username: the_bit_before_the_at_symbol
+domain: gmail.com
+address: talk.google.com:5222
+password: this_is_your_password_in_plain_text
+#uncomment the following line if your server uses tls
+usetls: True

Property changes on: Apps/GSOC_JMB_Publish/Gateway/util/kpgate.ini
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/util/kpgate.db.orig
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

Property changes on: Apps/GSOC_JMB_Publish/Gateway/util/kpgate.db.orig
___________________________________________________________________
Added: svn:mime-type
   + application/octet-stream
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Gateway/zipheader.unix
===================================================================
--- Apps/GSOC_JMB_Publish/Gateway/zipheader.unix	(revision 0)
+++ Apps/GSOC_JMB_Publish/Gateway/zipheader.unix	(revision 6484)
@@ -0,0 +1,30 @@
+#!/bin/sh
+#
+# JMB_PUBLISH_GATEWAY
+#
+# The majority of this code comes from:
+# Python Cookbook, 2nd ed., by Alex Martelli, Anna Martelli Ravenscroft, and David Asher
+# (O'Relly Media, 2005) 0-596-00797-3
+# Section 16.12 credited to Joerg Raedler
+#
+
+PYTHON=$(which python 2>/dev/null)
+
+if [ -x "x$PYTHON" ] ; then
+    echo "python executable not found - cannot continue!"
+    exit 1
+fi
+
+exec $PYTHON -c "
+
+import sys, os
+version = sys.version_info[:2]
+if version < (2,3):
+    print 'Sorry, need python 2.3 or better; %s%s is too old' % version
+    sys.exit(1)
+sys.path.insert(0, sys.argv[1])
+del sys.argv[0]
+
+import main
+
+main.main()" $0 $@

Property changes on: Apps/GSOC_JMB_Publish/Gateway/zipheader.unix
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/scripts/transactions.py
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/scripts/transactions.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/scripts/transactions.py	(revision 6484)
@@ -0,0 +1,279 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_PEER
+#
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+"""
+==========================
+TransactionManager
+==========================
+
+This component will manage all the various transactions going on at any given
+point in time.  A transaction represents an HTTP request and response transaction.
+Note that of course the actual HTTP request and response don't actually happen
+here in this program.  They happen at the gateway.
+
+Upon receiving a message that is a part of a thread the TransactionManager has
+not encountered yet, a new BoxBundle is created to represent the transaction.
+In addition, a translator is created to translate data passed back and forth
+between the TransactionManager and the resource handler (that will be created
+by the translator).
+
+FIXME
+------------
+This should really be made to look more like the gateway's interface in a lot of
+respects.
+"""
+import Axon
+from Axon.CoordinatingAssistantTracker import coordinatingassistanttracker as cat
+
+from Axon.ThreadedComponent import threadedadaptivecommscomponent
+from Kamaelia.Util.Backplane import SubscribeTo
+
+from Kamaelia.Apps.JMB.Publish.Peer.translator import TranslatorChassis, \
+    RequestDeserializer, ResponseSerializer, SimpleHandler
+
+from headstock.api.im import Message, Thread, Body
+
+class _BoxBundle(object):
+    """
+    This object is used to represent a set of boxes in an adaptive comms component.
+    It may also store metadata about the transaction.
+    """
+    SendMethod=None
+    RecvMethod=None
+    DataReadyMethod=None
+    InboxAddMethod=None
+    InboxRmMethod=None
+    OutboxAddMethod=None
+    OutboxRmMethod=None
+    
+    thread = None
+    
+    Translator = None
+    def __init__(self, **argd):
+        self.__dict__.update(**argd)
+        self.box_dict = {}
+        self.inbox = ''
+        self.outbox = ''
+        self.control = ''
+        self.signal = ''
+
+    def createBoxes(self):
+        thread = str(self.thread)
+        self.inbox = self.InboxAddMethod('THREAD_' + self.thread + '_INBOX')
+        self.control = self.InboxAddMethod('THREAD_' + self.thread + '_CONTROL')
+        self.signal = self.OutboxAddMethod('THREAD_' + self.thread + '_SIGNAL')
+        self.outbox = self.OutboxAddMethod('THREAD_' + self.thread + '_OUTBOX')
+    def destroyBoxes(self):
+        self.UnlinkMethod(self.Translator)
+        self.InboxRmMethod(self.inbox)
+        self.InboxRmMethod(self.control)
+        self.OutboxRmMethod(self.signal)
+        self.OutboxRmMethod(self.outbox)
+        
+    def recv(self, boxname):
+        return self.RecvMethod(self.__dict__[boxname])
+    def Inbox(self, boxname):
+        while self.dataReady(boxname):
+            yield self.recv(boxname)
+    def dataReady(self, boxname):
+        return self.DataReadyMethod(self.__dict__[boxname])
+    def anyReady(self):
+        return self.DataReadyMethod(self.inbox) or self.DataReadyMethod(self.control)
+    def send(self, msg, boxname):
+        self.SendMethod(msg, self.__dict__[boxname])
+    def __repr__(self):
+        return '<transaction for thread %s: %s, %s, %s, %s>' \
+            % (self.thread or '(unknown)', self.inbox, self.control, self.outbox, self.control)
+        
+    def _get_done(self):
+        return self.Translator._isStopped()
+    
+    done = property(fget=_get_done)
+        
+def BoxBundle(adap, translator=None, thread=None):
+    """This factory function will create a new box bundle with all the necessary
+    info about a component.  This is done this way to prevent circular references.
+    (the alternative would be to pass the adaptive comms component directly to the
+    box bundle)."""
+    if not isinstance(thread, str):
+        thread = str(thread)
+    bundle = _BoxBundle(
+        SendMethod = adap.send,
+        RecvMethod = adap.recv,
+        DataReadyMethod = adap.dataReady,
+        InboxAddMethod = adap.addInbox,
+        InboxRmMethod = adap.deleteInbox,
+        OutboxAddMethod = adap.addOutbox,
+        OutboxRmMethod = adap.deleteOutbox,
+        LinkMethod = adap.link,
+        UnlinkMethod = adap.unlink,
+        thread = thread,
+        Translator=translator,
+    )
+    return bundle
+
+class NullBundle(object):
+    pass
+
+class TransactionManager(threadedadaptivecommscomponent):
+    Inboxes = {'inbox' : 'Receive output from the translators',
+               'control' : 'Receive shutdown messages',
+               'jid' : 'Receive the JID from headstock'}
+    Outboxes = {'outbox' : 'NOT USED',
+                'signal' : 'Send shutdown messages'}
+    
+    """
+    This component will manage all the various transactions going on at any given
+    point in time.  A transaction represents an HTTP request and response transaction.
+    Note that of course the actual HTTP request and response don't actually happen
+    here in this program.  They happen at the gateway.
+    
+    Upon receiving a message that is a part of a thread the TransactionManager has
+    not encountered yet, a new BoxBundle is created to represent the transaction.
+    In addition, a translator is created to translate data passed back and forth
+    between the TransactionManager and the resource handler (that will be created
+    by the translator).
+    """
+    #As of right now, there's not much reason to override the next two attributes.
+    #But there may be in the future!
+    RequestTranslator = RequestDeserializer
+    ResponseTranslator = ResponseSerializer
+    HandlerFactory = SimpleHandler
+    
+    ThisJID=None
+    def __init__(self, **argd):
+        super(TransactionManager, self).__init__(**argd)
+        self.transactions = {}
+        self.null = NullBundle()
+    
+    def main(self):
+        self.jid_subscriber = SubscribeTo('JID')
+        self.link((self.jid_subscriber, 'outbox'), (self, 'jid'))
+        self.jid_subscriber.activate()
+  
+        myjid = cat.getcat().retrieveValue("MYJID")
+        self.ThisJID = myjid
+        
+        self.signal = None
+        while not self.signal:
+            for msg in self.Inbox('jid'):
+                self.ThisJID = msg
+                
+            for msg in self.Inbox('control'):
+                self.signal = msg
+                
+            for msg in self.Inbox('inbox'):
+                self.handleIncoming(msg)
+
+            #This is a set of all the transactions that will be removed once this
+            #loop is finished.  We do it this way to prevent the size of self.transactions
+            #from changing in the middle of the loop (which will cause an exception).
+            marked = set()
+            for thread, transaction in self.transactions.iteritems():
+                if transaction.anyReady():
+                    if transaction.done:
+                        marked.add(transaction)
+                    
+                    self.sync()
+                    for msg in transaction.Inbox('inbox'):
+                        self.send(msg, 'outbox')
+                        
+            self._cleanup(marked)
+
+            if not self.anyReady():
+                self.pause()
+        for k,v in self.transactions.iteritems():
+            print repr(v)
+    
+    def handleIncoming(self, msg):
+        if not self.transactions.get(str(msg.thread)):
+            self._createTranslator(msg)
+        elif isinstance(self.transactions[str(msg.thread)], NullBundle):
+            pass
+        else:
+            self._sendToTranslator(msg)
+        
+    def _createTranslator(self, msg):
+        translator = TranslatorChassis(msg, self.HandlerFactory)
+        transaction = BoxBundle(self, translator, msg.thread)
+        transaction.createBoxes()
+        
+        #link the newly created transaction object to the translator
+        self.link((self, transaction.outbox), (translator, 'inbox'))
+        self.link((self, transaction.signal), (translator, 'control'))
+        self.link((translator, 'outbox'), (self, transaction.inbox))
+        self.link((translator, 'signal'), (self, transaction.control))
+        
+        self.transactions[str(msg.thread)] = transaction
+        
+        translator.activate()
+        self.addChildren(translator)
+        
+    def _sendToTranslator(self, msg):
+        thread = str(msg.thread)
+        transaction = self.transactions[thread]
+        transaction.send(msg, 'outbox')
+        
+    def _cleanup(self, marked):
+        for transaction in marked:
+            assert(transaction.Translator._isStopped())
+            self.removeChild(transaction.Translator)
+            transaction.destroyBoxes()
+            del self.transactions[transaction.thread]
+        
+if __name__ == '__main__':
+    from Axon.Component import component
+    from Axon.Introspector import Introspector
+    from Axon.Ipc import producerFinished
+    from Kamaelia.Chassis.Pipeline import Pipeline
+    from Kamaelia.Util.Console import ConsoleEchoer
+    
+    import simplejson
+    
+    class Producer(component):
+        def main(self):
+            for i in xrange(5):
+                msg = Message(u'foo@foo.com', u'foo2@foo.com',
+                              type=u'chat')
+                body = Body(simplejson.dumps({'batch' :  str(i), 'signal' : 'producerFinished'}))
+                msg.bodies.append(body)
+                msg.thread = Thread(unicode(i))
+                self.send(msg, 'outbox')
+                yield 1
+                
+                msg = Message(u'foo@foo.com', u'foo2@foo.com',
+                              type=u'chat')
+                body = Body(simplejson.dumps({'signal' : 'producerFinished', 'batch': str(i)}))
+                msg.bodies.append(body)
+                msg.thread = Thread(unicode(i))
+                self.send(msg, 'outbox')
+                
+                yield 1
+                
+            self.send(producerFinished(self), 'signal')
+            
+    Pipeline(
+        Producer(),
+        TransactionManager(),
+    ).run()

Property changes on: Apps/GSOC_JMB_Publish/Peer/scripts/transactions.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/scripts/__init__.py
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/scripts/__init__.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/scripts/__init__.py	(revision 6484)
@@ -0,0 +1,3 @@
+#
+# JMB_PUBLISH_PEER
+#

Property changes on: Apps/GSOC_JMB_Publish/Peer/scripts/__init__.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/scripts/main.py
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/scripts/main.py	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/scripts/main.py	(revision 6484)
@@ -0,0 +1,708 @@
+# -*- coding: utf-8 -*-
+#
+# JMB_PUBLISH_PEER
+#
+"""
+This is an adapted version of Sylvain Hellegouarch's simplechat example.  It is used
+as the basis for Kamaelia Publish's XMPP code.  The original documentation is reproduced
+below.
+
+The majority of the code needed to understand how this module works is in the Client
+component (including a big graphline)
+
+Original documentation
+------------------------
+
+This module is a simple XMPP chat client demonstrating the use of headstock.
+Many Kamaelia components are created to manage different XMPP kind of stanzas.
+
+* RosterHandler:
+  * querying the server for the roster list
+  * if supported by server, asking for the last activity of each contact
+
+* DummyMessageHandler:
+  * sending a message typed into the console window
+  * printing to the console any received messages
+
+* DiscoHandler: 
+  * querying for the supported features by the server
+  * dispatching the result of the previous query to components interested in that event
+
+* ActivityHandler:
+  * dispatching to the RosterHandler the fact the server supports the feature
+
+* RegisterHandler:
+  * registring a new user using in-band registration if supported
+
+The actual XMPP client is the Client component that sets up the different
+dispatchers and handlers involved by liking each inbox to the expected outbox and
+vcie versa.
+
+FIXME
+---------
+This code desperately needs to be refactored and needs to have uneccessary functionality
+removed.  The code is good for an example, but not a production system.
+"""
+import re, os, sys, zipfile
+
+import Axon
+from Axon.CoordinatingAssistantTracker import coordinatingassistanttracker as cat
+from Axon.Component import component
+from Axon.AdaptiveCommsComponent import AdaptiveCommsComponent
+from Kamaelia.Chassis.Graphline import Graphline
+from Kamaelia.Chassis.Pipeline import Pipeline
+from Kamaelia.Util.Backplane import Backplane
+from Kamaelia.Util.Backplane import PublishTo, SubscribeTo
+from Kamaelia.Internet.TCPClient import TCPClient
+from Kamaelia.Util.Console import ConsoleReader
+from Axon.Ipc import shutdownMicroprocess, producerFinished
+
+from Kamaelia.Apps.JMB.WSGI import SimpleWSGIFactory, WSGIFactory
+from Kamaelia.Apps.JMB.WSGI.Apps.Simple import simple_app
+from Kamaelia.Apps.JMB.Common.ConfigFile import DictFormatter, ParseConfigFile
+from Kamaelia.Apps.JMB.Common.UrlConfig import ParseUrlFile
+from Kamaelia.Apps.JMB.Common.ServerSetup import processPyPath, normalizeUrlList,\
+ normalizeWsgiVars, initializeLogger
+
+from transactions import TransactionManager
+from Kamaelia.Apps.JMB.Common.Structs import StaticConfigObject, XMPPConfigObject,\
+ ConfigObject
+from Kamaelia.Apps.JMB.Common.autoinstall import autoinstall
+from Kamaelia.Apps.JMB.Common.Console import prompt_corrupt
+    
+from headstock.protocol.core.stream import ClientStream, StreamError, SaslError
+from headstock.protocol.core.presence import PresenceDispatcher
+from headstock.protocol.core.roster import RosterDispatcher, RosterNull
+from headstock.protocol.core.message import MessageDispatcher, MessageEchoer
+from headstock.protocol.extension.register import RegisterDispatcher
+from headstock.protocol.extension.activity import ActivityDispatcher
+from headstock.protocol.extension.discovery import DiscoveryDispatcher
+from headstock.protocol.extension.discovery import FeaturesDiscovery
+from headstock.api.jid import JID
+from headstock.api.im import Message, Body, Event
+from headstock.api.contact import Presence, Roster, Item
+from headstock.api import Entity
+from headstock.api.activity import Activity
+from headstock.api.registration import Registration
+from headstock.lib.parser import XMLIncrParser
+from headstock.lib.logger import Logger
+from headstock.lib.utils import generate_unique
+
+from bridge import Element as E
+from bridge.common import XMPP_CLIENT_NS, XMPP_ROSTER_NS, \
+    XMPP_LAST_NS, XMPP_DISCO_INFO_NS, XMPP_IBR_NS
+
+__all__ = ['Client']
+
+class RosterHandler(component):    
+    Inboxes = {"inbox"        : "headstock.api.contact.Roster instance",
+               "control"      : "stops the component",
+               "pushed"       : "roster stanzas pushed by the server",
+               "jid"          : "headstock.api.jid.JID instance received from the server",
+               "ask-activity" : "request activity status to the server for each roster contact"}
+    
+    Outboxes = {"outbox"      : "UNUSED",
+                "signal"      : "Shutdown signal",
+                "message"     : "Message to send",
+                "result"      : "", 
+                "activity"    : "headstock.api.activity.Activity instance to send to the server"}
+
+    def __init__(self, from_jid):
+        super(RosterHandler, self).__init__() 
+        self.from_jid = from_jid
+        self.roster = None
+        print "NEW MYJID", self.from_jid
+        try:
+            cat.getcat().trackValue("MYJID", from_jid)
+        except Axon.AxonExceptions.NamespaceClash:
+            cat.getcat().updateValue("MYJID", self.from_jid)
+            print "MYJID", cat.getcat().retrieveValue("MYJID")
+
+    def initComponents(self):
+        # We subscribe to the JID backplane component
+        # that will inform us when the server has
+        # returned the per-session jid
+        sub = SubscribeTo("JID")
+        self.link((sub, 'outbox'), (self, 'jid'))
+        self.addChildren(sub)
+        sub.activate()
+
+        return 1
+
+    def main(self):
+        yield self.initComponents()
+
+        while 1:
+            while self.dataReady("control"):
+                mes = self.recv("control")
+                
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            while self.dataReady("jid"):
+                self.from_jid = self.recv('jid')
+                print "NEW MYJID", self.from_jid
+                try:
+                    cat.getcat().trackValue("MYJID", self.from_jid)
+                except Axon.AxonExceptions.NamespaceClash:
+                    cat.getcat().updateValue("MYJID", self.from_jid)
+                    print "MYJID", cat.getcat().retrieveValue("MYJID")
+            
+            while self.dataReady("pushed"):
+                roster = self.recv('pushed')
+                for nodeid in roster.items:
+                    self.send(Roster(from_jid=self.from_jid, to_jid=nodeid,
+                                     type=u'result', stanza_id=generate_unique()), 'result')
+                
+            while self.dataReady("inbox"):
+                roster = self.recv("inbox")
+                self.roster = roster
+                print "Your contacts:"
+                for nodeid in roster.items:
+                    contact = roster.items[nodeid]
+                    print "  ", contact.jid
+                    
+            while self.dataReady('ask-activity'):
+                self.recv('ask-activity')
+                if self.roster:
+                    for nodeid in self.roster.items:
+                        contact = roster.items[nodeid]
+                        a = Activity(unicode(self.from_jid), unicode(contact.jid))
+                        self.send(a, 'activity')
+
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+class DiscoHandler(component):
+    Inboxes = {"inbox"          : "UNUSED",
+               "control"        : "stops the component", 
+               "initiate"       : "event informing the component the client session is active",
+               "jid"            : "headstock.api.jid.JID instance received from the server",
+               "features.result": "headstock.api.discovery.FeaturesDiscovery instance from the server",}
+    
+    Outboxes = {"outbox"           : "UNUSED",
+                "signal"           : "Shutdown signal",
+                "features-disco"   : "headstock.api.discovery.FeaturesDiscovery query to the server",  
+                "features-announce": "headstock.api.discovery.FeaturesDiscovery informs"\
+                    "the other components about the features instance received from the server"}
+
+    def __init__(self, from_jid, to_jid):
+        super(DiscoHandler, self).__init__() 
+        self.from_jid = from_jid
+        self.to_jid = to_jid
+        print "NEW MYJID", self.from_jid
+        try:
+            cat.getcat().trackValue("MYJID", self.from_jid)
+        except Axon.AxonExceptions.NamespaceClash:
+            cat.getcat().updateValue("MYJID", self.from_jid)
+            print "MYJID", cat.getcat().retrieveValue("MYJID")
+
+    def initComponents(self):
+        sub = SubscribeTo("JID")
+        self.link((sub, 'outbox'), (self, 'jid'))
+        self.addChildren(sub)
+        sub.activate()
+
+        pub = PublishTo("DISCO_FEAT")
+        self.link((self, 'features-announce'), (pub, 'inbox'))
+        self.addChildren(pub)
+        pub.activate()
+
+        sub = SubscribeTo("BOUND")
+        self.link((sub, 'outbox'), (self, 'initiate'))
+        self.addChildren(sub)
+        sub.activate()
+
+        return 1
+
+    def main(self):
+        yield self.initComponents()
+
+        while 1:
+            while self.dataReady("control"):
+                mes = self.recv("control")
+                
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            while self.dataReady("jid"):
+                self.from_jid = self.recv('jid')
+                print "NEW MYJID", self.from_jid
+                try:
+                    cat.getcat().trackValue("MYJID", self.from_jid)
+                except Axon.AxonExceptions.NamespaceClash:
+                    cat.getcat().updateValue("MYJID", self.from_jid)
+                    print "MYJID", cat.getcat().retrieveValue("MYJID")
+            
+            # When this box has some data, it means
+            # that the client is bound to the server
+            # Let's ask for its supported features then.
+            while self.dataReady("initiate"):
+                self.recv("initiate")
+                d = FeaturesDiscovery(unicode(self.from_jid), self.to_jid)
+                self.send(d, "features-disco")
+
+            # The response to our discovery query
+            # is a a headstock.api.discovery.FeaturesDiscovery instance.
+            # What we immediatly do is to notify all handlers
+            # interested in that event about it.
+            while self.dataReady('features.result'):
+                disco = self.recv('features.result')
+                print "Supported features:"
+                for feature in disco.features:
+                    print "  ", feature.var
+                self.send(disco, 'features-announce')
+
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+class ActivityHandler(component):
+    Inboxes = {"inbox"   : "headstock.api.discovery.FeaturesDiscovery instance",
+               "control" : "stops the component",
+               }
+    
+    Outboxes = {"outbox"            : "UNUSED",
+                "signal"            : "Shutdown signal",
+                "activity-supported": "when used this tells the RosterHandler it needs"\
+                    "to request the server for each contact's activity."\
+                    "This is only used when the server supports the feature",
+                }
+
+    def __init__(self):
+        super(ActivityHandler, self).__init__() 
+
+    def initComponents(self):
+        sub = SubscribeTo("DISCO_FEAT")
+        self.link((sub, 'outbox'), (self, 'inbox'))
+        self.addChildren(sub)
+        sub.activate()
+        
+        return 1
+
+    def main(self):
+        yield self.initComponents()
+
+        while 1:
+            while self.dataReady("control"):
+                mes = self.recv("control")
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            while self.dataReady("inbox"):
+                disco = self.recv("inbox")
+                support = disco.has_feature(XMPP_LAST_NS)
+                print "Activity support: ", support
+                if support:
+                    self.send('', "activity-supported")
+
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+class PresenceHandler(component):
+    Inboxes = {"inbox"       : "headstock.api.contact.Presence instance",
+               "control"     : "Shutdown the client stream",
+               "subscribe"   : "",
+               "unsubscribe" : "",
+               "available"   : "Receive notification when a user comes online.",
+               "unavailable" : "Receive notification when a user becomes unavailable."}
+    
+    Outboxes = {"outbox" : "headstock.api.contact.Presence instance to return to the server",
+                "signal" : "Shutdown signal",
+                "roster" : "",
+                "log"    : "log",}
+    
+    def __init__(self):
+        super(PresenceHandler, self).__init__()
+
+    def main(self):
+        while 1:
+            while self.dataReady("control"):
+                mes = self.recv("control")
+                
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            while self.dataReady("subscribe"):
+                p = self.recv("subscribe")
+                p.swap_jids()
+
+                # Automatically accept any subscription requests
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'subscribed')
+                self.send(p, "outbox")
+                
+                # Automatically subscribe in return as well
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'subscribe')
+                self.send(p, "outbox")
+                
+            while self.dataReady("unsubscribe"):
+                p = self.recv("unsubscribe")
+                p.swap_jids()
+                
+                # We stop our subscription to the other user
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'unsubscribed')
+                self.send(p, "outbox")
+                
+                # We stop the other user's subscription
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'unsubscribe')
+                self.send(p, "outbox")
+
+                # We remove this user from our roster list
+                r = Roster(from_jid=p.from_jid, type=u'set')
+                i = Item(p.to_jid)
+                i.subscription = u'remove'
+                r.items[unicode(p.to_jid)] = i
+                self.send(r, 'roster')
+
+                # We tell the other user we're not available anymore
+                p = Presence(from_jid=p.from_jid, to_jid=unicode(p.to_jid),
+                             type=u'unavailable')
+                self.send(p, "outbox")
+                
+            for msg in self.Inbox('available'):
+                pass
+            
+            for msg in self.Inbox('unavailable'):
+                pass
+                
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+    
+
+class RegistrationHandler(component):
+    Inboxes = {"inbox"   : "headstock.api.registration.Registration",
+               "error"   : "headstock.api.registration.Registration",
+               "control" : "Shutdown the client stream",}
+    
+    Outboxes = {"outbox" : "headstock.api.registration.Registration",
+                "signal" : "Shutdown signal",
+                "log"    : "log",}
+    
+    def __init__(self, username, password):
+        super(RegistrationHandler, self).__init__()
+        self.username = username
+        self.password = password
+        self.registration_id = None
+
+    def main(self):
+        while 1:
+            while self.dataReady("control"):
+                mes = self.recv("control")
+                
+                if isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(producerFinished(), "signal")
+                    break
+
+            while self.dataReady("inbox"):
+                r = self.recv('inbox')
+                if r.registered:
+                    print "'%s' is already a registered username." % self.username
+                elif self.registration_id == r.stanza_id:
+                    print "'%s' is now a registered user."\
+                        "Please restart the client without the register flag." % self.username
+                else:
+                    if 'username' in r.infos and 'password' in r.infos:
+                        self.registration_id = generate_unique()
+                        r = Registration(type=u'set', stanza_id=self.registration_id)
+                        r.infos[u'username'] = self.username
+                        r.infos[u'password'] = self.password
+                        self.send(r, 'outbox')
+                
+            while self.dataReady("error"):
+                r = self.recv('error')
+                print r.error
+
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+class Client(component):
+    Inboxes = {"inbox"      : "",
+               "jid"        : "",
+               "streamfeat" : "",
+               "control"    : "Shutdown the client stream",}
+    
+    Outboxes = {"outbox"  : "",
+                "forward" : "",
+                "log"     : "",
+                "doauth"  : "",
+                "signal"  : "Shutdown signal",
+                "doregistration" : ""}
+
+    def __init__(self, Config, url_list):
+        super(Client, self).__init__() 
+        self.jid = JID(
+            Config.xmpp.username,
+            Config.xmpp.domain,
+            Config.xmpp.resource)
+        self.cfg = Config
+        self.username = Config.xmpp.username
+        self.password = Config.xmpp.password
+        self.server = Config.xmpp.server
+        self.client = None
+        self.graph = None
+        self.domain = Config.xmpp.domain
+        self.usetls = Config.xmpp.usetls
+        self.register = False
+        
+        self.url_list = url_list
+        
+        self.use_stdout = Config.options.xmpp_verbose
+
+    def passwordLookup(self, jid):
+        return self.password
+
+    def shutdown(self):
+        self.send(Presence.to_element(Presence(self.jid, type=u'unavailable')), 'forward')
+        self.send('OUTGOING : </stream:stream>', 'log')
+        self.send('</stream:stream>', 'outbox') 
+
+    def abort(self):
+        self.send('OUTGOING : </stream:stream>', 'log')
+        self.send('</stream:stream>', 'outbox')
+
+    def setup(self):
+        # Backplanes are like a global entry points that
+        # can be accessible both for publishing and
+        # recieving data. 
+        # In other words, a component interested
+        # in advertising to many other components that
+        # something happened may link one of its outbox
+        # to a PublishTo component's inbox.
+        # A component wishing to receive that piece of
+        # information will link one of its inbox
+        # to the SubscribeTo component's outbox.
+        # This helps greatly to make components more
+        # loosely connected but also allows for some data
+        # to be dispatched at once to many (such as when
+        # the server returns the per-session JID that
+        # is of interest for most other components).
+        Backplane("CONSOLE").activate()
+        Backplane("JID").activate()
+        # Used to inform components that the session is now active
+        Backplane("BOUND").activate()
+        # Used to inform components of the supported features
+        Backplane("DISCO_FEAT").activate()
+        Backplane("MESSAGING").activate()
+        
+
+        sub = SubscribeTo("JID")
+        self.link((sub, 'outbox'), (self, 'jid'))
+        self.addChildren(sub)
+        sub.activate()
+        
+        Backplane('LOG_' + self.cfg.server.log).activate()
+        if self.use_stdout:
+            log = Logger(stdout=True, name='XmppLogger')
+            Pipeline(SubscribeTo('LOG_' + self.cfg.server.log), log).activate()
+        
+        # We pipe everything typed into the console
+        # directly to the console backplane so that
+        # every components subscribed to the console
+        # backplane inbox will get the typed data and
+        # will decide it it's of concern or not.
+        Pipeline(ConsoleReader(), PublishTo('CONSOLE')).activate()
+
+        # Add two outboxes ro the ClientSteam to support specific extensions.
+        ClientStream.Outboxes["%s.query" % XMPP_IBR_NS] = "Registration"
+        ClientStream.Outboxes["%s.query" % XMPP_LAST_NS] = "Activity"
+        ClientStream.Outboxes["%s.query" % XMPP_DISCO_INFO_NS] = "Discovery"
+
+        self.client = ClientStream(self.jid, self.passwordLookup, use_tls=self.usetls)
+        
+        trans = TransactionManager(
+            HandlerFactory = WSGIFactory(self.cfg.wsgi, self.url_list, translator=None)
+        )
+
+        self.graph = Graphline(client = self,
+                               console = SubscribeTo('CONSOLE'),
+                               logger = PublishTo('LOG_' + self.cfg.server.log),
+                               tcp = TCPClient(self.cfg.xmpp.server, self.cfg.xmpp.port),
+                               xmlparser = XMLIncrParser(),
+                               xmpp = self.client,
+                               streamerr = StreamError(),
+                               saslerr = SaslError(),
+                               discohandler = DiscoHandler(self.jid, self.domain),
+                               activityhandler = ActivityHandler(),
+                               rosterhandler = RosterHandler(self.jid),
+                               registerhandler = RegistrationHandler(self.username, self.password),
+                               msghandler = trans,
+                               presencehandler = PresenceHandler(),
+                               presencedisp = PresenceDispatcher(),
+                               rosterdisp = RosterDispatcher(),
+                               msgdisp = MessageDispatcher(),
+                               discodisp = DiscoveryDispatcher(),
+                               activitydisp = ActivityDispatcher(),
+                               registerdisp = RegisterDispatcher(),
+                               pjid = PublishTo("JID"),
+                               pbound = PublishTo("BOUND"),
+                               smsg = SubscribeTo("MESSAGING"),
+
+                               linkages = {('xmpp', 'terminated'): ('client', 'inbox'),
+                                           ('console', 'outbox'): ('client', 'control'),
+                                           ('client', 'forward'): ('xmpp', 'forward'),
+                                           ('client', 'outbox'): ('tcp', 'inbox'),
+                                           ('client', 'signal'): ('tcp', 'control'),
+                                           ("tcp", "outbox") : ("xmlparser", "inbox"),
+                                           ("xmpp", "starttls") : ("tcp", "makessl"),
+                                           ("tcp", "sslready") : ("xmpp", "tlssuccess"), 
+                                           ("xmlparser", "outbox") : ("xmpp" , "inbox"),
+                                           ("xmpp", "outbox") : ("tcp" , "inbox"),
+                                           ("xmpp", "reset"): ("xmlparser", "reset"),
+                                           ("client", "log"): ("logger", "inbox"),
+                                           ("xmpp", "log"): ("logger", "inbox"),
+                                           ("xmpp", "jid"): ("pjid", "inbox"),
+                                           ("xmpp", "bound"): ("pbound", "inbox"),
+                                           ("xmpp", "features"): ("client", "streamfeat"),
+                                           ("client", "doauth"): ("xmpp", "auth"),
+                                           
+                                           # Registration
+                                           ("xmpp", "%s.query" % XMPP_IBR_NS): ("registerdisp", "inbox"),
+                                           ("registerdisp", "log"): ('logger', "inbox"),
+                                           ("registerdisp", "xmpp.error"): ("registerhandler", "error"),
+                                           ("registerdisp", "xmpp.result"): ("registerhandler", "inbox"),
+                                           ("registerhandler", "outbox"): ("registerdisp", "forward"),
+                                           ("client", "doregistration"): ("registerdisp", "forward"),
+                                           ("registerdisp", "outbox"): ("xmpp", "forward"),
+                                           
+                                           # Presence 
+                                           ("xmpp", "%s.presence" % XMPP_CLIENT_NS): ("presencedisp", "inbox"),
+                                           ("presencedisp", "log"): ('logger', "inbox"),
+                                           ("presencedisp", "xmpp.subscribe"): ("presencehandler", "subscribe"),
+                                           ("presencedisp", "xmpp.unsubscribe"): ("presencehandler", "unsubscribe"),
+                                           ("presencedisp", "xmpp.available") : ("presencehandler", "available"),
+                                           ("presencedisp", "xmpp.unavailable") : ("presencehandler", "unavailable"),
+                                           ("presencehandler", "outbox"): ("presencedisp", "forward"),
+                                           ("presencehandler", "roster"): ("rosterdisp", "forward"),
+                                           ("presencedisp", "outbox"): ("xmpp", "forward"),
+
+                                           # Roster
+                                           ("xmpp", "%s.query" % XMPP_ROSTER_NS): ("rosterdisp", "inbox"),
+                                           ("rosterdisp", "log"): ('logger', "inbox"),
+                                           ('rosterdisp', 'xmpp.set'): ('rosterhandler', 'pushed'),
+                                           ('rosterdisp', 'xmpp.result'): ('rosterhandler', 'inbox'),
+                                           ('rosterhandler', 'result'): ('rosterdisp', 'forward'),
+                                           ("rosterdisp", "outbox"): ("xmpp", "forward"),
+
+                                           # Discovery
+                                           ("xmpp", "%s.query" % XMPP_DISCO_INFO_NS): ("discodisp", "features.inbox"),
+                                           ("discodisp", "log"): ('logger', "inbox"),
+                                           ("discohandler", "features-disco"): ('discodisp', "features.forward"),
+                                           ("discodisp", "out.features.result"): ('discohandler', "features.result"),
+                                           ("discodisp", "outbox"): ("xmpp", "forward"),
+
+                                           # Message
+                                           ("xmpp", "%s.message" % XMPP_CLIENT_NS): ("msgdisp", "inbox"),
+                                           ("msgdisp", "log"): ('logger', "inbox"),
+                                           ("msgdisp", "xmpp.chat"): ('msghandler', 'inbox'),
+                                           ("msghandler", "outbox"): ('msgdisp', 'forward'),
+                                           ("smsg", "outbox") : ("msgdisp", "forward"),
+                                           ("msgdisp", "outbox"): ("xmpp", "forward"),
+
+                                           # Activity
+                                           ("xmpp", "%s.query" % XMPP_LAST_NS): ("activitydisp", "inbox"),
+                                           ("activitydisp", "log"): ('logger', "inbox"),
+                                           ("activitydisp", "outbox"): ("xmpp", "forward"),
+                                           ("activityhandler", 'activity-supported'): ('rosterhandler', 'ask-activity'),
+                                           ("rosterhandler", 'activity'): ('activitydisp', 'forward'),
+                                           }
+                               )
+        self.addChildren(self.graph)
+        self.graph.activate()
+
+        return 1
+
+    def main(self):
+        yield self.setup()
+
+        while 1:
+            while self.dataReady("control"):
+                mes = self.recv("control")
+
+                if isinstance(mes, str):
+                    if mes.strip() == 'quit':
+                        self.shutdown()
+                elif isinstance(mes, shutdownMicroprocess) or isinstance(mes, producerFinished):
+                    self.send(mes, "signal")
+                    break
+
+            while self.dataReady("inbox"):
+                msg = self.recv('inbox')
+                if msg == "quit":
+                    self.send(shutdownMicroprocess(), "signal")
+                    yield 1
+                    break
+
+            while self.dataReady("streamfeat"):
+                feat = self.recv('streamfeat')
+                if feat.register and self.register:
+                    self.send(Registration(), 'doregistration')
+                elif self.register and not feat.register:
+                    print "The server does not support in-band registration. Closing connection."
+                    self.abort()
+                else:
+                    self.send(feat, 'doauth')
+                
+            while self.dataReady("jid"):
+                self.jid = self.recv('jid')
+                
+            if not self.anyReady():
+                self.pause()
+  
+            yield 1
+
+        yield 1
+        self.stop()
+        print "You can hit Ctrl-C to shutdown all processes now." 
+
+def main():   
+    home_path = os.environ['HOME']
+    zip = zipfile.ZipFile(sys.argv[0], 'r')
+    
+    #prompt the user if this executable is corrupt
+    corrupt = zip.testzip()
+    if corrupt:
+        prompt_corrupt(corrupt)
+    
+    if not os.path.exists(home_path + '/kp.ini'):
+        autoinstall(zip, home_path, 'Kamaelia Publish')
+    
+    ConfigDict = ParseConfigFile('~/kp.ini', DictFormatter())
+    options = parseCmdOpts()
+    
+    Config = ConfigObject(ConfigDict, options)
+    processPyPath(ConfigDict['SERVER'])
+    initializeLogger()
+    
+    url_list = ParseUrlFile(Config.wsgi['url_list'])
+    normalizeUrlList(url_list)
+
+    client = Client(Config, url_list)
+    client.run()
+    
+def parseCmdOpts():
+    import optparse
+    parser = optparse.OptionParser()
+    parser.add_option('-v', '--verbose', dest='xmpp_verbose', action='store_true',
+                      help='Use this option to view each incoming and outgoing XMPP message')
+    (options, args) = parser.parse_args()
+    return options
+
+if __name__ == '__main__':
+    main()

Property changes on: Apps/GSOC_JMB_Publish/Peer/scripts/main.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/make-unix.sh
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/make-unix.sh	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/make-unix.sh	(revision 6484)
@@ -0,0 +1,58 @@
+#!/bin/sh
+#
+# JMB_PUBLISH_PEER
+#
+#make-unix.sh
+#usage:  ./make-unix.sh [clean] [include-files]
+#This script will first run scripts/publish.prepare.sh to assemble all of the relevant
+#files into the assembly directory and strip the .svns from them.  It will then remove
+#every pyc from the assembly directory.  Once this is finished, it will zip all the
+#source files, byte compiled modules, and optimized modules as well as any other
+#files that were named in include-files at the command line.  After this, the script
+#will concatenate this zip file with zipheader.unix creating the executable (which
+#will be moved to the zip directory).
+#
+#If clean was specified at the command line, the script will remove the assembly directory
+#once it is finished.  It is recommended that you remove the assembly directory prior to
+#running this script again.
+
+./prepare.sh #assemble everything we need in the assembly directory
+#python byte-compile.py urls.py main.py ServerConfig.py
+
+if [ "$1" = "clean" ]
+then
+    CLEANUP=$1
+    shift 1
+else
+    CLEANUP="empty"
+fi
+
+
+
+(
+cd assembly
+echo ">Removing any previously compiled modules"
+rm -rfv assembly/*.pyc
+echo ">Creating executable"
+find . -name "*.py"|zip -@ kpublish.zip
+find . -name "*.cfg"|zip -@g9 kpublish.zip
+find . -name "*.ini"|zip -@g9 kpublish.zip
+find . -name "*.tar" | zip -@g9 kpublish.zip
+#find . -name "*.pyc"|zip -@g kpublish.zip
+#find . -name "*.pyo"|zip -@g kpublish.zip
+cat zipheader.unix kpublish.zip > kpublish
+
+if [ ! -d ../dist ]
+then
+    mkdir ../dist
+fi
+
+mv kpublish ../dist
+chmod a+x ../dist/kpublish
+)
+
+if [ "$CLEANUP" = "clean" ]
+then
+    echo ">Cleaning up!"
+    rm -rf assembly
+fi

Property changes on: Apps/GSOC_JMB_Publish/Peer/make-unix.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/prepare.sh
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/prepare.sh	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/prepare.sh	(revision 6484)
@@ -0,0 +1,39 @@
+#!/bin/sh
+#
+# JMB_PUBLISH_PEER
+#
+#This shell script will check to see if an assemly directory already exits and create
+#one if not.  It will then copy all of the relevant files over to the assembly directory.
+
+echo "Creating staging area for building"
+if [ ! -d assembly ]
+then
+    mkdir assembly
+else
+    rm -rf assembly
+    mkdir assembly
+fi
+echo "----------------------------------------------------"
+echo "Assembling Axon/Kamaelia files"
+echo "----------------------------------------------------"
+
+echo "Copying Axon from branch to assembly directory"
+cp -R ../../../Axon/Axon/ assembly/Axon
+echo "Copying Kamaelia from branch to assembly directory"
+cp -R ../../../Kamaelia/Kamaelia/ assembly/Kamaelia
+echo "Copying zipheader.unix to assembly directory"
+cp zipheader.unix assembly/zipheader.unix
+echo "Copying scripts into the assembly directory"
+cp -R scripts/* assembly
+echo "Copying plugins to the assembly directory"
+cp -R plugins assembly/plugins
+echo "Tarring configuration data."
+(
+    cd data
+    mkdir ../assembly/data
+    tar -cvvf ../assembly/data/kpuser.tar kpuser kp.ini --exclude=.svn
+)
+
+echo "----------------------------------------------------"
+echo "Done preparing!"
+echo "----------------------------------------------------"

Property changes on: Apps/GSOC_JMB_Publish/Peer/prepare.sh
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/data/kp.ini
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/data/kp.ini	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/data/kp.ini	(revision 6484)
@@ -0,0 +1,28 @@
+#
+# JMB_PUBLISH_PEER
+#
+[SERVER]
+PORT: 8080
+PYPATH_APPEND: ~/kpuser:~/kpuser/Apps
+LOG: ~/kpuser/kp.log
+
+[STATIC]
+url: /static
+homedirectory: ~/kpuser/www
+index: index.html
+
+[WSGI]
+SERVER_SOFTWARE: Kamaelia Publish v 0.0.1
+SERVER_ADMIN: Jason Baker
+WSGI_VER: 1.0
+URL_LIST: ~/kpuser/urls.ini
+LOG: ~/kpuser/kp.log
+
+#uncomment the following sections to set up your XMPP account for Kamaelia Publish
+[XMPP]
+username:  kamaelia.testing
+domain: googlemail.com
+address: 
+password: 
+# uncomment the following line if your server uses tls
+usetls: True

Property changes on: Apps/GSOC_JMB_Publish/Peer/data/kp.ini
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/data/kpuser/urls.ini
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/data/kpuser/urls.ini	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/data/kpuser/urls.ini	(revision 6484)
@@ -0,0 +1,25 @@
+#
+# JMB_PUBLISH_PEER
+#
+#This is the default url list.  The items here are generally in the form:
+#[section_name]
+#regex:  application regex pattern (will be split by '/')
+#import_path:  path to import object from
+#app_object:  Attribute name of the WSGI application object in the given module
+#
+#Please note that this file MUST contain a section error_404 and that section
+#MUST NOT contain a regex.  It will be assigned a regex of '.*' automatically
+#by the UrlList parser.
+#
+#Also, please note that order IS important here.  You must put your applications
+#in the order you want them evaluated (error_404 will always be handled last no
+#matter what).
+
+[simple_app]
+regex: simple
+import_path: Kamaelia.Support.WsgiApps.Simple
+app_object: simple_app
+
+[error_404]
+import_path: Kamaelia.Support.WsgiApps.ErrorHandler
+app_object: application

Property changes on: Apps/GSOC_JMB_Publish/Peer/data/kpuser/urls.ini
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/data/kpuser/kp.log
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/data/kpuser/kp.log	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/data/kpuser/kp.log	(revision 6484)
@@ -0,0 +1,5 @@
+#
+# JMB_PUBLISH_PEER
+#
+==Kamaelia Publish Log==
+

Property changes on: Apps/GSOC_JMB_Publish/Peer/data/kpuser/kp.log
___________________________________________________________________
Added: svn:executable
   + *

Index: Apps/GSOC_JMB_Publish/Peer/zipheader.unix
===================================================================
--- Apps/GSOC_JMB_Publish/Peer/zipheader.unix	(revision 0)
+++ Apps/GSOC_JMB_Publish/Peer/zipheader.unix	(revision 6484)
@@ -0,0 +1,30 @@
+#!/bin/sh
+#
+# JMB_PUBLISH_PEER
+#
+# The majority of this code comes from:
+# Python Cookbook, 2nd ed., by Alex Martelli, Anna Martelli Ravenscroft, and David Asher
+# (O'Relly Media, 2005) 0-596-00797-3
+# Section 16.12 credited to Joerg Raedler
+#
+
+PYTHON=$(which python 2>/dev/null)
+
+if [ -x "x$PYTHON" ] ; then
+    echo "python executable not found - cannot continue!"
+    exit 1
+fi
+
+exec $PYTHON -c "
+
+import sys, os
+version = sys.version_info[:2]
+if version < (2,3):
+    print 'Sorry, need python 2.3 or better; %s%s is too old' % version
+    sys.exit(1)
+sys.path.insert(0, sys.argv[1])
+del sys.argv[0]
+
+import main
+
+main.main()" $0 $@

Property changes on: Apps/GSOC_JMB_Publish/Peer/zipheader.unix
___________________________________________________________________
Added: svn:executable
   + *


Property changes on: Apps/GSOC_JMB_Publish
___________________________________________________________________
Added: svn:mergeinfo

Index: Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/consts.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/consts.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/consts.py	(revision 6484)
@@ -0,0 +1,26 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+BPLANE_INBOX = 'INTERFACE_INBOX'
+BPLANE_CONTROL = 'INTERFACE_CONTROL'
Index: Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/translator.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/translator.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/translator.py	(revision 6484)
@@ -0,0 +1,621 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+"""
+========================
+Translator (Gateway)
+========================
+
+Translators are designed to take a request from the HTTP server (using the
+WSGILikeTranslator) and turn it into a message that can be sent out via headstock.
+It also takes a message from headstock and turns it into a response that can be
+sent out by the HTTPServer.
+
+There are three subcomponents in a Translator: A RequestSerializer, a
+ResponseDeserializer, and a Controller.  The RequestSerializer takes the incoming
+HTTP request and turns it into a form that can be sent to the peer.  The
+ResponseDeserializer takes a message from the Peer and turns it into a form that
+can be sent to the page requester by the HTTPServer.  The Controller does most of
+the signal handling and is responsible for receiving signals and forwarding them
+to the appropriate components.
+
+How does it work?
+------------------
+
+The system is made to connect to a pair of backplanes (via a PublishTo component
+of course).  The first service that it subscribes to will connect to the interface's
+inbox.  This is used to send the interface messages to be sent out to the peer.
+The second backplane is used to connect to the interface's control inbox.  This service
+is used by the Translator to register itself with the interface and to notify the
+interface that it's done.
+
+You probably don't need to instantiate either the RequestSerializer or
+ResponseDeserializer directly.  You should instead call the factory function
+Translator, which will automatically create the components and link them.  Note
+that it is possible to change the RequestSerializer or ResponseDeserializer in
+the Translator funcion, but be aware that they must use the same interface as the
+components they replace.
+
+What is crosstalk?
+--------------------
+
+Cross talk is a way of passing data back and forth between the gateway and the peer
+It is basically a dictionary that roughly maps to a CGI environment-like dictionary
+that has been serialized into JSON (using simplejson).  There are a few other fields
+that may be in a crosstalk message.
+
+- 'batch' is the "series" of messages a message is a part of.  Each HTTP request
+and its associated response (together referred to as a "transaction") are assigned
+a batch id.  This ID will be used to determine which "conversation" a message belongs
+to.  This is the id that the interface will use to determine which translator to
+send a message to.  The batch id also corresponds to the XMPP thread ID.
+
+- 'signal' will be present to signal certain things.  Presently, it is used to
+notify the peer when the gateway has transmitted the entire HTTP request (formatted
+into crosstalk) and by the Peer to signal when the entire HTTP response has been
+transmitted.
+
+- 'body' will contain a chunk of the body or the body in its entirety.
+
+The batch ID must be in all crosstalk messages while the signal and body fields may
+be in the initial message, a separate message, or may not even be in the same message
+(the Translator will currently send signal in a message by itself.)
+
+For more info on CGI environment variables that may be present, see the following
+webpage:  http://hoohoo.ncsa.uiuc.edu/cgi/env.html
+
+In additon to the standard CGI variables, the following variable may also be present:
+
+- 'NON_QUERY_URI' represents the URI without the query string.  For example, the
+URI /a/b/c?d=e would give a NON_QUERY_URI of /a/b/c
+
+What is JSON?
+--------------
+JSON may sound like an intimidating thing, but it's not.  It's a data serialization format
+sort of like XML, only less verbose and simpler.  In fact, if you're reading this,
+you're probably already familiar with a significant amount of its syntax.  For example,
+you can do this at the python command line (assuming you have simplejson installed):
+
+>>> import simplejson
+>>> x = {'a' : 'b', 'c' : 'd', 'e' : 'f'}
+>>> simplejson.dumps(x)
+'{"a": "b", "c": "d", "e": "f"}'
+>>> simplejson.dumps(y)
+'["a", "b", "c", "d", "e", "f"]'
+>>> z = {'a' : ['b', 'c', 'd', 'e'], 'f' : ['g', 'h', 'i', 'j']}
+>>> simplejson.dumps(z)
+'{"a": ["b", "c", "d", "e"], "f": ["g", "h", "i", "j"]}'
+
+
+You'll notice that the formatting is almost identical to the way that Python prints
+out string representation of basic objects.
+
+What else will be done to the message?
+--------------------------------------
+
+The message will be gzipped to be smaller, and will then be base64 encoded to
+prevent any text in the message from invalidating the XML that will be used by
+XMPP.
+"""
+import Axon
+from Axon.CoordinatingAssistantTracker import coordinatingassistanttracker as cat
+
+from Axon.Component import component
+from Axon.Ipc import producerFinished, shutdownMicroprocess
+from Axon.idGen import numId
+from Kamaelia.Chassis.Graphline import Graphline
+from Kamaelia.Util.Backplane import PublishTo, SubscribeTo
+from Kamaelia.Protocol.HTTP.ErrorPages import getErrorPage
+from Kamaelia.Apps.JMB.Common.IPC import LookupByText, userLoggedOut, batchDone, newBatch, internalNotify
+from Kamaelia.Apps.JMB.Common.Console import info, debug, warning
+
+from headstock.api.im import Message, Body, Event, Thread
+from headstock.api.jid import JID
+from headstock.lib.utils import generate_unique
+
+import base64, weakref
+from xml.sax.saxutils import escape, unescape
+import zlib
+from pprint import pformat
+
+import simplejson
+
+from Kamaelia.Apps.JMB.Publish.Gateway.consts import BPLANE_CONTROL, BPLANE_INBOX
+from Kamaelia.Apps.JMB.Publish.Gateway.JIDLookup import ExtractJID
+
+_logger_suffix='.publish.gateway.translator'
+
+
+class RequestSerializer(component):
+    """
+    This component will take a request from the HTTPServer and translate it into
+    a form that can be sent over XMPP via headstock.  It will turn the request it
+    receives in __init__ into the initial message to be sent to the interface (where
+    it will be then be sent to the Peer via XMPP).
+    
+    For each body chunk that this component receives from the HTTPServer, it will
+    generate a separate XMPP message.
+    
+    Signals the RequestSerializer accepts:
+      -producerFinished - used by the HTTPServer to notify that the entire HTTP
+       message has been sent.
+      -shutdownMicroprocess - used to notify this component that needs to shutdown
+       (usually used during program shutdown or during an error).
+       
+    The signals will be sent out to the peer in the Crosstalk signal field.
+    """
+    Inboxes = {'inbox' : 'Receive messages from the HTTPServer',
+               'control' : 'Receive signals from the HTTPServer'}
+    Outboxes = {'outbox' : 'Send messages to the Interface',
+                'signal' : 'Send signals',}
+    
+    ThisJID = u'sparks.m@gmail.com'    #FIXME: BROKEN LIKE A BROKEN THING IN BROKEN VILLE ON BROKEN DAY
+    def __init__(self, request, batch_id, **argd):
+        """
+        request - The request that was sent by the HTTPServer.
+        batch_id - The "series" of messages this translator is associated with.
+           Comparable to the thread in an XMPP message.
+        """
+        super(RequestSerializer, self).__init__(**argd)
+        self.request = request
+        print "REQUEST", request
+        self.signal = None
+        self.batch_id = batch_id
+        self.request['batch'] = self.batch_id
+        
+        if not isinstance(self.ThisJID, unicode):
+            self.ThisJID = unicode(self.ThisJID)
+        
+        self.bundle = None
+        
+    def main(self):
+        myjid = cat.getcat().retrieveValue("MYJID")
+        self.ThisJID = myjid
+        self.ToJID = ExtractJID(self.request)
+        info('request for [%s], batch %s', _logger_suffix, self.request['REQUEST_URI'], self.batch_id)
+        
+        if self.ToJID:
+            self.sendRegisterSignal()
+            yield 1 # give the register signal time to get to the interface
+            self.sendMessage(self.request)
+            debug('User found.  Initial message sent for batch %s.', _logger_suffix, self.batch_id)
+            print "USER ID", self.ToJID
+            print "REQUEST", self.request
+
+        else:
+            #FIXME:  Note that sometimes the gateway won't receive a message when
+            #it first logs in that a user is available.  It's really better to double
+            #check with the server to get the user's status before assuming that
+            #they are offline.
+            self.JIDNotFound()
+            debug('User not found for batch %s.', _logger_suffix, self.batch_id)
+            return
+        
+        #Note that self.signal is set in handleControlBox
+        while not self.signal:
+            for msg in self.Inbox('control'):
+                self.handleControlBox(msg)
+
+            for msg in self.Inbox('inbox'):
+                self.handleInbox(msg)
+                
+            if not self.signal and not self.anyReady():
+                self.pause()
+                
+            yield 1
+    
+        signal_msg = {'signal' : type(self.signal).__name__,
+                      'batch' : self.batch_id}
+        self.sendMessage(signal_msg)
+    
+    def handleInbox(self, msg):
+        """
+        msg - the message from the HTTPServer.
+        
+        This method simply forwards a body chunk from the HTTPServer to the Peer.
+        """
+        chunk = {
+            'body' : escape(msg),
+            'batch' : self.batch_id,
+        }
+        self.sendMessage(chunk)
+    
+    def handleControlBox(self, msg):
+        """
+        This method will shut the component down if a shutdownMicroprocess or
+        producerFinished message is received.
+        """
+        if isinstance(msg, (shutdownMicroprocess, producerFinished)):
+            self.signal = msg
+        
+    def sendRegisterSignal(self):
+        """
+        This message will be called so that the translator will register itself
+        with the interface.  A translator must be registered to receive notifications
+        when it receives a message.  Thus, this must be called before the translator
+        can receive any messages from the interface.
+        """
+        signal = newBatch(self.batch_id,
+                          self.bundle(), #dereference the weakref
+                          self.ToJID)
+        self.send(signal, 'signal')
+        
+    def JIDNotFound(self):
+        """
+        This function is used to return a 404 error page if no user matches the
+        requested URI.  This will send out an internalNotify signal (which is internal
+        to the Translator).
+        """
+        resource = getErrorPage(404, 'Could not find %s' % (self.request['REQUEST_URI']))
+        out = internalNotify(message=resource)
+        self.send(out, 'signal')
+        
+    def makeMessage(self, serializable):
+        """
+        This function actually does the work of translating a message to a form
+        that can be sent out over XMPP.  It will make a Message (a headstock
+        entity that will translate into XML) and encode the body in JSON, gzip it,
+        and then base64 encode it.
+        
+        The message will be sent out to the interface to be sent to the peer.
+        """
+        print "MAKING MESSAGE", self.ThisJID, self.ToJID, "chat"
+        m = Message(unicode(self.ThisJID), 
+                           unicode(self.ToJID),
+                           type=u'chat',
+                           stanza_id=generate_unique())
+            
+        body = simplejson.dumps(serializable)
+        debug_out = simplejson.dumps(serializable, indent=2, sort_keys=True)
+        debug('Outgoing CrossTalk message: %s' % debug_out, _logger_suffix)
+        body = zlib.compress(body)
+        body = base64.encodestring(body)
+        body = unicode(body)
+        m.bodies.append(Body(body))
+        
+#        m.thread = Thread(self.batch_id)
+        print "MESSAGE MADE:", repr(m)
+        return m
+    
+    def sendMessage(self, serializable):
+        """This convenience function will make a message and then send it out via
+        the outbox."""
+        if True:
+            print "IGNORING USUAL STEPS, USING HEADSTOCK SIMPLECHAT CODE"
+
+            print "FROM",self.ThisJID, "TO", self.ToJID
+            print "MESSAGE", repr(serializable)
+            m = Message(unicode(self.ThisJID),
+                        unicode(self.ToJID), 
+                        type=u'chat',
+                        stanza_id=generate_unique())
+            m.event = Event.composing # note the composing event status
+            
+            m.bodies.append(Body(unicode(simplejson.dumps(serializable))))
+#            m.bodies.append(Body(unicode(repr(serializable))))
+            self.send(m, "outbox")
+
+            # Right after we sent the first message
+            # we send another one reseting the event status
+
+            m = Message(unicode(self.ThisJID), unicode(self.ToJID), 
+                        type=u'chat', stanza_id=generate_unique())
+
+            self.send(m, "outbox")
+
+
+        else:
+            print "SENDING MESSAGE", serializable
+
+            serialised = self.makeMessage(serializable)
+            print "SERIALISED", serialised
+            self.send(serialised, 'outbox')
+        
+class ResponseDeserializer(component):
+    """
+    This component will take a response from a Peer and translate it into a form
+    that can be turned into an HTTP response by the HTTPServer.
+    
+    Signals the ResponseDeserializer will accept:
+      -producerFinished - Used to signal normal shut down.  Note that this will
+       be sent to this translator by the peer using XMPP, so such a signal will
+       more than likely come in on the inbox rather than the control box (the name
+       of the signal directly corresponds to its type, ie a signal of 'producerFinished'
+       will represent an instance of Axon.Ipc.producerFinished).  This will be
+       forwarded to the signal outbox.
+      -shutdownMicroprocess - this signal is used to indicate that the component
+       should shut down immediately.  This will be forwarded to the signal box.
+      -internalNotify - this is a signal that is to be used internally by the Translator.
+       The ResponseSerializer will send the text inside this message's message attribute
+       to the HTTP server as the text of the webpage.  Presently, this signal is
+       only sent when the RequestSerializer is unable to locate a user based on the
+       requested URI.  This message will not be forwarded to the signal outbox as
+       it is meant for internal use.
+       
+    Any other signals may result in undefined behavior, but will most likely shut
+    the component down and forward the signal to the signal outbox (going to the
+    HTTP server) much like the producerFinished and shutdownMicroprocess.
+    """
+    Inboxes = {'inbox' : 'Receive responses to deserialize',
+               'control' : 'Receive shutdown signals',}
+    Outboxes = {'outbox' : 'Send deserialized responses',
+                'signal' : 'Forward shutdown signals to the HTTPServer',}
+    def __init__(self, batch_id, **argd):
+        super(ResponseDeserializer, self).__init__(**argd)
+        self.signal = None
+        self.batch_id = batch_id
+        
+    def main(self):
+        self.not_done = True
+        while not self.signal:
+            [self.handleControlBox(msg) for msg in self.Inbox('control')]
+            [self.handleInbox(msg) for msg in self.Inbox('inbox')]
+            
+            if not self.anyReady() and not self.signal:
+                self.pause()
+                
+            yield 1
+        if not isinstance(self.signal, internalNotify):
+            debug('Translator %s sending signal %s' %(self.batch_id, self.signal),
+                  _logger_suffix)
+            self.send(self.signal, 'signal')
+            self.send(batchDone(self.batch_id), 'signal')
+        
+    def handleInbox(self, msg):
+        deserialize = ''.join([str(body) for body in msg.bodies])
+        #Sometimes an emty message comes through to reset the event status.  This
+        #will cause errors if we process it.
+        if deserialize:
+            deserialize = base64.decodestring(deserialize)
+            deserialize = zlib.decompress(deserialize)
+            resource = simplejson.loads(deserialize)
+            
+            signal = resource.get('signal')
+            if signal:
+                self.signal = LookupByText(signal)(self)
+                del resource['signal']
+            if resource:
+                self.send(resource, 'outbox')
+        else:
+            warning('deserialize empty', _logger_suffix)
+    def handleControlBox(self, msg):
+        if isinstance(msg, (producerFinished, shutdownMicroprocess)):
+            self.signal = msg
+        elif isinstance(msg, internalNotify):
+            #The user was not found.
+            resource = msg.message
+            self.send(resource, 'outbox')
+            self.send(producerFinished(self), 'signal')
+            self.signal = msg
+        elif isinstance(msg, userLoggedOut):
+            #The user logged out mid-batch
+            resource = getErrorPage(502, 'Batch %s terminated unexpectedly.' % (msg.thread))
+            self.send(resource, 'outbox')
+            self.signal = producerFinished(self)
+            
+class TranslatorController(component):
+    Inboxes = {'inbox' : 'NOT USED',
+               'control' : 'Receive signals from internal components',
+               'interface_control' : 'Receive signals from the interface',}
+    Outboxes = {'outbox' : 'NOT USED',
+                'signal' : 'NOT USED',
+                'interface_signal' : 'Send messages to the interface',
+                'signal_publisher_in' : """Send shutdown messages to the
+                                           in publisher""",
+                'signal_publisher_signal' : """Send shutdown messages to
+                                               the signal publisher""",
+                'signal_serializer' : 'Send signals to the serializer',
+                'signal_deserializer' : 'Send signals to the deserializer',
+                'http_signal' : 'Send shutdown signals to the HTTPServer',}
+    def main(self):
+        self.signal = None
+        while not self.signal:
+            for msg in self.Inbox('control'):
+                if isinstance(msg, internalNotify):
+                    #Notify internal components that we're done.
+                    #Note that no signal is sent out to the HTTP server or interface
+                    #by this component.  The signal to the HTTP server will be sent
+                    #by the deserializer and no message is necessary to the interface
+                    #since it won't have started tracking the component yet.
+                    self.sendSignals(msg)
+                    self.signal = msg
+                elif isinstance(msg, batchDone):
+                    #This signals normal shutdown when everything is fine.  The
+                    #interface and HTTP Server will both be notified.
+                    self.sendSignals(signal=msg,
+                                     interface_signal=msg,
+                                     http_signal=producerFinished())
+                    self.signal = msg
+                elif isinstance(msg, shutdownMicroprocess):
+                    #Not currently sent to this component by anything in Kamaelia
+                    #Publish, but we do want to shut down when we receive this
+                    #message.
+                    self.sendSignals(msg, msg, msg)
+                    self.signal = msg
+                elif isinstance(msg, newBatch):
+                    #This will go to the interface signaling that it should track
+                    #a new batch.
+                    self.send(msg, 'interface_signal')
+                else:
+                    warning('Unknown message %s received.  Ignoring' % (msg),
+                            _logger_suffix)
+            for msg in self.Inbox('interface_control'):
+                if isinstance(msg, userLoggedOut):
+                    #This message is from the interface notifying us that the user
+                    #has logged out mid-batch.  No notification is necessary for
+                    #the interface, since there the one that notified us.  The
+                    #deserializer will send the message to the HTTP Server.
+                    self.sendSignals(msg)
+                    self.signal=msg
+                else:
+                    warning('Unknown message %s received.  Ignoring.' % (msg),
+                            _logger_signal)
+            for msg in self.Inbox('inbox'):
+                pass #pop the messages so they won't keep unpausing this component
+            
+            if not self.signal and not self.anyReady():
+                self.pause()
+                
+            yield 1
+            
+                
+    def sendSignals(self, signal, interface_signal=None, http_signal=None):
+        """This will send the specified signal to the signal serializer and deserializer
+        and a producerFinished to the publishers."""
+        self.send(signal, 'signal_serializer')
+        self.send(signal, 'signal_deserializer')
+        self.send(producerFinished(), 'signal_publisher_in')
+        self.send(producerFinished(), 'signal_publisher_signal')
+        if interface_signal:
+            self.send(interface_signal, 'interface_signal')
+        if http_signal:
+            self.send(http_signal, 'http_signal')
+            
+def Translator(request, mtr=None, rtm=None):
+    batch = unicode(numId())
+    if not mtr:
+        print "MAKING RequestSerializer"
+        mtr = ResponseDeserializer(batch)
+    if not rtm:
+        print "MAKING RequestSerializer"
+        rtm = RequestSerializer(request, batch)
+
+    X = TranslatorController()
+    print "MTR", mtr
+    print "RTM", rtm
+    print "BPLANE_INBOX", BPLANE_INBOX
+    print "BPLANE_CONTROL", BPLANE_CONTROL
+
+    print "TranslatorController", X
+
+    trans = Graphline(
+        mtr=mtr,
+        rtm=rtm,
+        interface_in=PublishTo(BPLANE_INBOX),
+        interface_signal=PublishTo(BPLANE_CONTROL),
+            controller=X,
+        linkages={
+            #These are the boxes that the HTTPServer will use
+            ('self', 'inbox') : ('rtm', 'inbox'),
+            ('mtr', 'outbox') : ('self', 'outbox'),
+                
+            #These are the boxes that the XMPP Handler will use.
+            ('self', 'xmpp_in') : ('mtr', 'inbox'),
+            ('rtm', 'outbox') : ('interface_in', 'inbox'),
+                
+            #This is the signal handling
+            ('self', 'control') : ('rtm', 'control'),
+            ('rtm', 'signal') : ('controller', 'control'),
+            ('mtr', 'signal') : ('self', 'signal'), #Will go to the HTTPServer
+            ('controller', 'signal_serializer') : ('rtm', 'control'),
+            ('controller', 'signal_deserializer') : ('mtr', 'control'),
+            ('controller', 'http_signal') : ('self', 'signal'),
+            ('controller', 'interface_signal') : ('interface_signal', 'inbox'),
+            ('controller', 'signal_publisher_in') : ('interface_in', 'control'),
+            ('controller', 'signal_publisher_signal') : ('interface_signal', 'control'),
+            ('self', 'xmpp_control') : ('controller', 'interface_control')
+        }
+    )
+    
+    rtm.bundle = weakref.ref(trans) #use a weakref to prevent circular references
+    print rtm.bundle
+    print trans
+
+    return trans
+
+
+if __name__ == '__main__':
+    from Kamaelia.Util.Console import ConsoleEchoer
+    from Kamaelia.Chassis.Pipeline import Pipeline
+    
+    class Server(component):
+        def main(self):
+            self.send('foo')
+            yield 1
+            self.send(producerFinished(self), 'signal')
+            yield 1
+            signal = None
+            while not signal:
+                for msg in self.Inbox('control'):
+                    if isinstance(msg, (producerFinished, shutdownMicroprocess)):
+                        signal = msg
+                        print 'Server received:\n', repr(msg)
+                        
+                for msg in self.Inbox('inbox'):
+                    print 'Server received:\n', repr(msg)
+                    
+                if not (signal or self.anyReady()):
+                    self.pause()
+                    
+                yield 1
+            
+            
+            
+    class Client(component):
+        def main(self):
+            signal = None
+            while not signal:
+                for msg in self.Inbox('control'):
+                    if isinstance(msg, (producerFinished, shutdownMicroprocess)):
+                        signal = msg
+                        print 'Client received:\n', repr(msg)
+                        
+                for msg in self.Inbox('inbox'):
+                    print 'Client received:\n', repr(msg)
+                    self.send(msg, 'outbox')
+                    
+                if not (signal or self.anyReady()):
+                    self.pause()
+                    
+                yield 1
+                
+            self.send(signal, 'signal')
+            
+    request={
+        'a' : 'b',
+        'c' : 'd',
+        'e' : 'f',
+    }
+    Graphline(
+        server=Server(),
+        trans=Translator(request),
+        client=Client(),
+        
+        linkages={
+            #server
+            ('server', 'outbox') : ('trans', 'inbox'),
+            ('trans', 'outbox') : ('server', 'inbox'),
+                
+            #client
+            ('client', 'outbox') : ('trans', 'xmpp_in'),
+            ('trans', 'xmpp_out') : ('client', 'inbox'),
+                
+            #shutdown handling
+            ('client', 'signal') : ('trans', 'xmpp_control'),
+            ('server', 'signal') : ('trans', 'control'),
+            ('trans', 'signal') : ('server', 'control'),
+            ('trans', 'xmpp_signal') : ('client', 'control')
+        }
+    ).run()
+    print '\n'

Property changes on: Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/translator.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/__init__.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/__init__.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/__init__.py	(revision 6484)
@@ -0,0 +1,5 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+
Index: Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/JIDLookup.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/JIDLookup.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/JIDLookup.py	(revision 6484)
@@ -0,0 +1,162 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+"""
+This module will track users in a database.  You must first call connectToDB to
+connect to the database.  This will bind the class UserSession to an engine.
+
+Once this is done, you can call setUserStatus to control whether a user is online
+or not.  You may also call ExtractJID to tetermine a user's JID based on the URI
+that was passed to the server.
+"""
+from Kamaelia.Support.Protocol.HTTP import PopWsgiURI
+from Kamaelia.Apps.JMB.Publish.Gateway.UserDatabase import getUserTable, User
+from Kamaelia.Apps.JMB.Common.Console import debug
+
+from headstock.api.jid import JID
+
+import sqlalchemy
+from sqlalchemy import Table, Column, Integer, String, MetaData, ForeignKey
+from sqlalchemy.orm import mapper, sessionmaker
+from sqlalchemy.exceptions import InvalidRequestError
+
+_logger_suffix = '.publish.gateway.JIDLookup'
+
+#Generate a class type for sessions.
+UserSession = sessionmaker(autoflush=True, transactional=True)
+
+#A boolean value just to check and see if we've already connected to the db.
+_connected = False
+
+def _getURI(jid_text, session):
+    """A convenience function for GetUser in case we just want the uri."""
+    return GetUser(jid_text, session).url_prefix
+    
+def ExtractJID(request):
+    """
+    This function will take a request that has been generated by the HTTPServer
+    (using the WSGILikeTranslator) and extract a JID from it.  If the JID wasn't
+    found, this function will return an empty string.
+    
+    FIXME:  Sometimes, the user will show as inactive in the database even if they
+    are active.  We really should check to see if the user is active before throwing
+    a 404.
+    """
+    raw = request['REQUEST_URI']
+    split_raw = raw.split('/')
+    split_raw = [x for x in split_raw if x]  #remove empty strings
+    PopWsgiURI(request)
+    if split_raw:
+        session = UserSession()
+        user = _getUserByURI(split_raw[0], session)
+        if user:    
+            debug('%s located.' % (user.jid), _logger_suffix)    
+            return user.jid
+        else:
+            debug('JID not found for %s' % (request['REQUEST_URI']), _logger_suffix)
+            return ''
+    else:
+        debug('JID not found for %s' % (request['REQUEST_URI']), _logger_suffix)    
+        return ''
+
+def setUserStatus(jid_text, active):
+    """This is used to mark a user as active or inactive.  If active is True, the
+    JID specified will be marked as active.  If active is False, the JID will be
+    marked inactive."""
+    if isinstance(jid_text, JID):
+        jid_text = jid_text.nodeid()
+    session = UserSession()
+    try:
+        user = _getUser(jid_text, session)
+    except Exception, e:
+        print "WARNING FOR", jid_text, session, "UNABLE TO _getUser Exception:", e
+        return
+    print "GOT User", jid_text, session, user
+    user.active=bool(active)
+    session.update(user)
+    session.commit()
+    
+def _getUser(jid_text, session):
+    """Gets a user out of the database by JID."""
+    import sys
+    sys.stderr.write("_getUser.1" + repr( (jid_text, session) )+"\n\n")
+    Q = session.query(User)
+    sys.stderr.write("_getUser.2"+repr(Q)+"\n")
+    FBJ = Q.filter_by(jid=jid_text)
+    sys.stderr.write("_getUser.3"+repr(FBJ)+"\n")
+    O  = FBJ.one()
+    sys.stderr.write("_getUser.4"+repr(O)+"\n")
+    return O
+#    return session.query(User).filter_by(jid=jid_text).one()
+
+def _getUserByURI(uri, session):
+    """Gets a user out of the database by URI."""
+    try:
+        return session.query(User).filter_by(url_prefix=uri, active=True).one()
+    except InvalidRequestError:
+        return ''
+    
+def connectToDB(Config, **argd):
+    """
+    This function will connect to the database.  The important part of Config is
+    the db member of the server section.  This will specify the database to connect
+    to.
+    
+    **argd represents keyword arguments that will be passed to sqlalchemy.create_engine.
+    """
+    #Note:  this module is to be treated as an "object".  Thus, while these variables
+    #may be marked global, they aren't necessarily intended to be used globally
+    #throughout the application.
+    global _connected, _user_engine, _meta, _users
+    if not _connected:
+        _connected = True
+        
+        print Config.server.db
+        
+        _user_engine = sqlalchemy.create_engine(Config.server.db, **argd)
+        print _user_engine
+        UserSession.configure(bind=_user_engine)
+        print "Here"
+        _meta = MetaData(bind=_user_engine)
+        print "There"
+        _users = getUserTable(_meta)
+        print "Also There"
+        _meta.create_all()
+        print "_meta", _meta
+        print "Also here"
+        mapper(User, _users)
+        
+        
+        from atexit import register
+        register(_cleanup)
+        _cleanup()
+        
+def _cleanup():
+    """This function will make sure that all users are inactive in the database."""
+    session = UserSession()
+    
+    for user in session.query(User).filter_by(active=True):
+        user.active=False
+    
+    session.commit()

Property changes on: Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/JIDLookup.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/UserDatabase.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/UserDatabase.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/UserDatabase.py	(revision 6484)
@@ -0,0 +1,54 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_GATEWAY
+#
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+
+from sqlalchemy import Table, Column, Integer, String, MetaData, ForeignKey, create_engine, Boolean, Unicode
+
+class BaseUser(object):
+    def __init__(self, jid, url_prefix, active=False):
+        print "BaseUser.__init__"
+        self.jid = jid
+        self.url_prefix = url_prefix
+        self.active = active
+        
+    def __repr__(self):
+        print "BaseUser.__repr__"
+        return '<User jid=%s, url_prefix=%s>' % (self.jid, self.url_prefix)
+    
+class User(BaseUser):
+    pass
+
+class ActiveUser(BaseUser):
+    pass
+
+def getUserTable(meta, tablename='users'):
+    print "getUserTable"
+    X = Table(tablename, meta,
+                Column('id', Integer, primary_key=True),
+                Column('jid', Unicode(50)),
+                Column('url_prefix', Unicode(10)),
+                Column('active', Boolean())
+    )
+    print "getUserTable", X
+    return X

Property changes on: Kamaelia/Kamaelia/Apps/JMB/Publish/Gateway/UserDatabase.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Kamaelia/Kamaelia/Apps/JMB/Publish/__init__.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Publish/__init__.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Publish/__init__.py	(revision 6484)
@@ -0,0 +1,2 @@
+#!/usr/bin/env python
+
Index: Kamaelia/Kamaelia/Apps/JMB/Publish/Peer/translator.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Publish/Peer/translator.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Publish/Peer/translator.py	(revision 6484)
@@ -0,0 +1,511 @@
+#!/usr/bin/env python
+#
+#
+# JMB_PUBLISH_PEER
+#
+# Copyright (C) 2008 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+"""
+========================
+Translator (Peer)
+========================
+
+Translators are designed to take a request from the HTTP server (using the
+WSGILikeTranslator) and turn it into a message that can be sent out via headstock.
+It also takes a message from headstock and turns it into a response that can be
+sent out by the HTTPServer.
+
+There are three subcomponents in a Translator: A RequestDeserializer, a
+ResponseSerializer, and a TranslatorChassis.  The RequestDeserializer takes the incoming
+HTTP request and turns it into a form that can be used by the handler.  The
+ResponseSerializer takes a response by the Handler and turns it into a form that
+can be sent to the Gateway.  The TranslatorChassis managesthe components and forwards
+their messages to the TransactionManager.
+
+These components will also create a handler, which will be responsible for generating
+a Webpage that will be viewed by the person that sent the HTTP request to the Gateway.
+
+How does it work?
+------------------
+The TransactionManager will create a new TranslatorChassis when it receives a new
+incoming request.  The TranslatorChassis will create a new RequestDeserializer and
+a ResponseSerializer, passing the initial request along to the RequestDeserializer.
+Once the request has been translated, the TranslatorChassis will create the handler.
+The RequestDeserializer will continue to forward body chunks on to the handler until
+the Gateway signals that the body is done (using a producerFinished signal).  The
+handler will forward its response to the ResponseSerializer, which will translate
+the request to a form that may be sent over a network and then send the request out
+to headstock.
+
+You probably don't need to instantiate either the RequestDeserializer or
+ResponseSerializer directly.  You should instead call the factory function
+Translator, which will automatically create the components and link them.
+
+What is crosstalk?
+--------------------
+
+Cross talk is a way of passing data back and forth between the gateway and the peer
+It is basically a dictionary that roughly maps to a CGI environment-like dictionary
+that has been serialized into JSON (using simplejson).  There are a few other fields
+that may be in a crosstalk message.
+
+- 'batch' is the "series" of messages a message is a part of.  Each HTTP request
+and its associated response (together referred to as a "transaction") are assigned
+a batch id.  This ID will be used to determine which "conversation" a message belongs
+to.  This is the id that the interface will use to determine which translator to
+send a message to.  The batch id also corresponds to the XMPP thread ID.
+
+- 'signal' will be present to signal certain things.  Presently, it is used to
+notify the peer when the gateway has transmitted the entire HTTP request (formatted
+into crosstalk) and by the Peer to signal when the entire HTTP response has been
+transmitted.
+
+- 'body' will contain a chunk of the body or the body in its entirety.
+
+The batch ID must be in all crosstalk messages while the signal and body fields may
+be in the initial message, a separate message, or may not even be in the same message
+(the Translator will currently send signal in a message by itself.)
+
+For more info on CGI environment variables that may be present, see the following
+webpage:  http://hoohoo.ncsa.uiuc.edu/cgi/env.html
+
+In additon to the standard CGI variables, the following variable may also be present:
+
+- 'NON_QUERY_URI' represents the URI without the query string.  For example, the
+URI /a/b/c?d=e would give a NON_QUERY_URI of /a/b/c
+
+What is JSON?
+--------------
+JSON may sound like an intimidating thing, but it's not.  It's a data serialization format
+sort of like XML, only less verbose and simpler.  In fact, if you're reading this,
+you're probably already familiar with a significant amount of its syntax.  For example,
+you can do this at the python command line (assuming you have simplejson installed):
+
+>>> import simplejson
+>>> x = {'a' : 'b', 'c' : 'd', 'e' : 'f'}
+>>> simplejson.dumps(x)
+'{"a": "b", "c": "d", "e": "f"}'
+>>> simplejson.dumps(y)
+'["a", "b", "c", "d", "e", "f"]'
+>>> z = {'a' : ['b', 'c', 'd', 'e'], 'f' : ['g', 'h', 'i', 'j']}
+>>> simplejson.dumps(z)
+'{"a": ["b", "c", "d", "e"], "f": ["g", "h", "i", "j"]}'
+
+
+You'll notice that the formatting is almost identical to the way that Python prints
+out string representation of basic objects.
+
+What else will be done to the message?
+--------------------------------------
+
+The message will be gzipped to be smaller, and will then be base64 encoded to
+prevent any text in the message from invalidating the XML that will be used by
+XMPP.
+"""
+import Axon
+from Axon.CoordinatingAssistantTracker import coordinatingassistanttracker as cat
+
+from Axon.Component import component
+from Kamaelia.Apps.JMB.Common.IPC import LookupByText, ToText
+from Kamaelia.Apps.JMB.Common.Console import info, debug
+
+from xml.sax.saxutils import unescape, escape
+
+from headstock.api.im import Message, Body, Event, Thread
+from headstock.lib.utils import generate_unique
+
+import simplejson
+import zlib, base64
+
+_logger_suffix = '.publish.peer.translator'
+
+class RequestDeserializer(component):
+    Inboxes = {'inbox' : '',
+               'control' : '',}
+    Outboxes = {'outbox' : '',
+                'initial' : 'send the initial output',
+                'batch' : 'Output the batch id',
+                'signal' : '',
+                'chassis_signal' : '',}
+    def __init__(self, message, **argd):
+        super(RequestDeserializer, self).__init__(**argd)
+        self.batch_id = None
+        self.message = message
+    
+    def main(self):
+        self.processInitialMessage()
+        
+        self.signal = None
+        while not self.signal:
+            for msg in self.Inbox('inbox'):
+                msg = self.decodeMessage(msg)
+                
+                #signals may be included in the message by the gateway, so we
+                #check for a shutdown signal here.
+                sig = msg.get('signal')
+                if sig:
+                    #If there's a signal in the message, we send it to the chassis
+                    #to be sent right back to here after the request handler is
+                    #created.  This is done to prevent things from shutting down
+                    #too quickly.
+                    signal_type = LookupByText(sig)
+                    signal_instance = signal_type(self)
+                    self.send(signal_instance, 'chassis_signal')
+
+                self.send(msg, 'outbox')
+            
+            for msg in self.Inbox('control'):
+                self.signal = msg
+            
+            if not (self.anyReady() or self.signal):
+                self.pause()
+                
+            yield 1
+
+        self.send(self.signal, 'signal')
+    
+    def processInitialMessage(self):
+        
+        request = self.decodeMessage(self.message)
+        self.batch_id = request.get('batch', 0)
+        if self.batch_id == 0:
+            print "BATCH ID IS UNSET, RETURNING"
+            return
+        print "BATCH ID", self.batch_id 
+        self.send(self.batch_id, 'batch')
+        sig = request.get('signal')
+        if sig:
+            signal_type = LookupByText(sig)
+            signal_instance = signal_type(self)
+            self.send(signal_instance, 'chassis_signal')
+        
+        assert(isinstance(request, dict))
+        self.send(request, 'initial')
+        
+    def decodeMessage(self, msg):
+        temp = [str(x) for x in msg.bodies]
+        body = ''.join(temp)
+        if body:
+            print len(body)
+            print "--------------------------------------"
+            print repr(body)
+            print "--------------------------------------"
+            print "--------------------------------------"
+            print body
+            print "--------------------------------------"
+    #        body = base64.decodestring(body)
+    #        body = zlib.decompress(body)
+            #print body
+            return simplejson.loads(body)
+        else:
+            return {}
+    
+class ResponseSerializer(component):
+    Inboxes = {
+        'inbox' : '',
+        'control' : '',
+        'batch' : 'receive the batch ID'
+    }
+    Outboxes = {
+        'outbox' : '',
+        'signal' : '',
+    }
+    ThisJID = u'kamaelia.testing@googlemail.com'
+    ToJID = u'sparks.m@gmail.com'
+    def main(self):
+        #wait for the batch ID from the Request Translator
+        while not self.dataReady('batch'):
+            self.pause()
+            yield 1
+            
+        self.batch_id = self.recv('batch')
+        
+        self.signal = None
+        while not self.signal:
+            for response in self.Inbox('inbox'):
+                if response.get('signal'):
+                    del response['signal']
+                    
+                if response:
+                    self.sendMessage(response, 'outbox')
+#                    self.send(self.makeMessage(response), 'outbox')
+                
+            for msg in self.Inbox('control'):
+                self.signal = msg
+                self.sendMessage({'signal' : type(self.signal).__name__},"outbox")
+#                self.send(self.makeMessage({'signal' : type(self.signal).__name__}))
+                
+            if not self.anyReady() and not self.signal:
+                self.pause()
+                
+            yield 1
+            
+        yield 1
+        self.send(self.signal, 'signal')
+        #print 'serializer dying!'
+
+    def sendMessage(self, serializable, outbox):
+        if serializable.get('batch') != self.batch_id:
+            serializable['batch'] = self.batch_id
+
+        myjid = cat.getcat().retrieveValue("MYJID")
+        self.ThisJID = myjid
+
+        print "SENDMESSAGE", self.ThisJID, self.ToJID, serializable
+        print "SENDMESSAGE", u'kamaelia.testing@googlemail.com', self.ToJID, serializable
+
+        m = Message(unicode(self.ThisJID),
+                    unicode(self.ToJID), 
+                    type=u'chat',
+                    stanza_id=generate_unique())
+#        m = Message(unicode(u'kamaelia.testing@googlemail.com'),
+#                    unicode(self.ToJID), 
+#                    type=u'chat',
+#                    stanza_id=generate_unique())
+        m.event = Event.composing # note the composing event status
+
+        m.bodies.append(Body(unicode(simplejson.dumps(serializable))))
+        self.send(m, outbox)
+
+        debug_out = simplejson.dumps(serializable, indent=2, sort_keys=True)
+        debug('Outgoing CrossTalk message: %s' % (debug_out), _logger_suffix)
+
+
+        # Right after we sent the first message
+        # we send another one reseting the event status
+
+#        m = Message(unicode(u'kamaelia.testing@googlemail.com'), unicode(self.ToJID), 
+#                    type=u'chat', stanza_id=generate_unique())
+        m = Message(unicode(self.ThisJID), unicode(self.ToJID), 
+                    type=u'chat', stanza_id=generate_unique())
+
+        self.send(m, outbox)
+
+
+
+
+    def makeMessage(self, serializable):
+        #print serializable
+        if serializable.get('batch') != self.batch_id:
+            serializable['batch'] = self.batch_id
+        text = simplejson.dumps(serializable)
+        debug_out = simplejson.dumps(serializable, indent=2, sort_keys=True)
+        debug('Outgoing CrossTalk message: %s' % (debug_out), _logger_suffix)
+        text = zlib.compress(text)
+        text = base64.encodestring(text)
+        text = unicode(text)
+
+        msg = Message(self.ThisJID, self.ToJID,
+                      type=u'chat', stanza_id=generate_unique())
+        msg.bodies.append(Body(text))
+        msg.thread = Thread(self.batch_id)
+        
+        return msg
+        
+        
+class TranslatorChassis(component):
+    """
+    This is a chassis that will create a pair of translators and a resource handler
+    (aka Minimal or the WSGI Handler).  It will die only when all these components
+    die.
+    
+    Note that this component will also be responsible for forwarding messages from
+    the request translator to the resource handler.  It does this to prevent messages
+    that are sent before the resource handler is created from being lost.
+    """
+    Inboxes = {'inbox' : 'Receive body messages.  Forwarded to message translator',
+               'control' : '',
+               '_msg_translator' : 'Receive messages from the message translator',
+               '_body_chunks_in' : 'Receive body chunks',
+               '_request_control' : 'Receive signals from the request handler',}
+    Outboxes = {'outbox' : '',
+                'signal' : '',
+                '_body_chunks_out' : 'Send body chunks to the resource handler.',
+                '_request_signal' : 'Send signals to message translator',}
+    
+    requestTranslator = RequestDeserializer
+    responseTranslator = ResponseSerializer
+    
+    ThisJID = None
+    ToJID = u'sparks.m@gmail.com'
+    def __init__(self, message, handler_factory, **argd):
+        super(TranslatorChassis, self).__init__(**argd)
+        self.message = message
+        self.handler_factory = handler_factory
+        self.initializeComponents()
+        self.done = False
+        
+    def initializeComponents(self):
+        """Set up the response and request translators.
+        
+        FIXME:  This is a disorganized mess."""
+        self._requestTranslator = self.requestTranslator(self.message)
+        self.link((self, 'inbox'), (self._requestTranslator, 'inbox'), passthrough=1)
+        self.link((self, '_request_signal'), (self._requestTranslator, 'control'))
+        self.link((self._requestTranslator, 'outbox'), (self, '_body_chunks_in'))
+        self.link((self._requestTranslator, 'initial'), (self, '_msg_translator'))
+        self.link((self._requestTranslator, 'chassis_signal'), (self, '_request_control'))
+        
+        self._responseTranslator = self.responseTranslator(ThisJID=self.ThisJID, ToJID=self.ToJID)
+        self.link((self._requestTranslator, 'batch'), (self._responseTranslator, 'batch'))
+        self.link((self._responseTranslator, 'signal'), (self, 'signal'), passthrough=2)
+        
+        self.addChildren(self._requestTranslator, self._responseTranslator)
+        
+    def main(self):
+        self._requestTranslator.activate()
+        self._responseTranslator.activate()
+        
+        self.signal = None
+        initial_message_handled = False
+        
+        #Wait for the message translator to send its initial output
+        while not self.dataReady('_msg_translator'):
+            self.pause()
+            yield 1
+            
+        request = self.recv('_msg_translator')
+        #print 'chassis received:\n', request
+        
+        #FIXME: The below section is a disorganized mess
+        self.handler = self.handler_factory(request)
+        self._requestTranslator.link((self._requestTranslator, 'signal'), (self.handler, 'control'))
+        self.link((self, '_body_chunks_out'), (self.handler, 'inbox'))
+        self.link((self.handler, 'outbox'), (self._responseTranslator, 'inbox'))
+        self.link((self.handler, 'signal'), (self._responseTranslator, 'control'))
+        self.link((self._responseTranslator, 'outbox'), (self, 'outbox'), passthrough=2)
+        self.addChildren(self.handler)
+        self.handler.activate()
+        
+        while not self.childrenDone():                            
+            #This just forwards body chunks from the request translator to the
+            #resource handler.  This is done to prevent any messages that were
+            #sent out by the request translator before the resource handler is
+            #created from being lost.
+            for msg in self.Inbox('_body_chunks_in'):
+                self.send(msg, '_body_chunks_out')
+                
+            #essentially all the following code does is send a signal that was sent
+            #to us by the request translator.  It does this so that we can ensure
+            #that things don't get shut down too quickly.
+            for msg in self.Inbox('_request_control'):
+                self.send(msg, '_request_signal')
+                
+            if not self.anyReady() and not self.childrenDone():
+                self.pause()
+            
+            yield 1
+            
+    def childrenDone(self):
+       """Unplugs any children that have terminated, and returns true if there are no
+          running child components left (ie. their microproceses have finished)
+       """
+       for child in self.childComponents():
+           if child._isStopped():
+               self.removeChild(child)   # deregisters linkages for us
+
+       return 0==len(self.childComponents())
+    
+class SimpleHandler(component):
+    def __init__(self, request, **argd):
+        super(SimpleHandler, self).__init__(**argd)
+        self.request = request
+    def main(self):
+        self.signal = None
+        
+        resource = {
+            'statuscode' : '200 OK',
+            'headers' : [('content-type', 'text/plain')],
+            'data' : 'Hello, world!',
+        }
+        self.send(resource, 'outbox')
+        
+        while not self.signal:
+            for msg in self.Inbox('control'):
+                self.signal = msg
+
+            for msg in self.Inbox('inbox'):
+                print 'SimpleHandler received:\n', msg
+                self.send(msg, 'outbox')
+                
+            if not (self.anyReady() or self.signal):
+                self.pause()
+                
+            yield 1
+            
+        for msg in self.Inbox('inbox'):
+            self.send(msg, 'outbox')
+            
+        yield 1
+        
+        self.send(self.signal, 'signal')
+        
+_log_suffix='.publish.translator'
+
+if __name__ == '__main__':
+    from headstock.api.im import Message, Body
+    from Kamaelia.Chassis.Pipeline import Pipeline
+    
+
+    
+    class FakeHTTPServer(component):
+        body={u'body' : u'This is the body'}
+        def main(self):
+
+            for i in xrange(5):
+                self.body['count'] = i
+                msg = self.makeMessage(self.body)
+                self.send(msg, 'outbox')
+                yield 1
+                
+            signal = {'signal' : 'producerFinished'}
+            msg = self.makeMessage(signal)
+            self.send(msg, 'outbox')
+            
+            print 'FakeHTTPServer dying!'
+            
+        def makeMessage(self, serializable):
+            msg = Message(u'foo@foo.com', u'foo2@foo.com',
+                          type=u'chat')
+            
+            text = simplejson.dumps(serializable)
+            text = unescape(text)
+            text = unicode(text)
+            msg.bodies.append(Body(text))
+            
+            return msg
+    
+    request ={
+        'a' : 'b',
+        'c' : 'd',
+        'e' : 'f',
+        'batch' : '1234'
+    }
+    serial = simplejson.dumps(request)
+    serial = unicode(unescape(serial))
+    msg = Message(u'foo@foo.com', u'foo2@foo.com',
+                  type=u'chat')
+    msg.bodies.append(Body(serial))
+    
+    https = FakeHTTPServer()
+    tc = TranslatorChassis(msg, SimpleHandler)
+    print repr(tc)
+    
+    Pipeline(https, tc).run()

Property changes on: Kamaelia/Kamaelia/Apps/JMB/Publish/Peer/translator.py
___________________________________________________________________
Added: svn:executable
   + *

Index: Kamaelia/Kamaelia/Apps/JMB/Publish/Peer/__init__.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Publish/Peer/__init__.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Publish/Peer/__init__.py	(revision 6484)
@@ -0,0 +1,5 @@
+#!/usr/bin/env python
+#
+# JMB_PUBLISH_PEER
+#
+

Property changes on: Kamaelia/Kamaelia/Apps/JMB/Publish
___________________________________________________________________
Added: svn:mergeinfo

Index: Kamaelia/Kamaelia/Apps/JMB/Common/IPC.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Common/IPC.py	(revision 0)
+++ Kamaelia/Kamaelia/Apps/JMB/Common/IPC.py	(revision 6484)
@@ -0,0 +1,88 @@
+#!/usr/bin/env python
+# -*- coding: utf-8 -*-
+#
+# Copyright (C) 2004 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+
+from Axon.Ipc import producerFinished, notify
+
+# Pull in rather than redefine the standard ipc/control messages
+from Kamaelia.IPC import socketShutdown, serverShutdown
+from Kamaelia.IPC import newCSA, shutdownCSA, newServer
+from Kamaelia.IPC import newWriter, newReader, newExceptional
+from Kamaelia.IPC import removeReader, removeWriter, removeExceptional
+import Axon.Ipc as Ipc
+
+class userLoggedOut(notify):
+   def __init__(self, thread):
+      self.thread = thread
+      
+class batchDone(notify):
+   def __init__(self, thread):
+      self.thread=thread
+      
+class newBatch(notify):
+   def __init__(self, batch, bundle, to_jid):
+      self.batch_id = batch
+      self.bundle = bundle
+      self.to_jid = to_jid
+
+class internalNotify(Ipc.ipc):
+   """
+   This class is used to indicate that a message was posted to shut a component
+   down internally.  This should not be sent to any component outside of one
+   particular system of components.
+   """
+   def __init__(self, message=None):
+      self.message = message
+
+__ipc_msgs = [removeExceptional, removeWriter, removeReader, newExceptional, newReader,
+              newWriter, newServer, shutdownCSA, newCSA, serverShutdown, socketShutdown,
+              userLoggedOut, batchDone, newBatch, internalNotify]
+
+
+for key in dir(Ipc):
+   try:
+      if issubclass(getattr(Ipc,key),Ipc.ipc):
+         __ipc_msgs.append(getattr(Ipc,key))
+   except:
+      pass
+
+__ipc_lookup = {}
+
+def LookupByText(name):
+   global __ipc_lookup
+   if not __ipc_lookup:
+      for item in __ipc_msgs:
+         __ipc_lookup[item.__name__] = item
+         
+   return __ipc_lookup.get(name)
+
+def ToText(signal):
+   """Convert a signal into a text representation"""
+   return type(signal).__name__
+   
+if __name__ == '__main__':
+   signal_type = LookupByText('producerFinished')
+   signal = signal_type()
+   text = ToText(signal)
+   
+   print 'signal=%s' % (signal)
+   print 'text=%s' % (text)

Property changes on: Kamaelia/Kamaelia/Apps/JMB/Common/IPC.py
___________________________________________________________________
Added: svn:keywords
   + Author Date Id Revision
Added: svn:mergeinfo
Added: svn:eol-style
   + native
Added: svn:executable
   + *

Index: Kamaelia/Kamaelia/Apps/JMB/Common/Structs.py
===================================================================
--- Kamaelia/Kamaelia/Apps/JMB/Common/Structs.py	(revision 6391)
+++ Kamaelia/Kamaelia/Apps/JMB/Common/Structs.py	(revision 6484)
@@ -65,6 +65,7 @@
         
 class ConfigObject(object):
     def __init__(self, dictionary, options):
+        print "DEBUG", dictionary
         self.static = StaticConfigObject(dictionary['STATIC'])
         self.xmpp = XMPPConfigObject(dictionary['XMPP'])
         self.wsgi = dictionary['WSGI']  #FIXME:  Adapt the WSGI configuration dictionary
Index: Kamaelia/setup.py
===================================================================
--- Kamaelia/setup.py	(revision 6391)
+++ Kamaelia/setup.py	(revision 6484)
@@ -42,6 +42,9 @@
 		  "Kamaelia.Apps.JsonRPC",
 		  "Kamaelia.Apps.JMB",
 		  "Kamaelia.Apps.JMB.Common",
+		  "Kamaelia.Apps.JMB.Publish",
+		  "Kamaelia.Apps.JMB.Publish.Gateway",
+		  "Kamaelia.Apps.JMB.Publish.Peer",
 		  "Kamaelia.Apps.JMB.WSGI",
                   "Kamaelia.Apps.JMB.WSGI.Apps",
                   "Kamaelia.Apps.MPS",
