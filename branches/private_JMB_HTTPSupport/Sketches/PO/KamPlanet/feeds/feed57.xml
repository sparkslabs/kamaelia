<?xml version='1.0' encoding='UTF-8'?><?xml-stylesheet href="http://www.blogger.com/styles/atom.css" type="text/css"?><feed xmlns='http://www.w3.org/2005/Atom' xmlns:openSearch='http://a9.com/-/spec/opensearchrss/1.0/'><id>tag:blogger.com,1999:blog-11010257</id><updated>2007-04-15T01:26:58.500-07:00</updated><title type='text'>Level++</title><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/'/><link rel='http://schemas.google.com/g/2005#feed' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author><generator version='7.00' uri='http://www.blogger.com'>Blogger</generator><openSearch:totalResults>8</openSearch:totalResults><openSearch:startIndex>1</openSearch:startIndex><openSearch:itemsPerPage>25</openSearch:itemsPerPage><entry><id>tag:blogger.com,1999:blog-11010257.post-111601043616034549</id><published>2005-05-13T11:53:00.000-07:00</published><updated>2005-05-13T11:54:35.743-07:00</updated><title type='text'>wxPython combinatorial explosion</title><content type='html'>My head's about to explode managing all of the various configurations of wxPython these days.&lt;br /&gt;&lt;br /&gt;Gamera has supported wxPython 2.4.x for a number of years (since it came out), on Linux and MS Windows. The Mac users (which actually make up the majority outside of the core team) were forced to run wxPython on Gtk on X11, because the native Aqua port wasn't stable or complete enough in the 2.4 series. The nice thing about that for me, however, is that it was only really 2 platforms to test, since Linux and OSX were essentially the same widget set. I don't care how "cross platform" wxPython claims to be, there are always hidden gotchas, especially with the high-level widgets like wxGrid.&lt;br /&gt;&lt;br /&gt;Now wxPython 2.6 is out and things are changing fast. Mature Gtk2 support on Linux means that Unicode is now an option there. The Aqua version is almost (but not quite yet) ready (more on that below). All that's great, but some Debian users have expressed concerns about dropping wxPython 2.4 support soon, since that's the only package available in the core repository (and even then only in unstable). So we've gone from happily testing on two platforms to nine. (wx[GTK|Win32|Mac]-[Unicode|ANSI]-[2.4|2.6]) The Unicode vs. ANSI bugs are certainly all my fault for making certain assumptions about the return values of widgets being strings and not unicode strings, but they're still there and need to be hunted down.&lt;br /&gt;&lt;br /&gt;Clearly it's time for some sort of automated GUI testing suite...  Suggestions are welcome.&lt;br /&gt;&lt;br /&gt;What's wrong with wxMac? The raster operations (or LogialFunctions in wxWidgets parlance) aren't there. Gamera draws highlighted regions of the image in its display by ANDing a mask and then ORing a colored shape. (An age-old technique for drawing "sprite" graphics.) The problem is, apparently, that Aqua simply doesn't support those operations natively, since it uses a Porter-Duff compositing model, and you can't directly access the pixels underneath in order to mask them out. I'd love to use the Porter-Duff model, as it easily allows for what I want to do, and I don't mind rewriting my code to support it. But AFAIK, wxPython doesn't provide an interface to it, and ideally it should be provided on the other platforms to make the code truly cross-platform. Alas, there's the rub of the wxWidget's approach of building cross-platform abstractions on top of the native APIs: if a particular paradigm isn't supported, it can be a lot of work to make it work everywhere. Hopefully they'll move one or the other way soon...</content><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/2005/05/wxpython-combinatorial-explosion.html' title='wxPython combinatorial explosion'/><link rel='replies' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/111601043616034549/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default/111601043616034549'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/11010257/posts/default/111601043616034549'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-11010257.post-111566161893019631</id><published>2005-05-09T08:27:00.000-07:00</published><updated>2005-05-13T08:41:52.876-07:00</updated><title type='text'>gcc __deprecation__ attributes</title><content type='html'>Long time no post.  I've been busy putting together a 3.0 release of &lt;a href="http://gamera.sf.net/"&gt;Gamera&lt;/a&gt;&lt;br /&gt;&lt;br /&gt;The primary reason for a major version bump is to deprecate some functions that have long since bothered me: Many of Gamera's functions take arguments of the form (y, x). Not only is this self-inconsistent within Gamera, but it's against the long-established industry standard. I won't really get into how we got into that mess.&lt;br /&gt;&lt;br /&gt;Unfortunately, you can't just deprecate "function(y, x)" and add "function(x, y)", because the compiler/interpreter can't tell the difference. Leaping from one to the other overnight would aggravate end users, and undoubtedly there'd be some lingering unconverted calls that would come back to haunt you. Adding new function names (such as "function_xy") might have worked, but the namespace is already really large and that would just kill autocompletion.&lt;br /&gt;&lt;br /&gt;So the solution I ended upon was to use function overloading by type. "function(y, x)", and any version taking two numbers is deprecated, and "function(Point(x, y))" was added as an alternative. On the Python side, you can even go one step further and accept a two-element sequence everywhere a Point is required and "function((x, y))" works.  Sure, it's a bit more typing, but on the other hand:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;   &lt;li&gt;It's a much more graceful way to keep legacy code working (albeit with warnings)&lt;/li&gt;   &lt;li&gt;You're more likely to catch places where you forgot to invert the coordinate pair&lt;br /&gt; &lt;/li&gt;   &lt;li&gt;It encourages treating the logical coordinate pairs as a logical unit, which has a lot of advantages in terms of passing them around and manipulating them etc.&lt;/li&gt; &lt;/ul&gt; &lt;br /&gt;&lt;br /&gt;On the Python side, these changes were pretty straightforward, so I won't go into detail.  Basically. I wrote some decorators to help "fake out" the function overloading, since function overloading is not a "built-in" feature of Python.  I use the warn module to raise DeprecationWarnings at runtime when a deprecated call is made.&lt;br /&gt;&lt;br /&gt;Now, onto the subject of the title: gcc has a nice little feature where you can set a deprecation attribute on a function or value and every time that function is called or the value is accessed, a warning is emitted by the compiler.  Since this technique only works on gcc 3.1 or later, you probably want to put this in a macro that expands to nothing if the compiler doesn't support it.  This is exactly the technique used in glib.&lt;br /&gt;&lt;br /&gt; &lt;pre&gt;&lt;br /&gt;#&lt;span class="builtin"&gt;if&lt;/span&gt; (__GNUC__ &amp;gt; 3 || (__GNUC__ == 3 &amp;amp;&amp;amp; __GNUC_MINOR__ &amp;gt;= 1))&lt;br /&gt;#&lt;span class="builtin"&gt;define&lt;/span&gt; &lt;span class="variable-name"&gt;GAMERA_CPP_DEPRECATED&lt;/span&gt;  __attribute__((__deprecated__))&lt;br /&gt;#&lt;span class="builtin"&gt;else&lt;/span&gt;&lt;br /&gt;#&lt;span class="builtin"&gt;define&lt;/span&gt; &lt;span class="variable-name"&gt;GAMERA_CPP_DEPRECATED&lt;/span&gt;&lt;br /&gt;#&lt;span class="builtin"&gt;endif&lt;/span&gt; &lt;span class="comment"&gt;/* __GNUC__ */&lt;/span&gt;&lt;br /&gt;&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;br /&gt;Then you can write:&lt;br /&gt;&lt;br /&gt;    &lt;pre&gt;&lt;br /&gt;&lt;span class="comment"&gt;/*&lt;br /&gt;  ImageView&amp;lt;T&amp;gt;::get(size_t row, size_t col) is deprecated.&lt;br /&gt;  &lt;br /&gt;  Reason: (x, y) coordinate consistency.&lt;br /&gt;  &lt;br /&gt;  Use ImageView&amp;lt;T&amp;gt;::get(Point(col, row)) instead.&lt;br /&gt;*/&lt;/span&gt;&lt;br /&gt;&lt;span class="type"&gt;GAMERA_CPP_DEPRECATED&lt;/span&gt;&lt;br /&gt;&lt;span class="type"&gt;value_type&lt;/span&gt; &lt;span class="function-name"&gt;get&lt;/span&gt;(&lt;span class="type"&gt;size_t&lt;/span&gt; &lt;span class="variable-name"&gt;row&lt;/span&gt;, &lt;span class="type"&gt;size_t&lt;/span&gt; &lt;span class="variable-name"&gt;col&lt;/span&gt;) &lt;span class="keyword"&gt;const&lt;/span&gt; {&lt;br /&gt;  &lt;span class="keyword"&gt;return&lt;/span&gt; m_accessor(m_const_begin + (row * m_image_data-&amp;gt;stride()) + col);&lt;br /&gt;}&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;br /&gt;When you compile code (in test.cpp) that calls this function (in test.hpp) a warning is emitted:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;  test.cpp:10: warning `get' is deprecated (declared at test.hpp:0)&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;br /&gt;That's all fine and good, but this is C++, not C, so that statement is not entirely true.  I've deprecated get(int, int), and replaced it with an overloaded version, get(Point).  gcc doesn't  display the entire function signature in the warning.  If there is a way to convince it to do that, please let me know.&lt;br /&gt;&lt;br /&gt;My solution to this was to write a filter for these warnings that would replace them with the comment in the source code directly above the deprecated declaration.  So then, the feedback becomes:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;  ImageView&amp;lt;T&amp;gt;::get(size_t row, size_t col) is deprecated.&lt;br /&gt;  &lt;br /&gt;  Reason: (x, y) coordinate consistency.&lt;br /&gt;  &lt;br /&gt;  Use ImageView&amp;lt;T&amp;gt;::get(Point(col, row)) instead.&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;br /&gt;which is a whole lot more helpful -- though it requires some care to keep the comments in order.&lt;br /&gt;&lt;br /&gt;Great, so 99 deprecated functions later, I'm all done, right?  Well, no.  On gcc 3.4 (which is on my primary development machine), you can put function attributes on C++ constructors right before the declaration, just the same as member functions and free functions.  However, when I pushed the code out to OS-X, and MS-Windows, both having gcc 3.3, everything mysteriously broke.  It seems that those earlier gcc versions, attributes need to go *after* the class constructors, but before just about everthing else.  This unfortunately means you also can't define the constructor inline in the class, which is a common thing to do in heavily-templatized C++ code.  Not impassable, but a minor pain, which certainly explains why the gcc folk fixed it.</content><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/2005/05/gcc-deprecation-attributes.html' title='gcc __deprecation__ attributes'/><link rel='replies' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/111566161893019631/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default/111566161893019631'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/11010257/posts/default/111566161893019631'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-11010257.post-110977144846812140</id><published>2005-03-02T05:48:00.000-08:00</published><updated>2005-03-02T05:50:48.473-08:00</updated><title type='text'>Inverse wrapping</title><content type='html'>Had a double-take yesterday when for various good reasons I found myself writing a C++ wrapper around a Python class.  The code is not at all hard or interesting, but it just felt so backward to how I've worked up to now.  Feels like a milestone of some sort.&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; &lt;pre&gt;&lt;br /&gt;&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="type"&gt;ProgressBar&lt;/span&gt; {&lt;br /&gt;&lt;span class="constant"&gt;public&lt;/span&gt;:&lt;br /&gt;  &lt;span class="keyword"&gt;inline&lt;/span&gt; ProgressBar(&lt;span class="type"&gt;char&lt;/span&gt;* &lt;span class="variable-name"&gt;message&lt;/span&gt;) {&lt;br /&gt;    PyObject* dict = get_module_dict(&lt;span class="string"&gt;"gamera.util"&lt;/span&gt;); &lt;br /&gt;    PyObject* progress_factory = PyDict_GetItemString(dict, &lt;span class="string"&gt;"ProgressFactory"&lt;/span&gt;);&lt;br /&gt;    m_progress_bar = PyObject_CallFunction(progress_factory, &lt;span class="string"&gt;"s"&lt;/span&gt;, message);&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;  &lt;span class="keyword"&gt;inline&lt;/span&gt; ProgressBar() : m_progress_bar(NULL) {}&lt;br /&gt;&lt;br /&gt;  &lt;span class="keyword"&gt;inline&lt;/span&gt; ProgressBar(&lt;span class="keyword"&gt;const&lt;/span&gt; ProgressBar&amp;amp; other) {&lt;br /&gt;    m_progress_bar = other.m_progress_bar;&lt;br /&gt;    &lt;span class="keyword"&gt;if&lt;/span&gt; (m_progress_bar)&lt;br /&gt;      Py_INCREF(m_progress_bar);&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;  &lt;span class="keyword"&gt;inline&lt;/span&gt; ~ProgressBar() {&lt;br /&gt;    &lt;span class="keyword"&gt;if&lt;/span&gt; (m_progress_bar)&lt;br /&gt;      Py_DECREF(m_progress_bar);&lt;br /&gt;  }&lt;br /&gt;&lt;br /&gt;  &lt;span class="keyword"&gt;inline&lt;/span&gt; &lt;span class="type"&gt;void&lt;/span&gt; &lt;span class="function-name"&gt;add_length&lt;/span&gt;(&lt;span class="type"&gt;int&lt;/span&gt; &lt;span class="variable-name"&gt;l&lt;/span&gt;) {&lt;br /&gt;    &lt;span class="keyword"&gt;if&lt;/span&gt; (m_progress_bar)&lt;br /&gt;      PyObject_CallMethod(m_progress_bar, &lt;span class="string"&gt;"add_length"&lt;/span&gt;, &lt;span class="string"&gt;"i"&lt;/span&gt;, l);&lt;br /&gt;  }&lt;br /&gt; &lt;br /&gt;  ...&lt;br /&gt;&lt;br /&gt;&lt;span class="constant"&gt;protected&lt;/span&gt;:&lt;br /&gt;  PyObject* m_progress_bar;&lt;br /&gt;};&lt;br /&gt;&lt;/pre&gt;</content><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/2005/03/inverse-wrapping.html' title='Inverse wrapping'/><link rel='replies' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/110977144846812140/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default/110977144846812140'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/11010257/posts/default/110977144846812140'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-11010257.post-110951148159436862</id><published>2005-02-27T05:38:00.000-08:00</published><updated>2005-02-27T05:42:40.393-08:00</updated><title type='text'></title><content type='html'>&lt;a href="http://photos1.blogger.com/img/295/3814/1024/IMG_0866.jpg"&gt;&lt;img style="border: 2px solid rgb(0, 0, 0); margin: 2px;" src="http://photos1.blogger.com/img/295/3814/400/IMG_0866.jpg" border="0" /&gt;&lt;/a&gt;&lt;br /&gt;Cristo and Jeanne-Claude's "The Gates"&lt;br /&gt;&lt;br /&gt;Maura and I drove up to New York yesterday to check out "The Gates".  Less impressed than I expected to be, but still fun to say I saw it.</content><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/2005/02/cristo-and-jeanne-claudes-gates-maura.html' title=''/><link rel='replies' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/110951148159436862/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default/110951148159436862'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/11010257/posts/default/110951148159436862'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-11010257.post-110926809939850310</id><published>2005-02-24T09:50:00.000-08:00</published><updated>2005-02-24T10:01:39.400-08:00</updated><title type='text'>Gamera: Python-based framework for document image analysis, reported in DigiCULT</title><content type='html'>&lt;a href="http://www.digicult.info/"&gt;DigiCULT&lt;/a&gt;, a European journal about technologies affecting the cultural heritage sector, has a report on Open Source Software in their latest &lt;a href="http://www.digicult.info/downloads/TWR3-highres.pdf"&gt;Technical Watch Report&lt;/a&gt;, including a case study on a project I've worked on since 2001, &lt;a href="http://dkc.jhu.edu/gamera/"&gt;Gamera&lt;/a&gt; (pages 47-51).  Even if you're not interested in cultural heritage materials or document image analysis, the report has some interesting things to say about moving open source into non-technical arenas.</content><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/2005/02/gamera-python-based-framework-for.html' title='Gamera: Python-based framework for document image analysis, reported in DigiCULT'/><link rel='replies' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/110926809939850310/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default/110926809939850310'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/11010257/posts/default/110926809939850310'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-11010257.post-110916814763961244</id><published>2005-02-23T06:11:00.000-08:00</published><updated>2005-02-23T06:15:47.640-08:00</updated><title type='text'>Thomas Luis da Victoria Collection</title><content type='html'>Christoph Dalitz just pointed me to this extensive collection of music by &lt;a href="http://www.upv.es/coro/victoria/partituras.html"&gt;Thomas Luis da Victoria&lt;/a&gt; at the Universidad Politecnica de Valencia.&lt;br /&gt;&lt;br /&gt;Made me miss my days in the Victoria Scholars (named for Thomas Luis) in Toronto.  Their website seems to be dead.  I hope the choir is still around.  They were really top notch.</content><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/2005/02/thomas-luis-da-victoria-collection.html' title='Thomas Luis da Victoria Collection'/><link rel='replies' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/110916814763961244/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default/110916814763961244'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/11010257/posts/default/110916814763961244'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-11010257.post-110910690633431003</id><published>2005-02-22T13:13:00.000-08:00</published><updated>2005-02-22T13:15:06.336-08:00</updated><title type='text'>Google Maps Hacks</title><content type='html'>I probably don't have to tell you that Google Maps is really slick, but check out this page that adds all kinds of &lt;a href="http://libgmail.sourceforge.net/googlemaps.html"&gt;extended functionality&lt;/a&gt;.</content><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/2005/02/google-maps-hacks.html' title='Google Maps Hacks'/><link rel='replies' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/110910690633431003/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default/110910690633431003'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/11010257/posts/default/110910690633431003'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author></entry><entry><id>tag:blogger.com,1999:blog-11010257.post-110909765595325660</id><published>2005-02-22T10:12:00.000-08:00</published><updated>2005-02-23T06:58:08.206-08:00</updated><title type='text'>Durus + ElementTree = XML Object Database or Frankenstein's Monster?</title><content type='html'>I had one of those wacky ideas where I can't necessarily think of an immediate application, but is easy enough to try out.&lt;br /&gt;&lt;br /&gt;I just discovered &lt;a href="http://www.mems-exchange.org/software/durus/"&gt;Durus&lt;/a&gt;, which is a networkable, transactional object store for Python. Seems cool, even despite the admitted limitations on scalability, but could easily create Python lock-in if not careful. What if you're concerned about moving those objects to another system in another language down the road? Or what if you already have a large body of data that you want to access? Sounds like a reasonable use of XML to me. If nothing else, XML's more limited structure would prevent one from doing anything too Python-specific.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;9 lines of magic:&lt;/b&gt;  Grabbing my favorite Pythonic XML-tool, &lt;a href="http://effbot.org/zone/element-index.htm"&gt;ElementTree&lt;/a&gt;, I was able to combine it with Durus in only 9 lines of Python:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;&lt;span class="keyword"&gt;from&lt;/span&gt; durus.persistent &lt;span class="keyword"&gt;import&lt;/span&gt; Persistent&lt;br /&gt;&lt;span class="keyword"&gt;from&lt;/span&gt; durus.persistent_list &lt;span class="keyword"&gt;import&lt;/span&gt; PersistentList&lt;br /&gt;&lt;span class="keyword"&gt;from&lt;/span&gt; elementtree &lt;span class="keyword"&gt;import&lt;/span&gt; ElementTree&lt;br /&gt;&lt;br /&gt;&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="type"&gt;PElementTree&lt;/span&gt;(ElementTree.ElementTree, Persistent):&lt;br /&gt; &lt;span class="keyword"&gt;pass&lt;/span&gt;&lt;br /&gt;ElementTree.ElementTree = PElementTree&lt;br /&gt;&lt;br /&gt;&lt;span class="keyword"&gt;class&lt;/span&gt; &lt;span class="type"&gt;PElementInterface&lt;/span&gt;(ElementTree._ElementInterface, Persistent):&lt;br /&gt; &lt;span class="keyword"&gt;pass&lt;/span&gt;&lt;br /&gt;ElementTree._ElementInterface = PElementInterface&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;br /&gt;&lt;i&gt;(It would be great to support cElementTree as well, but getting its extension types to pickle, a requirement for use in Durus, is non-trivial, at least relative to the above, which is the very definition of trivial. I might look into cElementTree mods in a future post.)&lt;/i&gt;&lt;br /&gt;&lt;br /&gt;Then you can just add ElementTrees to the Durus root object:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;tree = et_module.parse(xml_source)&lt;br /&gt;connection = Connection(ClientStorage())&lt;br /&gt;connection.get_root()[&lt;span class="string"&gt;"xml"&lt;/span&gt;] = tree&lt;br /&gt;connection.commit()&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;br /&gt;Reading and modifying the XML data is as easy as the ElementTree API.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;What's the point of such a beast?&lt;/b&gt; You can have multiple clients accessing and modifying the same XML document (including basic transaction support). Without Durus (or similar object database approach), one would have to lock the XML files and then parse and dump the XML with each transaction. Backing up or transferring the data to nice clean XML is trivial -- you don't have to write an object -&gt; XML mapping because &lt;i&gt;the object is the XML&lt;/i&gt;. Of course, you lose some of the point of using a persistent object database by limiting yourself in this way. Lastly, this beast will have the same limitations on scalability as Durus, but that may not be a problem in all applications.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;How does this thing perform?&lt;/b&gt;  I devised some silly benchmarks (all of which use Jon Bosak's &lt;a href="http://www.ibiblio.org/bosak/xml/eg/religion.2.00.xml.zip"&gt;Old Testament in XML&lt;/a&gt;) trying to cover a range of use cases. If you know of other good tests, please suggest them to me and I'll try to include them here.&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;br /&gt;&lt;li&gt;begat: Uche Ogbuji's &lt;a href="http://www.oreillynet.com/pub/wlg/6291"&gt;"Old Testament"&lt;/a&gt; test: Finds all verses in the Old Testament containing the word "begat".&lt;/li&gt;&lt;br /&gt;&lt;li&gt;book_title: Find all the book titles in the old testament.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;book_title_remove: Remove all of the title elements.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;book_title_remove_text: Remove the text from all of the title elements, but leave the elements themselves intact.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;upper_case: Convert all of the verses to upper case.&lt;/li&gt;&lt;br /&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;The code for these benchmarks is:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function-name"&gt;begat_benchmark&lt;/span&gt;(tree):&lt;br /&gt; &lt;span class="keyword"&gt;for&lt;/span&gt; v &lt;span class="keyword"&gt;in&lt;/span&gt; tree.findall(&lt;span class="string"&gt;"./bookcoll/book/chapter/v"&lt;/span&gt;):&lt;br /&gt;    &lt;span class="keyword"&gt;if&lt;/span&gt; v.text.find(&lt;span class="string"&gt;"begat"&lt;/span&gt;) &amp;gt;= 0:&lt;br /&gt;       &lt;span class="keyword"&gt;print&lt;/span&gt; v.text&lt;br /&gt;begat_benchmark.mutates = False&lt;br /&gt;&lt;br /&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function-name"&gt;book_title_benchmark&lt;/span&gt;(tree):&lt;br /&gt; &lt;span class="keyword"&gt;for&lt;/span&gt; title &lt;span class="keyword"&gt;in&lt;/span&gt; tree.findall(&lt;span class="string"&gt;"./bookcoll/book/bktshort"&lt;/span&gt;):&lt;br /&gt;    &lt;span class="keyword"&gt;print&lt;/span&gt; title.text&lt;br /&gt;book_title_benchmark.mutates = False&lt;br /&gt;&lt;br /&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function-name"&gt;book_title_remove_benchmark&lt;/span&gt;(tree):&lt;br /&gt; &lt;span class="keyword"&gt;for&lt;/span&gt; book &lt;span class="keyword"&gt;in&lt;/span&gt; tree.findall(&lt;span class="string"&gt;"./bookcoll/book"&lt;/span&gt;):&lt;br /&gt;    book.remove(book.find(&lt;span class="string"&gt;"./bktshort"&lt;/span&gt;))&lt;br /&gt;book_title_remove_benchmark.mutates = True&lt;br /&gt;&lt;br /&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function-name"&gt;book_title_remove_text_benchmark&lt;/span&gt;(tree):&lt;br /&gt; &lt;span class="keyword"&gt;for&lt;/span&gt; book &lt;span class="keyword"&gt;in&lt;/span&gt; tree.findall(&lt;span class="string"&gt;"./bookcoll/book"&lt;/span&gt;):&lt;br /&gt;    book.find(&lt;span class="string"&gt;"./bktshort"&lt;/span&gt;).text = &lt;span class="string"&gt;""&lt;/span&gt;&lt;br /&gt;book_title_remove_text_benchmark.mutates = True&lt;br /&gt;&lt;br /&gt;&lt;span class="keyword"&gt;def&lt;/span&gt; &lt;span class="function-name"&gt;upper_case_benchmark&lt;/span&gt;(tree):&lt;br /&gt; &lt;span class="keyword"&gt;for&lt;/span&gt; v &lt;span class="keyword"&gt;in&lt;/span&gt; tree.findall(&lt;span class="string"&gt;"./bookcoll/book/chapter/v"&lt;/span&gt;):&lt;br /&gt;    v.text = v.text.upper()&lt;br /&gt;upper_case_benchmark.mutates = True&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;br /&gt;Each of these benchmarks was run in four different environments:&lt;br /&gt;&lt;br /&gt;&lt;ul&gt;&lt;br /&gt;&lt;li&gt;ElementTree: Uses Python ElementTree to save/load XML to disk. When the benchmark involves changing the XML, the XML file is locked for the entire operation.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;cElementTree: Same as above, but uses C ElementTree&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Durus/ElementTree: Stores the ElementTree with a Durus server. The time for connecting to the database and committing to the database is included in the runtime.&lt;/li&gt;&lt;br /&gt;&lt;li&gt;Durus/Document-level ElementTree: Stores the entire document as a single item in the Durus server. (The Elements themselves are not "persisted" as separate objects). The results show that there are some interesting tradeoffs between then approach and the one above.&lt;/li&gt;&lt;br /&gt;&lt;/ul&gt;&lt;br /&gt;&lt;br /&gt;All times were measured using wall-clock time so that the time spent in the Durus server would be included. The tests were run on a dual Xeon system with 1GB of RAM. Obviously running over a network would add some overhead, and I didn't test that.&lt;br /&gt;&lt;br /&gt;The results:&lt;br /&gt;&lt;br /&gt;&lt;pre&gt;&lt;br /&gt;begat:&lt;br /&gt;           parse/connect    benchmark        total&lt;br /&gt;ET           3.3172s          0.2096s          3.5268s&lt;br /&gt;cET          0.1031s          0.1720s          0.2751s&lt;br /&gt;Durus-ET     0.0022s          11.4826s         11.4848s&lt;br /&gt;Durus-Doc-ET 0.0025s          0.8641s          0.8666s&lt;br /&gt;&lt;br /&gt;book_title:&lt;br /&gt;           parse/connect    benchmark        total&lt;br /&gt;ET           3.3593s          0.0049s          3.3643s&lt;br /&gt;cET          0.0951s          0.0024s          0.0974s&lt;br /&gt;Durus-ET     0.0022s          1.8796s          1.8818s&lt;br /&gt;Durus-Doc-ET 0.0026s          0.6883s          0.6909s&lt;br /&gt;&lt;br /&gt;book_title_remove:&lt;br /&gt;           parse/connect    benchmark        write/commit     total&lt;br /&gt;ET           3.5531s          0.0015s          2.5252s          6.0799s&lt;br /&gt;cET          0.0957s          0.0010s          2.3441s          2.4408s&lt;br /&gt;Durus-ET     0.0022s          0.1090s          0.0004s          0.1115s&lt;br /&gt;Durus-Doc-ET 0.0022s          0.7283s          0.0006s          0.7311s&lt;br /&gt;&lt;br /&gt;book_title_remove_text:&lt;br /&gt;           parse/connect    benchmark        write/commit     total&lt;br /&gt;ET           3.5531s          0.0015s          2.5252s          6.0799s&lt;br /&gt;cET          0.0957s          0.0010s          2.3441s          2.4408s&lt;br /&gt;Durus-ET     0.0022s          0.1090s          0.0004s          0.1115s&lt;br /&gt;Durus-Doc-ET 0.0022s          0.7283s          0.0006s          0.7311s&lt;br /&gt;&lt;br /&gt;upper_case:&lt;br /&gt;           parse/connect    benchmark        write/commit     total&lt;br /&gt;ET           3.2904s          0.2834s          2.5160s          6.0898s&lt;br /&gt;cET          0.0946s          0.1691s          2.3705s          2.6342s&lt;br /&gt;Durus-ET     0.0022s          12.3476s         7.2875s          19.6373s&lt;br /&gt;Durus-Doc-ET 0.0025s          0.9293s          0.0007s          0.9325s&lt;br /&gt;&lt;/pre&gt;&lt;br /&gt;&lt;br /&gt;Interesting to note that the &lt;i&gt;aggregate times&lt;/i&gt; Durus at the document level outperforms Python ElementTree in every case. Note, however, that the overall size of the document is important here, as it will affect the parsing/writing times.&lt;br /&gt;&lt;br /&gt;When seeks and edits are relatively few, storing the XML in Durus at the element level can be a real win. For grand sweeping changes over the whole file (upper_case benchmark), this fine-grained approach gets really bogged down by the serialize/unserialize overhead.&lt;br /&gt;&lt;br /&gt;&lt;b&gt;Useful?&lt;/b&gt; If you need concurrent access and transactions, this could be an interesting way to work on XML files. Please leave comments below.</content><link rel='alternate' type='text/html' href='http://levelpp.blogspot.com/2005/02/durus-elementtree-xml-object-database.html' title='Durus + ElementTree = XML Object Database or Frankenstein&apos;s Monster?'/><link rel='replies' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/110909765595325660/comments/default' title='Post Comments'/><link rel='self' type='application/atom+xml' href='http://levelpp.blogspot.com/feeds/posts/default/110909765595325660'/><link rel='edit' type='application/atom+xml' href='http://www.blogger.com/feeds/11010257/posts/default/110909765595325660'/><author><name>Michael Droettboom</name><uri>http://www.blogger.com/profile/12388598921628250225</uri><email>noreply@blogger.com</email></author></entry></feed>