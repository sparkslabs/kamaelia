<?xml version="1.0" encoding="utf-8" ?>

<rss version="2.0"
     xmlns:content="http://purl.org/rss/1.0/modules/content/"
     xmlns:dc="http://purl.org/dc/elements/1.1/"
     xmlns:atom="http://www.w3.org/2005/Atom"
     >


<channel>
  <atom:link href="http://plope.com/python.rss" rel="self" type="application/rss+xml" />


  <title>Chris McDonough's Python Feed</title>
  <link>http://plope.com</link>
  <description>Chris McDonough's Python Feed</description>
  <pubDate>
      Thu, 29 May 2008 03:07:33 +0000
  </pubDate>

          
  <item>
    <title>Writing Bad Unit Tests</title>
    <link>http://plope.com/Members/chrism/bad_unit_tests</link>
    <pubDate>
        Thu, 29 May 2008 03:07:33 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/bad_unit_tests</guid>
    <description>We write bad unit tests sometimes.</description>
    <content:encoded><![CDATA[<p>Lots of times you'll see people write unit tests in the
form:
<pre>
   class TestMyObject(unittest.TestCase):

       def test_my_object_add(self):
           from my.package import MyObject
           framework = self._setupTheUnderlyingFramework()
           object = MyObject('myobject')
           framework.add(object)
           self.assertEqual(framework.objectIds(), ['myobject'])
</pre>
</p>
<p>There are two reasons the above test is
wrong:
<ul>
<li>It doesn't actually test your object.  It's testing the return
    value of your framework's "objectIds" method, and to some extent,
    the "add" method of the framework.  If it's a framework you didn't
    write, <em>you don't need to test the framework</em>.  And even if you
    <em>did</em> write the framework, you're not supposed to be testing it
    here, you're supposed to be testing your MyObject.  Unit tests are
    not supposed to be about testing how your object interacts with
    the framework you're using.  They're supposed to about testing the
    implementation of the objects you create.</li>
<li><em>Unit</em> tests (as opposed to functional or integration tests)
    should rely on <em>as little</em> as possible.  When you write code that
    requires an entire framework to be initialized before it can be
    tested, you've written improperly factored code.  If your objects
    can't be tested without using some actual framework
    implementation, you've already failed some unwritten fundamental
    factoring test (or at least the framework you're using has).  For
    the record, it doesn't matter if the framework itself has all its
    tests written in this way either, that doesn't make it ok.</li>

</ul>
</p>
<p>The reason I know these things is because I used to write tests just
like the one I show above.  For an example of my sheer incompetence, see the tests in
Zope's
<a href="http://svn.zope.org/Zope/trunk/lib/python/Products/Sessions/tests/">Products.Sessions.tests</a>.
The setUp of these tests actually create an <em>OFS.Application</em> object.
One of these tests actually <em>creates a ZODB storage</em> to test a simple
object.  I originally wrote/contributed to these somewhere around
2001, and I now know enough to be ashamed of myself.  I'm not going to
rewrite them (I'm not that ashamed of myself, and besides, I've
already helped write a <a href="http://agendaless.com/Members/tseaver/software/faster/">replacement
implementation</a>).
But the tests are horrid.  I just didn't know any better.</p>
<p>On the other hand, I wrote the <a href="http://svn.repoze.org/repoze.who/trunk/repoze/who/tests.py">tests for
repoze.who</a>
more recently.  While they're not the paragon of virtue, they are far
less stupid.  Each test tests only the implementation of the thing it
claims it's testing.  Even when an object relies on another object <em>in
the same module</em>, but doesn't "own" that object, we use dummy
implementations of things to ensure that we don't actually test more
(or less) than we intend to.</p>
<p>The correct way to write unit tests is to create "mock" or "dummy"
objects for each external object your implementation depends on.  For
example, if your object expects to take some complicated subobject in
its __init__ method and consults it thereafter when you call one of
its methods, instead of doing:
<pre>
  def test_something(self):
      from some.real.implementation import ComplicatedThing
      c = ComplicatedThing()
      from my.package import MyObject
      myob = MyObject(c)
      self.assertEqual(myob.methodThatConsultsComplicatedThing(), True)
</pre>
</p>
<p>You actually want do
do:
<pre>
  def test_something(self):
      c = DummyComplicatedThing()
      from my.package import MyObject
      myob = MyObject(c)
      self.assertEqual(myob.methodThatConsultsComplicatedThing(), True)

  class DummyComplicatedThing:
      def consult(self):
          return True
</pre>
</p>
<p>Note that now you really are only testing and depending on code that
you wrote yourself, and you're not depending on the <em>real</em> complicated
thing.  Why this this good?  The real complicated thing is probably
<em>complicated</em>.  For example, its consult method might look like this:
<pre>
  class ComplicatedThing:
      def consult(self):
          vector1 = self.frobozz.getFleebar()
          vector2 = getUtility(self, ICramItDown).getFuzbaz(self)
          return vector1 == vector2
</pre>
</p>
<p>If you actually use this implementation, you're going to need to deal
with the fact that it needs a frobnozz who's getFleebar method is
willing to return a particular value, and you'll need to figure out
how to make getUtility(self, ICramItDown) return something that has a
getFuzbaz method that is willing to return another particular value.
Then you'll need to make sure that the comparison of "vector1 ==
vector2" returns soemthing sensible for your test.  In short, it's
going to turn into a clusterfuck.  It is add-only-code-to-be.</p>
<p>It may <em>seem</em> like more work to set up the dummy objects instead of
relying on actual implementations, and often it is initially.  But
later on when you have hundreds or thousands of unit tests, they take
on the order of minutes (as opposed to seconds) to complete, and you
can't really figure out the tests when you come back to them later
because much of the noise in the tests goes towards wiggling wires to
set up real implementations in such a way that the tests will pass,
you'll be in a bright world of shit.  The only thing you'll be able to
do is reimplement the tests properly, and you might as well have done
that in the first place.</p>
<p>For reasons I mention above, I must note that ZopeTestCase and
PloneTestCase are <em>canonizations</em> of bad unit testing practice.  When
you need to set up the entirety of Zope and/or Plone to test the
implementation of a small bit of custom code, you've just fed yourself
and all others who need to deal with your code in the future a huge
helping of fail.  It takes <em>forever</em> to run these sorts of tests, and
you're never actually testing <em>just</em> your object implementations,
you're also testing and potentially dealing with hundreds upon
hundreds of other implementations, each of which is arbitrarily
complex.  Likewise if your unit tests rely on an actual database
connection, or an actual mailserver, etc.</p>
<p>All that said, this is a subtle, subtle thing.  Half the time, I'm
still not 100% confident that I'm "doing it the right way".  Some of
my tests still just plain suck.</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Transcoding Batches of Ogg Files to MP3</title>
    <link>http://plope.com/Members/chrism/xcoding_ogg_batches</link>
    <pubDate>
        Sun, 25 May 2008 04:15:28 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/xcoding_ogg_batches</guid>
    <description>Some Python code that helps transcode a batch of ogg files to mp3.</description>
    <content:encoded><![CDATA[<p>I have an Apple iPod.  I'm not sure why, because most of my music is ripped to Ogg Vorbis format, which the iPod doesn't play natively.  Since I've had the iPod, I've had Rockbox on it
in order to play all my music.  But the Rockbox UI is pretty rough, and I'd like to be able to just plug the thing into my Mac and have it sync with iTunes, which requires actual thought one way or another if it's not running the native iPod OS, and I really have enough thinking to do without thinking about this.  So I've decided for better or worse to transcode all my Ogg Vorbis music to MP3 and get rid of Rockbox in favor of running the iPod OS.   Yes, I am lame, but I don't care.  Here's the Python code I'm using to transcode my music directory into a (shadowed) directory that is Ogg-free.  It requires <a href="http://ekyo.nerim.net/software/pyogg/">PyOgg</a> as well as system-invocable "oggdec" and "lame" binaries.  It probably also has bugs because I haven't actually let it run all the way through my music (this will take a few days) :
<pre>
  """Usage: transcode &lt;oggdir&gt; &lt;outdir&gt;"""

  import errno
  import os
  import shutil
  import sys
  import tempfile

  def usage():
      print __doc__
      sys.exit(2)

  def normalize(dir):
      return os.path.abspath(os.path.normpath(os.path.expanduser(dir))) + os.sep

  def main(argv):
      try:
          infolder, outfolder = map(normalize, argv[1:])
      except TypeError:
          usage()
      transcoder = MP3Transcoder()
      transcoder.walk(infolder, outfolder)

  class MP3Transcoder:

      def do_ogg(self, name, inpath, outpath):
          from ogg.vorbisutils import getVorbisComments
          if os.path.exists(outpath):
              return
          tempdir = tempfile.mkdtemp()
          vendor, comments = getVorbisComments(inpath)
          comments = dict(comments)
          unknown = 'Unknown'
          if not comments.get('TITLE'):
              comments['TITLE'] = name
          if not comments.get('ARTIST'):
              comments['ARTIST'] = unknown
          if not comments.get('ALBUM'):
              comments['ALBUM'] = unknown
          if not comments.get('TRACKNUMBER'):
              comments['TRACKNUMBER'] = '0'
          if not comments.get('TRACK'):
              comments['TRACK'] = comments['TRACKNUMBER']
          if not comments.get('YEAR'):
              comments['YEAR'] = '1'
          comment = comments.get('COMMENT', '') + ' (retranscoded)'
          comments['COMMENT'] = comment.lstrip()
          try:
              tempwav = os.path.join(tempdir, '%s.wav' % name)
              os.system('oggdec -o "%s" "%s"' % (tempwav, inpath))
              tempmp3 = os.path.join(tempdir, '%s.mp3' % name)
              comments['infile'] = tempwav
              comments['outfile'] = tempmp3
              print comments
              cmd = ('lame '
                     '--preset 192 '
                     '--ignore-tag-errors '
                     '--tt "%(TITLE)s" '
                     '--ta "%(ARTIST)s" '
                     '--tl "%(ALBUM)s" '
                     '--ty "%(YEAR)s" '
                     '--tc "%(COMMENT)s" '
                     '--tn "%(TRACK)s" '
                     '-ms -h "%(infile)s" "%(outfile)s"' % comments)
              print cmd
              os.system(cmd)
              shutil.copyfile(tempmp3, outpath)
          finally:
              shutil.rmtree(tempdir)

      def do_mp3(self, name, inpath, outpath):
          if not os.path.exists(outpath):
              shutil.copyfile(inpath, outpath)

      do_m4a = do_mp3
      do_m4p = do_mp3
      do_flac = do_mp3

      def walk(self, inroot, outroot):
          for root, dirs, files in os.walk(inroot):
              print root, dirs, files
              for dir in dirs:
                  outpath = os.path.join(outroot, root[len(inroot):], dir)
                  try:
                      os.makedirs(outpath)
                  except OSError, why:
                      if why[0] != errno.EEXIST:
                          raise
              for file in files:
                  name, ext = os.path.splitext(file)
                  realext = ext[1:]
                  doer = getattr(self, 'do_%s' % realext, None)
                  if doer is not None:
                      inpath = os.path.join(root, file)
                      outname = name + '.mp3'
                      outpath = os.path.join(outroot, root[len(inroot):], outname)
                      doer(name, inpath, outpath)

  if __name__ == '__main__':
      main(sys.argv)
</pre>
</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Political Loyalties in Web Frameworks</title>
    <link>http://plope.com/Members/chrism/political_loyalties</link>
    <pubDate>
        Sun, 11 May 2008 22:29:19 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/political_loyalties</guid>
    <description>There are at least two distinct forms of web framework styles:
&quot;right-leaning&quot; and &quot;left-leaning&quot; (in the political sense). </description>
    <content:encoded><![CDATA[<p>The very most right-leaning web framework is PHP: it's so right-leaning it's not
really a framework.  Pylons is very much a "right-leaning" frameworks
(someone at PyCon referred to it as a "drawing of a hammer" in
contrast with the famed <a href="http://discuss.joelonsoftware.com/default.asp?joel.3.219431.12">hammer factory factory featured in a Joel on
Software blog
comment</a>
).  Zope is very much a "left-leaning" framework (it is certainly the
most left-leaning Python framework; I suspect Smalltalk frameworks
would be left-leaning but I've never used one so I don't know).
Django and TurboGears fall somewhere in between, though maybe they're
more right-leaning than left leaning.  I suspect Apple's various
frameworks are pretty left-leaning, but I'm not really an Apple
developer either.  UNIX is a right-leaning framework; Windows leans
more left.</p>
<p>"Right leaning" frameworks place more responsibility on developers,
end users and integrators.  Therefore, they are usually materially
simpler than left-leaning frameworks, which tend to assume a lot of
the responsibility that isn't provided by the right-leaning variety.
On the other hand, left leaning frameworks, because they provide a lot
of functionality are typically harder to understand and develop for
initially, because you need to understand a lot more before you begin
to write code but they tend to provide features that can prove useful
later in development and deployment that are ignored by right-leaning
ones.</p>
<p>This distinction has consequences on applications developed within
them.  In applications developed in "right-leaning" frameworks:
<ul>
<li>One instance created by an integrator or end user is assumed to
   serve up (mostly) a single instance of a single application
   (e.g. "<em>the</em> blog", "<em>the</em> tagging system").  If another
   application is required, or another instance of the same
   application is required for a separate audience, it's more likely
   that right-leaning framework integrators will create a separate
   build of the entire framework stack to run the new application or
   instance rather than attempt to integrate into an existing build
   than might be the case under a left-leaning framework.  Developers
   of applications under right-leaning frameworks are not culturally
   encouraged to make it possible to run two (slightly different)
   instances of the same application within a single process space.</li>
<li>The number of configuration knobs exposed by the application to end
   users and/or integrators is typically fewer in right-leaning
   frameworks than code developed under left-leaning frameworks;
   instead it's assumed that an integrator or end user will change
   code directly to get the behavior he needs.  For example,
   environment-specific settings tend to be stored in Python code
   within files belonging to "the application" along with the
   application code itself with only a conventional distinction
   between the two.</li>
<li>Because applications are more tightly focused, it makes builds less
   complicated than under a left-leaning framework.  Therefore, the
   developers of applications under a right-leaning framework don't
   place much stock in making instance builds repeatable in an
   automatic way.  This task is more often left to the end user.</li>
<li>It's usually easier for right-leaning framework authors to document
   their framework, as there's less of it.</li>

</ul>
</p>
<p>In applications developed in "left-leaning"
frameworks:
<ul>
<li>Application developers are expected to implement a great deal of
   functionality required to satisfy various aspects expected by the
   framework or the culture surrounding the framework.
<ul>
<li>Environment-specific settings are stored in configuration files
     or other instance-specific data structures that are separated
     very distinctly from the software that uses these settings.  It's
     almost never the case that configuration knobs are put into
     Python files that ship along with an application; it would be a
     dramatic cultural faux pas.</li>
<li>Left-leaning frameworks tend to attempt to provide more
     facilities that allow developers to inject pluggability and allow
     behavior to be overridden without an integrator or end user
     needing to fork their code.  Developers are expected to provide
     these plug points to integrators and end users.</li>
<li>One build of the framework is assumed to serve up more than one
     application (a blog application <em>and</em> a tagging application).
     It's not uncommon for a single framework build to contain many
     instances of a single application ("a blog for fred, a blog for
     sally", "a blog for brad", "a tagging system for customer a", "a
     tagging system for customer b", etc).  Cultural requirements
     dictate that developers make this possible, which adds to their
     work load.</li>

</ul>
</li>
<li>Because left-leaning frameworks tend to provide a lot of
   functionality, and because the first attempt at the functionality
   is almost always wrong, they tend to accrete multiple
   implementations of very similar things over time.  The old
   implementations aren't removed because applications developed
   previously rely on them.  This can provide a dizzying intiation for
   new developers (do I use "way A" or "way B?")</li>
<li>Because there's so much framework, left-leaning frameworks tend to
   be more sparsely documented in total, just because documentation
   tends to lag behind code.</li>

</ul>
</p>
<p>It's often far, far easier for people to start writing code using a
right-leaning framework than a left-leaning one simply because there's
a lot less to learn.  A poorly-documented right-leaning framework is
easier to develop in than even the best-documented left-leaning
framework.  If you're just starting out and you need to develop an
in-house application that won't be redistributed or reused, a
right-leaning framework is almost certainly a better choice: many of
the features of left-leaning frameworks are there to support
redistribution and reuse.</p>
<p>On the other hand, if the goals of a left-leaning framework line up
with your problem domain, despite a steep learning curve at the
beginning, it might be wise to use one rather than a right-leaning
framework.  For example, Zope is exceedingly good at providing
arbitrary-depth document hierarchies out of the box, whereas this
behavior tends to need to be created from scratch for each job in
right-leaning frameworks.  It's typically far easier to retrofit a
Zope application to go "one level deeper" than it is to retrofit an
application written in a right-leaning framework.</p>
<p>All that said, personally, I'd like to see Zope lean a little more
right.  Because it has so much history, it's pretty difficult to make
it do so.  Our shot at it has been in the form of
<a href="http://dist.repoze.org">Repoze</a> which attempts to make Zope do less by
pulling functionality <em>out</em> of Zope and into smaller distinct pieces.
These pieces should be more easily understood and used by people who
don't want to bite off an entire left-leaning framework.  They can
even be used by people who might otherwise be using right-leaning
frameworks.  <a href="http://grok.zope.org">Grok</a> leans more right than does
Zope, which is gret, but it's still more left-leaning than any of the
other existing Python web frameworks because it has historically had a
focus on general "approachability".  This drives its inventors to want
to solve very general problems by writing more framework software
rather than by placing particular bits of responsibility on end users.</p>
<p>I imagine a lot of the current right-leaning frameworks will evolve
more left-leaning tendencies as they become more ambitious.  Both
Django and TurboGears seem to be shaping up this way.  This path needs
to be treaded carefully, but I think both of these communities have
excellent leadership, which should take some of the risk out of "going
left".  In the meantime we'll go at it from the other side, trying to
pull bits out of Zope that should form a slightly more right-leaning
set of components.  The future looks very bright.  Viva la 4th
generation of Python web frameworks!</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Call for New Maintainer for External Editor</title>
    <link>http://plope.com/Members/chrism/call_for_new_external_editor_maintainer</link>
    <pubDate>
        Sun, 11 May 2008 02:06:17 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[externaleditor]]></category>
          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/call_for_new_external_editor_maintainer</guid>
    <description>External Editor is two pieces of software:  a client side browser &quot;plug in&quot; application that launches editing processes (Word, Excel, vim, emacs, whatever) and a server-side component for Zope that   allows developers to inject links into pages that will trigger the client side application when they're clicked.  It needs a new maintainer.</description>
    <content:encoded><![CDATA[<p>I have been maintaining the venerable <a href="http://www.plope.com/software/ExternalEditor/">External Editor</a> Zope product originally written by Casey Duncan for several years now.  Lately, however, I have not maintaining it very well.  I took over its maintenance because it was essential for it to get new features and continue operating due to customer requirements at the time, but those requirements have come and gone.  I didn't even make the last release (0.9.3), it was done by Sidnei DaSilva.  So I beg of someone:  please take its maintainership off my hands.  To do so, you'll likely need to do the following:</p>

<ul>
<li>Create a web presence for the product</li>
<li>Create a bug tracker for the product and import existing bugs from the <a href="http://www.plope.com/software/collector">Plope bugtracker</a></li>
<li>Commit to making bugfixes</li>
<li>Commit to making and distributing new releases</li>

</ul>
<p>Please let me (chrism@plope.com) know if you're willing to do this, and the honor will be mine to hand it over.</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Integrating the repoze.who WSGI Authentication Framework with TurboGears 2</title>
    <link>http://plope.com/Members/chrism/tg2_repozewho_1</link>
    <pubDate>
        Sun, 27 Apr 2008 19:14:46 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/tg2_repozewho_1</guid>
    <description>Integrating repoze.who (web-platform-agnostic WSGI middleware for performing authentication) with TurboGears 2.</description>
    <content:encoded><![CDATA[<p>In theory, I've been added to the Planet Python feed aggregator.
Rather than post something totally useless to test the theory, I'll
offer a link over to <a href="http://blog.repoze.org/tgrepozewho.html">an entry on
blog.repoze.org</a> about
how other folks have integrated TurboGears 2 with the
<a href="http://svn.repoze.org/repoze.who/trunk/">repoze.who</a> WSGI
authentication framework.  I'd ask for the Repoze feed to get
aggregated too, but we don't have tagging in place and we do a lot of
release announcements there that would probably just clog up the
aggregator.  Meh.</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Signs That Your Python Package is Not Usable By Others</title>
    <link>http://plope.com/Members/chrism/challenge_to_web_framework_implementors</link>
    <pubDate>
        Tue, 08 Apr 2008 16:10:03 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/challenge_to_web_framework_implementors</guid>
    <description>Here's a challenge to web framework implementors: start packaging and documenting things in a way all Python web programmers would be embarrassed to not understand.</description>
    <content:encoded><![CDATA[<p>Signs that your framework packages are not optimally consumable by the Python web development
community:
<ul>
<li>Your package has no API: the implementation is the API.</li>
<li>Your package is never released independently from some other set of packages.
      Variation:  you never think about making a big deal out of releasing just one of your packages, 
      but releasing all of them at once in lockstep with each other is a major event.</li>
<li>Usefulness of your package depends on someone subclassing one of your classes to do anything at all.</li>
<li>Installing your package properly requires that you use a build system that not everyone runs</li>
<li>Installing your package relies on more than five other packages as dependencies.</li>
<li>Your package is documented using a set of files in the package itself, but nowhere else (no website docs).
      Variation: your package is only documented within "rollup" documentation for an application or framework that
      uses it.</li>
<li>Your package is a plugin to a framework that you use, but it doesn't work outside the framework even though it solves a more general problem shared by other frameworks.</li>
<li>Your package solves problems using formalizations of concepts that they don't want to understand (adapters, interfaces).
     Use of your package requires that people understand the concepts.</li>
<li>Your package has been out for years but it's only used in your framework.</li>

</ul>
</p>
<p>Mea culpa.  Youa culpa too, I'm sure. ;-)</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Six Months of Repoze</title>
    <link>http://plope.com/Members/chrism/six_months_of_repoze</link>
    <pubDate>
        Sun, 23 Mar 2008 07:10:43 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/six_months_of_repoze</guid>
    <description>Six (long, fun) months of Repoze.</description>
    <content:encoded><![CDATA[<p>I just put up a <a href="http://blog.repoze.org/sixmonthsofrepoze.html">blog entry</a> on the Repoze blog entitled "six months of Repoze".  I only mention this here because the Repoze blog doesn't accept comments yet, and this blog does; it's likely you'll be annoyed by the double link from an aggregator, but posting here is easier than fixing the Repoze blog right now. ;-)</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Pycon 2008:  Best. Pycon. Ever.</title>
    <link>http://plope.com/Members/chrism/pycon08</link>
    <pubDate>
        Wed, 19 Mar 2008 16:26:30 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[supervisor]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/pycon08</guid>
    <description>I probably don't have enough time to do justice in describing it here, but I loved Pycon 2008.</description>
    <content:encoded><![CDATA[<p>Pycon 2008 is now over.  Here's what I did while I was there:</p>

<ul>
<li>I gave a <a href="http://www.plope.com/static/presentations/repoze-zope2-pycon-2008.pdf">talk about repoze.zope2</a> on
  Friday.  It was sparsely attended, at least in comparison.  I should have given a lightning talk, I think,
  as really I think we (Agendaless) just want people to understand that the effort is meant to make it possible
  for non-Zope people to use Zopey stuff, and the rest of the details are discoverable via our online stuff.
  I was slightly uncomfortable giving this talk.  I don't know why, I've given it about 9 times already, but
  c'est la vie.  It wasn't the worst presentation I've ever given, but it wasn't the best.</li>
<li><a href="http://mikenaberezny.com/">Mike Naberezny</a> and I gave a talk titled <a href="http://supervisord.org/wp-content/uploads/2008/03/supervisor-pycon2008.pdf">Supervisor as a Platform</a> .  Yes, everything
  devolves into a platform, even a program that starts and stops other programs. ;-)  But it's quite a nice
  platform, and the talk was well-attended and a number of people came up to me and said "wow, I didn't know
  anything did that" after the talk.  Barry Warsaw also indicated he'd like to ship the new version of Mailman with
  supervisor running its queue runner programs, leveraging some of supervisor's event sending/listenting
  capability to do special stuff.  You also might
  want to check out the new <a href="http://supervisord.org">supervisord.org</a> that Maintainable (Mike's company)
  put together.  Yummy.</li>
<li>On the sprint days, we held a "Web Frameworks WSGI-fication" sprint.  We settled on working on authentication
  for these days.  Whit Morriss, Chris Shenton, Bill Rivet, Lennart Regebro, and I worked on various plugins
  for <a href="http://svn.repoze.org/repoze.pam/trunk/">repoze.pam</a> .  I had a number of conversations with the TurboGears
  guys (who we ended up sprinting in the same room with, along with a good number of Pylons folks), and there
  may be some opportunity for TG2 to ship with repoze.pam for some authentication duties.  We'll need to work
  it out with some of the stakeholders in an existing project they've launched named "Authority".  Chris Shenton
  managed to create a repoze.pam RADIUS plugin; Whit Morriss created "metadata providers" for repoze.pam.  Bill
  Rivet managed to start using repoze.pam with Turbogears 2 "in anger".  Lennart started on a config file
  parser for repoze.pam.</li>
<li>I watched a good number of talks.  None stick out in my mind.</li>

</ul>
<p>Other notables: Ian's house party, the "Web Pad", dinner with a bunch of people at at Italian place, a low-key get-together in our hotel room, and a notable post-sprint celebration with Chris Shenton, Christian Theune, Reed O'Brien, and Whit Morriss where a number of unprintable catchprases were coined.</p>
<p>I really need to get this feed onto Planet Python.  Sigh.</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Vanquishing the Virtual Host Monster</title>
    <link>http://plope.com/Members/chrism/vhm_victory</link>
    <pubDate>
        Mon, 10 Mar 2008 04:06:27 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/vhm_victory</guid>
    <description>I am victorious.  I have vanquished the Virtual Host Monster.</description>
    <content:encoded><![CDATA[<p><a href="http://svn.repoze.org/repoze.zope2">repoze.zope2</a> was always meant to have a virtual hosting story separate than that of Zope 2's "Virtual Host Monster"..  Tres and I struggled with this mightily in the early days of Repoze development, and I thought we had it licked.  But alas, on Friday, I was in the <a href="irc://irc.freenode.net#repoze">#repoze</a> IRC channel, talking with David Durham.  He noticed that when he added lines to his Apache mod_wsgi Location configuration (as documented) like so, to enable virtual hosting:
<pre>
  SetEnv HTTP_X_VHM_HOST http://www.example.com
  SetEnv HTTP_X_VHM_ROOT /plone
</pre>
</p>
<p>Nothing happened.  So I went and looked at the code, and lo and behold it was BRIDGE OUT!  We just had never finished the virtual hosting portion of repoze.zope2.  Yikes, quite  embarrassing, as I thought it had already been done.  I had been documenting code that just didn't exist!</p>
<p>So today I went in and added it to repoze.zope2, and wound up releasing new versions of both repoze.zope2 (0.3.3) and repoze.vhm (0.5).  It took a while for me to get virtual hosting working (I have four pages of notes to prove it; it took that much just to document what VHM was doing), but now you can use those headers in your Apache (or whatever) config to "turn on" virtual hosting when using repoze.zope2 with the repoze.vhm "xheaders" middleware in your WSGI pipeline.  When running under this configuration, you can also now delete the virtual host monster from your Zope when using repoze.vhm if you need virtual hosting. </p>
<p>That's not very interesting, of course.  What <em>is</em> interesting (to me, anyway)
are these things:
<ul>
<li>The code to do virtual hosting in repoze.vhm and repoze.zope is about 140 lines of Python, all totaled.  This replaces roughly 1000 
      lines of Python in SiteAccess' VirtualHostMonster.  To be fair, some of this is UI code.  But we don't need no stinking UI when we have a
      config file.   On the other hand, why a VHM was ever configured via a persistent ZODB object is anybody's guess.   I also must say that
      what VHM does to set the virtual root path is downright perverse.  The repoze.vhm code is nowhere near as tricky.</li>
<li>The <a href="http://www.plope.com/Books/2_7Edition/VirtualHosting.stx">hideous syntax</a>  of URLs meant to be parsed by VirtualHostMonster turned out to
      be utterly unnecessary.  It was so inscrutable it spawned a <a href="http://betabug.ch/zope/witch">wizard</a> to help people configure it.  
      The repoze.vhm syntax uses HTTP headers to do the same job instead of encoding semantics in the URL, which makes it much nicer.</li>

</ul>
</p>
<p>So before where you used to need to put in your Apache configuration something like:
<pre>
  &lt;VirtualHost *:80&gt;
      ServerName www.example.com
      RewriteEngine On
      RewriteRule ^/(.*) http://127.0.0.1:8080/VirtualHostBase/http/www.example.com:80/plone/VirtualHostRoot/$1 [L,P]
 &lt;/VirtualHost&gt;
</pre>
</p>
<p>You can (if you run under repoze.zope2 and repoze.vhm, proxying through to a Paste server) now replace that with:
<pre>
  &lt;VirtualHost *:80&gt;
      ServerName www.example.com
      RewriteEngine On
      RewriteRule ^/(.*) http://127.0.0.1:8080/$1 [L,P]
      Header add X-Vhm-Host http://www.example.com/
      Header add X-Vhm-Root /plone
 &lt;/VirtualHost&gt;
</pre>
</p>
<p>Or if you're running repoze.zope2 directly under Apache:
<pre>
   &lt;Location /&gt;
      WSGIPassAuthorization On
      SetEnv HTTP_X_VHM_HOST http://www.example.com/
      SetEnv HTTP_X_VHM_ROOT /plone
    &lt;/Location&gt;
</pre>
</p>
<p>Damn, that felt good.</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Buildout Ghettoization</title>
    <link>http://plope.com/Members/chrism/buildout_ghettoization</link>
    <pubDate>
        Sun, 24 Feb 2008 17:42:50 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/buildout_ghettoization</guid>
    <description>zc.buildout's ghettoization effect on the Python package installation process.</description>
    <content:encoded><![CDATA[<p>Although I have resigned myself to supporting it, I'm still unhappy with <code>zc.buildout</code>. 
This is mostly because it tends to ghettoize the packages that are written to use
some of its core features.  The core features that tend towards ghettoization fall into
dependency info, testing info, and script generation.  Here's what I don't like.</p>
<h1>Dependency Information Balkanization</h1>
<p>  Critical dependency version information is kept outside of setup.py
  in <code>buildout.cfg</code>, making it more likely that a package won't work
  when 'easy_install'ed.  Example: roughly 90% of the Zope3-related
  packages and any packages that depend upon them were not
  'easy_install'able from PyPI for a few months due to two
  external dependency pins done in buildout.cfg files.  Installation
  via buildout worked, of course, and the packagers never noticed that
  the packages couldn't be 'easy_install'ed, even though the packages
  are all published to PyPI, and thus presumably 'easy_install'able.</p>
<h1>Testing Info Balkanization</h1>
<p>  Because the defacto test regime is via the zope testrunner invoked
  via <code>bin/test</code>, buildout-centric package developers are hostile to
  test invocation via <code>setup.py test</code>, although <code>setup.py test</code> has
  been adopted in the larger Python community as the expected way to
  run a single package's tests.  Example: another committer "fixed" a
  checkin of mine by removing stuff from the "tests_require" line of
  setup.py in a package housed on svn.zope.org.  This makes <code>setup.py test</code> not work
  in a fresh checkout.  <code>bin/test</code> after a buildout continues to work,
  so the packagers just never notice.</p>
<h1>Script Generation</h1>
<p>  Scripts of dependent packages aren't installed automatically by
  buildout, while easy_install does install them.  So the result of
  installing an egg by putting it in a buildout <code>eggs=</code> line is not
  equivalent to installing using <code>setup.py install</code>.  This means that
  packages which have post-setup routines (such as creating an
  instance) which expect dependent packages scripts to be installed
  won't work.  Example: the <code>repoze.plone</code> package depends on the
  <code>repoze.zope2</code> package.  The <code>repoze.plone</code> package is a meta-egg
  that names as its dependencies <code>repoze.zope2</code> and all Plone product
  and library eggs.  When <code>repoze.plone</code> is 'easy_install'ed, a script
  from its <code>repoze.zope2</code> dependency named <code>mkzope2instance</code> is put
  into the bin directory.  However, when it's named as an egg in a
  <code>buildout.cfg</code>, the script is not installed, making it impossible to
  create an instance.  This is fixable by adding a
  <code>zc.recipe.eggs:scripts</code> recipe and naming each egg I want to
  install scripts for in that recipe's section, so it's not
  intractable, it just violates the rule of least suprise.</p>
<p>  Scripts are generated to have long PYTHONPATHS because eggs go to
  locations that aren't already on the PYTHONPATH.  The environment
  generated by a buildout is roughly equivalent to a virtualenv, so I
  don't understand why we shouldn't just make a virtualenv, and have
  <code>zc.recipe.egg</code> put eggs in its site-packages, and manage a .pth
  file to activate and deactivate them as necessary.  Scripts wouldn't
  need to contain any PYTHONPATH info then.  This would be more in
  line with what <code>easy_install</code> already does, which would make it
  easier for people who haven't yet drank the buildout Kool-Aid to
  understand.</p>
<p>In any case, I'm, as usual, bitter but dealing. ;-)  One buildout for <code>repoze.plone</code>
is on the burner.</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Decsec Revisited</title>
    <link>http://plope.com/Members/chrism/decsec_revisited</link>
    <pubDate>
        Fri, 22 Feb 2008 06:23:54 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/decsec_revisited</guid>
    <description>An implementation of a frameworky piece of middleware which allows users to implement declarative security in their web applications.</description>
    <content:encoded><![CDATA[<p>I've been working on a declarative security module for WSGI
applications I've named
<a href="http://svn.repoze.org/repoze.decsec/trunk/">repoze.decsec</a> , loosely
modeled after the original thoughts about <a href="http://www.plope.org/Members/chrism/decsec_proposal">the topic</a> I wrote
up a few years ago.</p>
<p>No matter what you might think of Zope, one of the best things that it
has had since "day one" is a way to declaratively protect resources in
web applications.  Zope respects a combination of decorators within
code and assertions made through through the web interface (or
programmatically) to allow folks to make statements about which
portions of their web applications require what level of access to
invoke.  This access is very granular: essentially you protect a
method or an object with a permission, then users can decide which
"roles" have some number of permissions in some context.  When a user
makes a request to the web application, the operation is either
allowed or denied depending on the permission that protects the
resource he's attempting to access compared to his roles in the
context of the resource.</p>
<p>In 1999, this was heady stuff.  I had come from a Perl background,
where I was writing all of my security checking code in an
"imperative" way.  Each one of my functions would do a security check
and its own login redirection, etc.  It was a tragedy.  I started
using Zope mainly for this feature.</p>
<p>But for some Python web frameworks, good declarative security is still
not a built-in feature.  They either provide no way make declarative security
assertions, or their declarative security model is weak (e.g. in some
web frameworks you can only say via code that some method "requires
authentication" or is "anonymous allowed", as opposed to being able to
make more granular assertions).</p>
<p>Decsec is a mini-framework which users of WSGI-compatible web
frameworks can use to implement granular declarative security
checking.  Its main features are:</p>

<ul>
<li>Pluggable mechanisms (via dotted-name callables mostly) for:
<ul>
<li>determining the "remote user" for the current request (using a key
    in the WSGI environment).  This is a value which must be provided
    by an upstream component.</li>
<li>determining the "principals" related to a request.  A principal is
    a username, groupname, or rolename.  The remote user can be
    represented by "n" principals.</li>
<li>determining the "required permission" related to a request.  A
    permission is typically a string like "Read", "Write", or
    "Create".  Each WSGI request is assumed to be resolveable to one
    of these permissions.</li>
<li>determining an ACL related to a request.  An ACL (access control
    list) is an ordered list of ACEs (access control entries).  Each
    ACE is a triple of <code>action</code> (allow or deny), <code>principal</code> (a
    principal name), and <code>permission</code> (a permission name).</li>

</ul>
</li>
<li>Middleware which:
<ul>
<li>calls the plugin points to find the principals, ACL and required
    permission for a given WSGI request.</li>
<li>checks the ACL using the principals and required permission
    implied by the request.  If the ACL allows, the request is
    permitted to proceed to the "right hand" WSGI application.  If the
    ACL denies, decsec raises an exception which is meant to be caught
    upstream by authentication middleware (e.g. Authkit) and turned
    into an authentication challenge (or at least a notification of
    failure).</li>

</ul>
</li>

</ul>
<p>Decsec does not provide any UI, nor does it handle authentication
(that's presumed to be the job of an upstream component).  It also
relies on the policy of its plugpoints to determine how to retrieve
and manufacture permission names and principal names.  As a result,
it's quite general.  It's functional and tested, but not documented.
I may not do much more work on it until I need to write code in a
framework that doesn't have a good declarative security model.</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Unittest findTestCases</title>
    <link>http://plope.com/Members/chrism/unittest_hair</link>
    <pubDate>
        Tue, 19 Feb 2008 16:50:52 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/unittest_hair</guid>
    <description>A reminder to myself about what to put at the bottom of unit test files when the tests are to be found by a testrunner that looks at &quot;test_suite&quot; for the suite in each test module.</description>
    <content:encoded><![CDATA[<p>It's useful to use the <code>findTestCases</code> utility function to find all the test cases in the current
module, instead of makeSuite'ing each test case manually.  For example, instead of:
<pre>
  import unittest

  class TestProxyBase(unittest.TestCase):
      def _makeOne(self, id, resource):
          from Products.davproxy.resource import ProxyBase
          return ProxyBase(id, resource)

      def test_getId(self):
          p = self._makeOne('theid', None)
          self.assertEqual(p.getId(), 'theid')

      def test_getId_utf8(self):
          p = self._makeOne(u'dummytitle-\u03cb', None)
          self.assertEqual(p.getId().decode('utf-8'), u'dummytitle-\u03cb')

  def test_suite():
      return unittest.TestSuite((
          unittest.makeSuite(TestProxyBase),
          ))

  if __name__ == '__main__':
      unittest.main(defaultTest='test_suite')
</pre>
</p>
<p>I really want do do this, so I don't have to keep adding stuff to
"test_suite" when I add more test cases to the module:
<pre>
  import unittest

  class TestProxyBase(unittest.TestCase):
      def _makeOne(self, id, resource):
          from Products.davproxy.resource import ProxyBase
          return ProxyBase(id, resource)

      def test_getId(self):
          p = self._makeOne('theid', None)
          self.assertEqual(p.getId(), 'theid')

      def test_getId_utf8(self):
          p = self._makeOne(u'dummytitle-\u03cb', None)
          self.assertEqual(p.getId().decode('utf-8'), u'dummytitle-\u03cb')

  def test_suite():
      import sys
      return unittest.findTestCases(sys.modules[__name__])

  if __name__ == '__main__':
      unittest.main(defaultTest='test_suite')
</pre>
</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Safari 3 Fails to Send Basic Auth Credentials</title>
    <link>http://plope.com/Members/chrism/safari_3_discards_basic_auth</link>
    <pubDate>
        Sat, 16 Feb 2008 19:34:47 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/safari_3_discards_basic_auth</guid>
    <description>Safari 3 fails to send basic auth credentials every so often?</description>
    <content:encoded><![CDATA[<p>I always log in to my development Zope instance using basic auth (e.g. http://localhost:8080/manage).  But often the sites I work on have their own authentication credential checking routines (via cookies, usually) when I traverse into a subfolder (eg a CMF site).  Historically this has been OK, because the cookie challenges never make it to me while I'm logged in as a management user because my basic auth credentials are sent to the server on each request.  But Safari 3 actually either dumps its knowledge about basic auth credentials every so often, or just fails to send them to the server on subsequent requests (after say, 5 minutes of inactivity).  What happens to me after Safari fails to send the credentials along on subsequent requests to my development system is that the cookie login stuff kicks in as the challenge because I'm usually traversing to a part of the site where the challenge code is no longer something that asks for basic auth credentials.  And often I <em>can't</em> log in as the management user, because this challenge only checks user data in this part of the site.  This is minor pain in the ass, so I'm using Firefox more these days (it doesn't seem to have this behavior).  I was just wondering if anyone else had noticed this.  Safari 2 didn't do this.  I suppose this behavior is not a spec violation, but it does violate the rule of least surprise for dubious benefit ("security?")</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>Report from Plone Gathering in Seattle</title>
    <link>http://plope.com/Members/chrism/post_seattle</link>
    <pubDate>
        Thu, 14 Feb 2008 05:11:35 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/post_seattle</guid>
    <description>Report from the Seattle Plone Gathering, where your intrepid blogger recently gave a talk about Repoze.</description>
    <content:encoded><![CDATA[<p>Yesterday, I visited Seattle to give a talk about
<a href="http://repoze.org">Repoze</a> .  The talk brought a pretty good-sized
crowd, something like 25 people.  I was relieved that people actually
asked questions at the end, as if they might actually be interested in
the software.  I managed to dodge the hard ones.  The folks there were
particularly clueful.  For example, while "demonstrating"
<a href="http://www.openplans.org/projects/deliverance/project-home">Deliverance</a>
(of which I'm woefully clueless), someone asked me to explain the
"rules" file.  I had to ask "does anyone know XPath?"  Not my best
moment. ;-)</p>
<p>In any case, it was a lot of fun.  Thanks to Veda Williams and
Olympus.net, whom sponsored my presentation at the <a href="http://seattleplone.org">Seattle Plone
Gathering</a> .  Thanks also to Andrew Burkhalter
who mediated the talk logistics.  And thanks to everyone who showed up!</p>
]]></content:encoded>

  </item>

            
  <item>
    <title>We Dont Twinkle Much in Kentucky</title>
    <link>http://plope.com/Members/chrism/kentuckyans_dont_twinkle</link>
    <pubDate>
        Mon, 11 Feb 2008 02:17:02 +0000
    </pubDate>
    <dc:creator>chrism</dc:creator>

          <category><![CDATA[python]]></category>
          <category><![CDATA[tech]]></category>
          <category><![CDATA[zope]]></category>
        
    <guid isPermaLink="false">http://plope.com/Members/chrism/kentuckyans_dont_twinkle</guid>
    <description>Obligatory report from the Plone Strategic Planning Summit 2008 in Mountain View.</description>
    <content:encoded><![CDATA[<p>We had this thing at Google.  Heated toilet seats.  Catered food.  All
you can drink soda, etc.  Very decadent, I see now why Google has done
so well at hiring people.</p>
<p>Our facilitator, Jon Stahl, did a great job of driving the sessions.
He looked like he was about to pass out the last time I saw him about
an hour ago.  It must have been exhausting.</p>
<p>The PSPS itself was a series of organization and brainstorming
exercises designed to steer people towards a consensus about "what
needs to be done" in the future.  Jon had everybody move around and
put up notes on big pieces of white paper and run around with stickers
and mark issues they agreed with, and some other exercises.  Virtually
no one used computers the entire time (at least relative to the
audience, some folks hauled out laptops for brief periods to check
email and whatnot).</p>
<p>The first two days were about framing the issues.  The last day was
largely about attempting to define very specific tasks and to find
people willing to do them, or at least to drive other people to do
them ("champions").  I think maybe 20 or 30 tasks got created, and the
majority of them were claimed by someone.</p>
<p>The audience was relatively balanced, with probably 50% of the people
there being integrators (lots of consultants) or internal deployers,
and the other 50% being "Plone core" folks (also a good number of
consultants in that camp too), who are in charge of actually creating
the framework upon which new features might be based.</p>
<p>I think this was a useful exercise.  Although I personally enjoyed the
first two days of exercises, I probably would have been better off
just attending the last day, as I intended to "champion" the things
that I care about anyway and I could have just said "yes I'll do that"
on the last day and discussed it with folks afterwards.</p>
<p>We are now supposed to create some sort of proposal about creating a
zc.buildout that installs Repoze and Plone together.  Agendaless is
also on the hook to deliver a proposal for a stripped-down Plone theme
for use with Deliverance (or another transform engine).</p>
<p>I accidentally hit a nerve today when I suggested as an example of
stratifying the things that currently make up the amorphous "Plone
core" that we make Archetypes optional.  There was lots of strong
disagreement on that one from almost everyone (each task was "voted
on" by coloring in of dots on a range of "strongly agree" to "strongly
disagree").  I suspect, however, that many folks may have
misunderstood "make Archetypes optional" as "destroy Archetypes
altogether."  And perhaps there has been some talk about that in the
past that colored people's expectations about what the task actually
was.</p>
<p>There really wasn't enough time to clarify the intent at the summit in
person but I believe it'd be possible to preserve backwards
compatibility but allow for an Archetypes-less Plone deployment (which
is more or less what I'm after; I'd actually like more things than
Archetypes to be optional).  But I did get into some side
conversations with folks on the "framework team" which leads me to
believe that the idea of stratifying Plone isn't as stillborn as the
response to that proposal suggested.  As long as we're willing to
supply some of the elbow grease, I think it might be acceptable and
desirable to the folks to whom it would matter: integrators would
basically just not need to be aware of the existence of an
Archetypes-less Plone, and the core folks would just create
dependencies from "Plone the application" to "the Plone core" and
"Archetypes".</p>
<p>As always, it was a lot of fun to hang out with the folks that showed
up at the summit.  Tip: hide the beer when the Plone folks show up at
your offices.</p>
<p>Oh yeah, and I forgot to mention, it was <em>great</em> to see the winner of
the GHOP Plone project (who was 14).  He rocked.</p>
]]></content:encoded>

  </item>

    
</channel>

</rss>

