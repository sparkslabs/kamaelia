Index: Kamaelia/File/Reading.py
===================================================================
--- Kamaelia/File/Reading.py	(revision 3562)
+++ Kamaelia/File/Reading.py	(revision 5910)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 #
-# (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -277,7 +277,7 @@
 
 """
 
-
+import Axon
 from Axon.Component import component
 from Axon.Ipc import producerFinished, shutdownMicroprocess
 from Kamaelia.Util.RateFilter import ByteRate_RequestControl
@@ -478,7 +478,49 @@
                     }
         )
 
-__kamaelia_components__ = ( PromptedFileReader, )
+class SimpleReader(component):
+    def __init__(self, filename, mode="r", buffering=1, **argd):
+        super(SimpleReader, self).__init__(**argd)
+        self.filename = filename
+        self.mode = mode
+        self.buffering = buffering
+        self.fh = None
+    def main(self):
+        self.fh = open(self.filename, self.mode,self.buffering)
+        shutdown = False
+        sent_ok = False
+        for i in self.fh:
+            sent_ok = False
+            while not sent_ok:
+                yield 1
+                if self.shutdown():
+                    shutdown = True
+                    break
+                try:
+                    self.send(i, "outbox")
+                    sent_ok = True
+                except Axon.AxonExceptions.noSpaceInBox:
+                    self.pause() # wait for data to be taken from the outbox
+        self.fh.close()
+        if not shutdown:
+            self.send(producerFinished(), "signal")
+
+    def shutdown(self):
+        """\
+        Returns True if a shutdownMicroprocess message is received.
+
+        Also passes the message on out of the "signal" outbox.
+        """
+        while self.dataReady("control"):
+            msg = self.recv("control")
+            if isinstance(msg, shutdownMicroprocess):
+                self.send(msg, "signal")
+                return True
+        return False
+        
+
+
+__kamaelia_components__ = ( PromptedFileReader, SimpleReader )
 __kamaelia_prefabs__ = ( RateControlledFileReader, ReusableFileReader, RateControlledReusableFileReader, FixedRateControlledReusableFileReader, )
 
 if __name__ == "__main__":

Index: Kamaelia/File/ReadFileAdaptor.py
===================================================================
--- Kamaelia/File/ReadFileAdaptor.py	(revision 3562)
+++ Kamaelia/File/ReadFileAdaptor.py	(revision 5910)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python2.3
 #
-# (C) 2004 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2004 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -102,6 +102,10 @@
 from Axon.Ipc import producerFinished
 
 import time
+
+class EOF(Exception):
+    pass
+
 class ReadFileAdaptor(component):
    """\
    An instance of this class is a read file adaptor component. It's
@@ -198,7 +202,7 @@
       data = ""
       data = self.f.read(self.readsize)
       if not data:
-         raise "End of Data"
+         raise EOF("End of Data")
       return data
 
    def getDataReadline(self):
@@ -209,7 +213,7 @@
       Same reason for indirection as above."""
       data = self.f.readline()
       if not data:
-         raise "End of Data"
+         raise EOF("End of Data")
       return data
 
    def mainBody(self):

Index: Kamaelia/Internet/TCPClient.py
===================================================================
--- Kamaelia/Internet/TCPClient.py	(revision 3562)
+++ Kamaelia/Internet/TCPClient.py	(revision 5910)
@@ -4,7 +4,7 @@
 #        selector service that its services are no longer required.
 #        This needs resolving.
 #
-# (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -243,6 +243,7 @@
                raise x  # XXXX If X is not finality, an error message needs to get sent _somewhere_ else
                # The logical place to send the error is to the signal outbox
          except Exception, x:
+#            print "I ALSO AM CALLED"
             sock.close() ;  yield 4,x # XXXX If X is not finality, an error message needs to get sent _somewhere_ else
             raise x
       except Finality:
@@ -259,11 +260,25 @@
       self.send(producerFinished(self,self.howDied), "signal")
 #          self.send(e, "signal")
         # "TCPC: Exitting run client"
+   
+   def stop(self):
+       try:
+           self.sock.shutdown(2)
+           self.sock.close()
+       except:
+           pass # Well, we tried.
+       self.send(producerFinished(self,self.howDied), "signal")
+       if (self.sock is not None) and (self.CSA is not None):
+           self.send(removeReader(self.CSA, self.sock), "_selectorSignal")
+           self.send(removeWriter(self.CSA, self.sock), "_selectorSignal")
+           self.send(producerFinished(),"signal")
+       super(TCPClient, self).stop()
 
    def shutdown(self):
        while self.dataReady("control"):
            msg = self.recv("control")
            self.send(msg,"signal")
+#           print "woo?"
            if isinstance(msg, (producerFinished,shutdownMicroprocess)):
                return True
        return False

Index: Kamaelia/Visualisation/PhysicsGraph/TopologyViewer.py
===================================================================
--- Kamaelia/Visualisation/PhysicsGraph/TopologyViewer.py	(revision 3562)
+++ Kamaelia/Visualisation/PhysicsGraph/TopologyViewer.py	(revision 5910)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-# (C) 2004 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2004 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -548,6 +548,12 @@
                 elif cmd == ("DEL", "ALL") and len(msg) == 2:
                     self.removeParticle(*self.physics.particleDict.keys())
 
+                elif cmd == ("FREEZE", "ALL") and len(msg) == 2:
+                    self.freezeAll()
+
+                elif cmd == ("UNFREEZE", "ALL") and len(msg) == 2:
+                    self.freezeAll()
+
                 elif cmd == ("GET", "ALL") and len(msg) == 2:
                     topology = [("DEL","ALL")]
                     topology.extend(self.getTopology())
@@ -581,6 +587,14 @@
                 p.set_label(new_name)
                 return
 
+    def freezeAll(self):
+        for p in self.physics.particles:
+            p.freeze()
+    
+    def unFreezeAll(self):
+        for p in self.physics.particles:
+            p.unfreeze()
+
     def getParticleLabel(self, node_id):
         """\
         getParticleLabel(node_id) -> particle's name

Index: Kamaelia/Visualisation/PhysicsGraph/ParticleDragger.py
===================================================================
--- Kamaelia/Visualisation/PhysicsGraph/ParticleDragger.py	(revision 3562)
+++ Kamaelia/Visualisation/PhysicsGraph/ParticleDragger.py	(revision 5910)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-# (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -75,6 +75,11 @@
         
         # find particles under the mouse pos
         pos = int(pos[0] + self.app.left), int(pos[1] + self.app.top)
+        if pos[0]> self.app.screensize[0]: return False
+        if pos[1]> self.app.screensize[1]: return False
+        if pos[0]<0: return False
+        if pos[1]<0: return False
+
         inRange = self.app.physics.withinRadius( pos, self.app.biggestRadius )
         inRange = filter(lambda (p, rsquared) : p.radius*p.radius >= rsquared, inRange)

Index: Kamaelia/Visualisation/PhysicsGraph/TopologyViewerServer.py
===================================================================
--- Kamaelia/Visualisation/PhysicsGraph/TopologyViewerServer.py	(revision 3562)
+++ Kamaelia/Visualisation/PhysicsGraph/TopologyViewerServer.py	(revision 5910)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-# (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -91,9 +91,16 @@
 from Kamaelia.Visualisation.PhysicsGraph.chunks_to_lines import chunks_to_lines
 from Kamaelia.Visualisation.PhysicsGraph.lines_to_tokenlists import lines_to_tokenlists
 from Kamaelia.Visualisation.PhysicsGraph.TopologyViewer import TopologyViewer
-from Kamaelia.Internet.SingleServer import SingleServer
 from Kamaelia.Util.Console import ConsoleEchoer
+from Kamaelia.Chassis.ConnectedServer import SimpleServer
+from Kamaelia.Util.Backplane import *
 
+Backplane("NODEEVENTS").activate()
+
+
+def Users():
+    return PublishTo("NODEEVENTS")
+
 def TopologyViewerServer(serverPort = 1500, **dictArgs):
     """\
     TopologyViewerServer([noServer][,serverPort],**args) -> new TopologyViewerServer component.
@@ -107,7 +114,8 @@
     - serverPort  -- None, or port number to listen on (default=1500)
     - args        -- all remaining keyword arguments passed onto TopologyViewer
     """
-    return Pipeline( SingleServer(port=serverPort),
+    SimpleServer(protocol=Users, port=serverPort).activate()
+    return Pipeline( SubscribeTo("NODEEVENTS"),
                      chunks_to_lines(),
                      lines_to_tokenlists(),
                      TopologyViewer(**dictArgs),

Index: Kamaelia/Visualisation/PhysicsGraph/chunks_to_lines.py
===================================================================
--- Kamaelia/Visualisation/PhysicsGraph/chunks_to_lines.py	(revision 3562)
+++ Kamaelia/Visualisation/PhysicsGraph/chunks_to_lines.py	(revision 5910)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python
 
-# (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2006 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -85,7 +85,14 @@
          
          while self.dataReady("inbox"):
             chunk = self.recv("inbox")
-            chunk = chunk.replace("\r", "")
+            try:
+                chunk = chunk.replace("\r", "")
+            except:
+                print "BAD CHUNK, Arrrgggh", repr(chunk)
+                import time
+                time.sleep(3)
+                raise
+
             line = line + chunk
          
          pos = line.find("\n")

Index: Kamaelia/Chassis/TPipe.py
===================================================================
--- Kamaelia/Chassis/TPipe.py	(revision 0)
+++ Kamaelia/Chassis/TPipe.py	(revision 5910)
@@ -0,0 +1,194 @@
+#!/usr/bin/python
+#
+# Copyright (C) 2007 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+#
+"""\
+============
+What it does 
+============
+
+XXX TODO: Module level docs
+
+Much like unix "tee", copies data from inboxes to outboxes but also to a
+subcomponent. Copying to the subcomponent is conditional on the data, and
+also
+
+Example Usage
+-------------
+What this shows followed by double colon::
+    def func():
+        print "really really simple minimal code fragment"
+
+Indicate any runtime user input with a python prompt::
+    >>> func()
+    really really simple minimal code fragment
+
+Optional comment on any particularly important thing to note about the above 
+example.
+
+How does it work?
+-----------------
+
+Statements, written in the present tense, describing in more detail what the 
+component does.
+
+Explicitly refer to "named" inbox an "named" outbox to avoid ambiguity.
+
+Does the component terminate? What are the conditions?
+
+If the 'xxxx' argument is set to yyy during initialization, then something
+different happens.
+
+A subheading for a subtopic
+~~~~~~~~~~~~~~~~~~~~~~~~~~~
+
+Lists of important items might be needed, such as commands:
+    the item
+        A description of the item, what it is and what it does, and maybe 
+        consequences of that.
+
+    another item
+        A description of the item, what it is and what it does, and maybe 
+        consequences of that.
+
+You may also want bullet lists:
+
+
+- first item
+- second item
+
+Optional extra topics
+---------------------
+
+May be necessary to describe something separately, eg. a complex data structure
+the component expects to receive, or the GUI interface it provides.
+"""
+
+import Axon
+
+class TPipe(Axon.Component.component):
+    """\
+    TPipe([condition=<callback>][,action=<Component>],[,sink=<Bool>],[,source=<Bool>]) -> new TPipe component.
+
+    This component takes a single component as an argument. It runs this argument
+    and sets it up to be able to send data to it. (and optionally recieve
+    data from it) The subcomponent can obviously be any component, for example
+    another pipeline, graphline, threadedcomponent or backplane.
+
+    This component is designed to sit in a Pipeline, where there is interesting
+    data flowing through. It always forwards whatever messages it recieves on its
+    inboxes "inbox,control" to its outboxs "outbox,signal", *UNLESS* the flag
+    "demux" is set.
+
+    Additionally, it runs the condition provided against each piece of
+    data. If the condition returns True, then the data is forwarded to the
+    subcomponent, otherwise it isn't.
+
+    If the argument "mode" is "route", then any piece of data goes either to
+    the subcomponent inboxes or out the component's outboxes. If the argument
+    "mode" is "split", it can go to both. The default is "split".
+
+    Finally it takes two boolean arguments "sink" and "source. sink defaults
+    to true and means that we should send data to the subcomponent. source
+    defaults to false. If source is True however, any data coming out the
+    subcomponents outboxes "outbox, signal" is passed through to TPipes
+    outboxes "outbox, signal" (respectively).
+
+    Keyword arguments:
+
+    - condition -- Applied to data on inbox, forwards to subcomponent
+    - action -- The subcomponent to be activated and recieve a copy of data
+    - sink - If True (default) condition will be applied to data if true,
+      data forwarded to action
+    - source - If True (default=False), any data from action will go out
+      our outbox. In a pipeline this results in data injection.
+    - mode - "split" (default) or "route". "split" means the each piece of
+      data can go to both the component's outboxes and the subcomponent.
+      "route" means the data goes to one or the other.
+    """
+    Inboxes = {
+        "inbox" : "Messages we may wish to pass onto the sub component",
+        "control" : "Shutdown messages come here.",
+        "_inbox" : "Message the subcomponent sends us back",
+        "_control" : "The subcomponent may wish to send shutdown to us as well for some reason",
+    }
+    Outboxes = {
+        "outbox" : "We always pass on all messages we recieve",
+        "signal" : "We always send on shutdown messages",
+        "_outbox" : "Messages we send here go to the sub component",
+        "_signal" : "Shutdown messages sent here go to the sub component",
+    }
+    condition = None
+    action = None
+    sink = True
+    source = False
+    mode = "split"
+    def main(self):
+        if (self.mode != "split") and (self.mode != "route"): return
+        if not self.condition: self.condition = lambda x: True
+        if not self.action: return
+        self.addChildren(*( self.action, ))
+        self.link( (self, "_signal"), (self.action, "control") ) # Always want to be able to send a shutdown message
+        if self.sink:
+            self.link( (self, "_outbox"), (self.action, "inbox") )
+        if self.source:
+            self.link( (self.action, "outbox"), (self, "_inbox") )
+            self.link( (self.action, "signal"), (self, "_control") )
+
+        for child in self.children:
+            child.activate()
+        while not self.childrenDone():
+            while self.dataReady("inbox"):
+                d = self.recv("inbox")
+                if self.mode == "split":
+                    self.send(d, "outbox")
+
+                if self.sink and self.condition(d):
+                    self.send(d, "_outbox")
+                elif self.mode == "route":
+                    self.send(d, "outbox")
+
+                yield 1
+
+            while self.dataReady("_inbox"):
+                d = self.recv("_inbox")
+                if self.source:
+                    self.send(d, "outbox")
+                yield 1
+
+            while self.dataReady("control"):
+                d = self.recv("control")
+                self.send(d, "signal")
+                self.send(d, "_signal")
+                yield 1
+            self.pause()
+            yield 1
+
+    def childrenDone(self):
+        """Unplugs any children that have terminated, and returns true if there are no
+          running child components left (ie. their microproceses have finished)
+        """
+        for child in self.childComponents():
+            if child._isStopped():
+                self.removeChild(child)   # deregisters linkages for us
+
+        return 0==len(self.childComponents())
+

Index: Kamaelia/Audio/PyMedia/Input.py
===================================================================
--- Kamaelia/Audio/PyMedia/Input.py	(revision 3562)
+++ Kamaelia/Audio/PyMedia/Input.py	(revision 5910)
@@ -102,36 +101,50 @@
         self.format = format
         
     def main(self):
-        self.snd.start()
-        
-        format = {
-            'channels'    : self.channels,
-            'sample_rate' : self.sample_rate,
-            'format'      : self.format,
-        }
-        self.send(format, "format")
-        
-        shutdown=False
-        while self.anyReady() or not shutdown:
-            while self.dataReady("control"):
-                msg=self.recv("control")
-                if isinstance(msg, (producerFinished,shutdownMicroprocess)):
-                    shutdown=True
-                self.send(msg,"signal")
-                
-            raw = self.snd.getData()
-            if raw and len(raw):
-                data = str(raw)
-                while data:
-                    try:
-                        self.send(data,"outbox")
-                        data=None
-                    except noSpaceInBox:
-                        self.pause()
-            else:
-                self.pause(0.01)
-                    
-        self.snd.stop()
+        # Pymedia is not the most reliabe piece of code in the world
+        # As a result I'm wrapping this entire code with a try..except
+        # designed to catch any & all pymedia errors regarding input.
+        #
+        # This allows the component to (relatively) gracefully shutdown
+        # whilst still bleat about how Pymedia is bust...
+        #
+        try:
+            self.snd.start()
+            
+            format = {
+                'channels'    : self.channels,
+                'sample_rate' : self.sample_rate,
+                'format'      : self.format,
+            }
+            self.send(format, "format")
+            
+            shutdown=False
+            while self.anyReady() or not shutdown:
+                while self.dataReady("control"):
+                    msg=self.recv("control")
+                    if isinstance(msg, (producerFinished,shutdownMicroprocess)):
+                        shutdown=True
+                    self.send(msg,"signal")
 
+                raw = self.snd.getData()
+                if raw and len(raw):
+                    data = str(raw)
+                    while data:
+                        try:
+                            self.send(data,"outbox")
+                            data=None
+                        except noSpaceInBox:
+                            self.pause()
+                else:
+                    self.pause(0.01)
+                        
+            self.snd.stop()
+        except sound.SoundError, e:
+            print "**************************************************************"
+            print "WARNING: Due to a bug in PYMEDIA, Audio input is shutting down"
+            print "ERROR: ",e
+            print "**************************************************************"
+            shutdown = True
 
+
 __kamaelia_components__ = ( Input, )

Index: Kamaelia/Util/PureTransformer.py
===================================================================
--- Kamaelia/Util/PureTransformer.py	(revision 3562)
+++ Kamaelia/Util/PureTransformer.py	(revision 5910)
@@ -45,19 +45,24 @@
 from Axon.Ipc import producerFinished,shutdownMicroprocess,shutdown
 
 class PureTransformer(component):
-    def __init__(self, function=None):
-        super(PureTransformer, self).__init__()
+    catch_excepts = False
+    def __init__(self, function=None, **argd):
+        super(PureTransformer, self).__init__(**argd)
         if function:
             self.processMessage = function

     def processMessage(self, msg):
         pass

     def main(self):
         while 1:
             yield 1
             while self.dataReady("inbox"):
-                returnval = self.processMessage(self.recv("inbox"))
+                try:
+                    returnval = self.processMessage(self.recv("inbox"))
+                except:
+                    if not self.catch_excepts:
+                        raise
                 if returnval != None:
                     self.send(returnval, "outbox")
             while self.dataReady("control"):

Index: Kamaelia/Util/NullSink.py
===================================================================
--- Kamaelia/Util/NullSink.py	(revision 3562)
+++ Kamaelia/Util/NullSink.py	(revision 5910)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python2.3
 #
-# (C) 2004 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2004 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -27,9 +27,6 @@
 from Axon.Component import component, scheduler
 from Axon.Ipc import producerFinished, shutdownMicroprocess
 class nullSinkComponent(component):
-   Inboxes=["inbox","control"]
-   Outboxes=[]
-
    def mainBody(self):
       while self.dataReady("inbox"):
          data = self.recv("inbox")

Index: Kamaelia/Util/RateFilter.py
===================================================================
--- Kamaelia/Util/RateFilter.py	(revision 3562)
+++ Kamaelia/Util/RateFilter.py	(revision 5910)
@@ -242,10 +242,10 @@
     Outboxes = { "outbox" : "Items/messages limited to specified maximum output rate",
                  "signal" : "NOT USED",
                }
-    
-    def __init__(self, messages_per_second, buffer=60):
+    hardlimit = 0
+    def __init__(self, messages_per_second, buffer=60, **argd):
         """x.__init__(...) initializes x; see x.__class__.__doc__ for signature"""
-        super(MessageRateLimit, self).__init__()
+        super(MessageRateLimit, self).__init__(**argd)
         self.mps = messages_per_second
         self.interval = 1.0/(messages_per_second*1.1)
         self.buffer = buffer
@@ -266,6 +266,8 @@
         last = start
         interval = self.interval # approximate rate interval
         mps = self.mps
+        if self.hardlimit:
+            self.setInboxSize("inbox", self.hardlimit)
         while 1:
             try:
                 while not( self.scheduler.time - last > interval):

Index: Kamaelia/Util/Console.py
===================================================================
--- Kamaelia/Util/Console.py	(revision 3562)
+++ Kamaelia/Util/Console.py	(revision 5910)
@@ -1,6 +1,6 @@
 #!/usr/bin/env python2.3
 #
-# (C) 2005 British Broadcasting Corporation and Kamaelia Contributors(1)
+# Copyright (C) 2005 British Broadcasting Corporation and Kamaelia Contributors(1)
 #     All Rights Reserved.
 #
 # You may only modify and redistribute this under the terms of any of the
@@ -59,7 +59,8 @@
 the str() builtin function to convert them to strings suitable for display.
 
 However, if the 'use_repr' argument is set to True during initialization, then
-repr() will be used instead of str().
+repr() will be used instead of str(). Similarly if a "tag" is provided it's
+prepended before the data.
 
 If the 'forwarder' argument is set to True during initialisation, then whatever
 is received is not only displayed, but also set on to the "outbox" outbox
@@ -104,16 +105,23 @@
 
    def main(self):
       """Main thread loop."""
-      while 1:
-         line = raw_input(self.prompt)
-         line = line + self.eol
-         self.send(line, "outbox")
+      while not self.shutdown():       # XXXX: NOTE We check self.shutdown *AFTER* waiting for input, meaning
+         line = raw_input(self.prompt) # XXXX: NOTE the last line *will* be read. This is probably good
+         line = line + self.eol        # XXXX: NOTE  motivation at some point for moving away from using
+         self.send(line, "outbox")     # XXXX: NOTE  raw_input.
 
+   def shutdown(self):
+       while self.dataReady("control"):
+           data = self.recv("control")
+           if isinstance(data, producerFinished) or isinstance(data, shutdownMicroprocess):
+               self.send(data,"signal")
+               return True
+       return 0
 
 
 class ConsoleEchoer(component):
    """\
-   ConsoleEchoer([forwarder][,use_repr]) -> new ConsoleEchoer component.
+   ConsoleEchoer([forwarder][,use_repr][,tag]) -> new ConsoleEchoer component.
 
    A component that outputs anything it is sent to standard output (the
    console).
@@ -122,6 +130,7 @@
    
    - forwarder  -- incoming data is also forwarded to "outbox" outbox if True (default=False)
    - use_repr   -- use repr() instead of str() if True (default=False)
+   - tag -- Pre-pend this text tag before the data to emit
    """
    Inboxes  = { "inbox"   : "Stuff that will be echoed to standard output",
                 "control" : "Shutdown signalling",
@@ -130,7 +139,7 @@
                 "signal" : "Shutdown signalling",
               }
 
-   def __init__(self, forwarder=False, use_repr=False):
+   def __init__(self, forwarder=False, use_repr=False, tag=""):
       """x.__init__(...) initializes x; see x.__class__.__doc__ for signature"""
       super(ConsoleEchoer, self).__init__()
       self.forwarder=forwarder
@@ -138,13 +147,14 @@
           self.serialise = repr
       else:
           self.serialise = str
+      self.tag = tag
 
    def main(self):
       """Main loop body."""
       while not self.shutdown():
           while self.dataReady("inbox"):
               data = self.recv("inbox")
-              _sys.stdout.write(self.serialise(data))
+              _sys.stdout.write(self.tag + self.serialise(data))
               _sys.stdout.flush()
               if self.forwarder:
                   self.send(data, "outbox")

Index: Kamaelia/UI/Pygame/Text.py
===================================================================
--- Kamaelia/UI/Pygame/Text.py	(revision 0)
+++ Kamaelia/UI/Pygame/Text.py	(revision 5910)
@@ -0,0 +1,321 @@
+#!/usr/bin/env python
+#
+# Copyright (C) 2007 British Broadcasting Corporation and Kamaelia Contributors(1)
+#     All Rights Reserved.
+#
+# You may only modify and redistribute this under the terms of any of the
+# following licenses(2): Mozilla Public License, V1.1, GNU General
+# Public License, V2.0, GNU Lesser General Public License, V2.1
+#
+# (1) Kamaelia Contributors are listed in the AUTHORS file and at
+#     http://kamaelia.sourceforge.net/AUTHORS - please extend this file,
+#     not this notice.
+# (2) Reproduced in the COPYING file, and at:
+#     http://kamaelia.sourceforge.net/COPYING
+# Under section 3.5 of the MPL, we are using this text since we deem the MPL
+# notice inappropriate for this file. As per MPL/GPL/LGPL removal of this
+# notice is prohibited.
+#
+# Please contact us via: kamaelia-list-owner@lists.sourceforge.net
+# to discuss alternative licensing.
+# -------------------------------------------------------------------------
+#
+
+"""
+============================================
+Pygame components for text input and display
+============================================
+
+TextDisplayer displays any data it receives on a Pygame surface. Every new piece
+of data is displayed on its own line, and lines wrap automatically.
+
+Textbox displays user input while the user types, and sends its string buffer
+to its 'outbox' when it receives a '\n'.
+
+
+
+Example Usage
+-------------
+
+To take user input in Textbox and display it in TextDisplayer::
+
+    Pipeline(Textbox(screen_width = 800,
+                     screen_height = 300,
+                     position = (0,0)),
+             TextDisplayer(screen_width = 800,
+                           screen_height = 300,
+                           position = (0,340))
+             ).run()
+
+
+
+How does it work? 
+-----------------
+TextDisplayer requests a display from the Pygame Display service and requests
+that Pygame Display send all keypresses to it. Everytime TextDisplayer receives
+a keypress, it updates its string buffer and the display. 
+
+If it receives a newline, or if text must wrap, it moves the existing text
+upwards and blits the new line onto the bottom. 
+
+
+
+Known issues
+------------
+The line wrapping length is specified by the width of the display divided by the
+width of the letter 'a' in the displayed font, so lines may wrap too far off the
+edge of the screen if the user types very narrow text (i.e. just spaces with no
+other charachters), or too far inside the edge of the screen (usually).
+"""
+
+import pygame
+import time
+from Kamaelia.UI.Pygame.Display import PygameDisplay
+from Kamaelia.UI.Pygame.KeyEvent import KeyEvent
+from Axon.Component import component
+from Axon.Ipc import shutdownMicroprocess, producerFinished, WaitComplete
+from pygame.locals import *
+
+    
+class TextDisplayer(component):
+    """\
+    TextDisplayer(...) -> new TextDisplayer Pygame component.
+
+    Keyword arguments:
+
+    - screen_width     -- width of the TextDisplayer surface, in pixels.
+                          Default 500.
+    - screen_height    -- height of the TextDisplayer surface, in pixels.
+                          Default 300.
+    - text_height      -- font size. Default 18.
+    - background_color -- tuple containing RGB values for the background color.
+                          Default is a pale yellow.
+    - text_color       -- tuple containing RGB values for the text color.
+                          Default is black.
+    - position         -- tuple containing x,y coordinates of the surface's
+                          upper left corner in relation to the Pygame
+                          window. Default (0,0)
+    """
+    Inboxes = {"inbox" : "for incoming lines of text",
+               "_surface" : "for PygameDisplay to send surfaces to",
+               "_quitevents" : "user-generated quit events",
+               "control" : "shutdown handling"}
+    
+    Outboxes = {"outbox" : "not used",
+                "_pygame" : "for sending requests to PygameDisplay",
+                "signal" : "propagates out shutdown signals"}
+    
+    def __init__(self, screen_width=500, screen_height=300, text_height=18,
+                 background_color = (255,255,200), text_color=(0,0,0), position=(0,0),
+                 margin=10):
+        """Initialises"""
+        super(TextDisplayer, self).__init__()
+        self.screen_width = screen_width
+        self.textbox_width = screen_width -margin*2
+        self.screen_height = screen_height
+        self.textbox_height = screen_height-margin*2
+        self.text_height = text_height
+        self.background_color = background_color
+        self.text_color = text_color
+        self.position = position
+        self.textbox_position = position[0]+margin, position[1]+margin
+        self.margin = margin
+        self.done = False
+        
+    def initPygame(self, **argd):
+        """requests a display surface from the PygameDisplay service, fills
+        the color in, and copies it"""
+        displayservice = PygameDisplay.getDisplayService()
+        self.link((self, "_pygame"), displayservice)
+        self.send(argd, "_pygame")
+        while not self.dataReady("_surface"):
+            yield 1
+        self.screen = self.recv("_surface")
+        self.screen.fill(self.background_color)
+        self.scratch = self.screen.copy()
+        self.send({"REDRAW" : True,
+                   "surface" : self.screen}, "_pygame")
+        yield 1
+
+        h = self.screen_height
+        h = self.textbox_height
+        w = self.screen_width
+        w = self.textbox_width
+        th = self.text_height
+        self.font = pygame.font.Font(None, th)
+        M = self.margin
+        self.linelen = self.textbox_width/self.font.size('a')[0]
+        self.keepRect = pygame.Rect((M, th+M),(w, h - th))
+        self.scrollingRect = pygame.Rect((M, M), (w, h - th))
+        self.writeRect = pygame.Rect((M, h - th+M), (w, th))
+
+    def main(self):
+        """Main loop"""
+        yield WaitComplete(self.initPygame(DISPLAYREQUEST = True,
+                                           size = (self.screen_width, self.screen_height),
+                                           callback = (self, '_surface'),
+                                           position = self.position))
+        
+        while not self.shutdown():
+            yield 1
+            if self.dataReady('inbox'):
+                line = str(self.recv('inbox'))
+                self.update(line)
+
+            if not self.anyReady():
+                self.pause()
+
+    def update(self, text):
+        """Updates text to the bottom of the screen while scrolling old text
+        upwards. Delegates most of the work to updateLine"""
+        while len(text) > self.linelen:
+            cutoff = text.rfind(' ', 0, self.linelen)
+            if cutoff == -1:
+                cutoff = self.linelen
+            self.updateLine(text[0:cutoff])
+            text = text[cutoff + 1:]
+        self.updateLine(text)
+            
+    def updateLine(self, line):
+        """Updates one line of text to bottom of screen, scrolling old text upwards."""
+        line = line.replace('\r', ' ')
+        line = line.replace('\n', ' ')
+        lineSurf = self.font.render(line, True, self.text_color)    
+        self.screen.fill(self.background_color)
+        self.screen.blit(self.scratch, self.scrollingRect, self.keepRect)
+        self.screen.blit(lineSurf, self.writeRect)
+        self.scratch.fill(self.background_color)
+        self.scratch.blit(self.screen, self.screen.get_rect())
+        self.send({"REDRAW" : True,
+                   "surface" : self.screen}, "_pygame")
+
+    def shutdown(self): # TODO: Confusingly named. it seems that this initiates a shutdown, whereas it just monitors for one.
+        """Checks for control messages"""
+        while self.dataReady("control"):
+            msg = self.recv("control")
+            if isinstance(msg, producerFinished) or isinstance(msg, shutdownMicroprocess):
+                self.done = True
+        if self.dataReady("_quitevents"):
+            self.done = True
+        if self.done:
+            self.send(shutdownMicroprocess(), 'signal')
+            return True
+            
+
+class Textbox(TextDisplayer):
+    """\
+    Textbox(...) -> New Pygame Textbox component
+
+    Keyword Arguments:
+    - Textbox inherits its keyword arguments from TextDisplayer. Please see
+      TextDisplayer docs.
+
+    Reads keyboard input and updates it on the screen. Flushes string buffer and
+    sends it to outbox when a newline is encountered.
+
+    """
+    
+    Inboxes = {"inbox" : "for incoming lines of text",
+               "_surface" : "for PygameDisplay to send surfaces to",
+               "_quitevents" : "user-generated quit events",
+               "_events" : "key events",
+               "control" : "shutdown handling"}
+    
+    Outboxes = {"outbox" : "not used",
+                "_pygame" : "for sending requests to PygameDisplay",
+                "signal" : "propagates out shutdown signals"}
+
+    string_buffer = ""
+    def setText(self, text):
+        """erases the screen and updates it with text"""
+        self.screen.fill(self.background_color)
+        self.scratch.fill(self.background_color)
+        self.update(text)
+
+    def main(self):
+        """\
+        Requests a surface from PygameDisplay and registers to listen for events.
+        Then enters the main loop, which checks for Pygame events and updates
+        them to the screen.
+        """
+        yield WaitComplete(self.initPygame(DISPLAYREQUEST = True,
+                                 size = (self.screen_width, self.screen_height),
+                                 callback = (self, '_surface'),
+                                 position = self.position,
+                                 events = (self, "_events")))
+
+        self.send({'ADDLISTENEVENT' : pygame.KEYDOWN,
+                   'surface' : self.screen
+                   }
+                  , '_pygame')
+        
+        string_buffer = self.string_buffer
+        self.setText(string_buffer + '|')
+        while not self.shutdown():
+            yield 1
+            while self.dataReady('_events'):
+                for event in self.recv('_events'):
+                    char = event.unicode
+                    if char == '\n' or char == '\r':
+                        self.send(string_buffer)
+                        string_buffer = ''
+                    elif event.key == K_BACKSPACE:
+                        string_buffer = string_buffer[:len(string_buffer)-1]
+                    elif event.key == K_ESCAPE:
+                        self.done = True
+                    else:
+                        string_buffer += char
+                    self.setText(string_buffer + '|')
+                    self.string_buffer = string_buffer
+
+            if not self.anyReady():
+                self.pause()
+
+__kamaelia_components__ = (TextDisplayer, Textbox, )
+
+if __name__ == '__main__':
+    from Kamaelia.Chassis.Pipeline import Pipeline
+    from Kamaelia.Util.Console import ConsoleEchoer
+    from Kamaelia.Chassis.Graphline import Graphline
+    
+    Pipeline(Textbox(screen_width = 800,
+                     screen_height = 300,
+                     position = (0,0)),
+             TextDisplayer(screen_width = 800,
+                           screen_height = 300,
+                           position = (0,340))
+             ).run()
+
+if 0: #old test just involving TextDisplayer
+    from Kamaelia.Chassis.Pipeline import Pipeline
+    from Kamaelia.Chassis.Graphline import Graphline
+    from Kamaelia.Util.Console import ConsoleReader
+    import time
+    #the long lines are there on purpose, to see if the component wraps text correctly.
+    text =  """\
+To be, or not to be: that is the question:
+Whether 'tis nobler in the mind to suffer
+The slings and arrows of outrageous fortune,
+Or to take arms against a sea of troubles,
+And by opposing end them? To die: to sleep;
+No more; and by a sleep to say we end
+The heart-ache and the thousand natural shocks That flesh is heir to, 'tis a consummation Devoutly to be wish'd. To die, to sleep;
+To sleep: perchance to dream: ay, there's the rub;
+For in that sleep of death what dreams may come
+When we have shuffled off this mortal coil,
+Must give us pause: there's the respect
+That makes calamity of so long life;
+"""
+
+    class Chargen(component):
+        def main(self):
+            lines = text.split('\n')
+            for one_line in lines:
+                time.sleep(0.5)
+                self.send(one_line)
+                print one_line
+                yield 1
+##            self.send(producerFinished(), 'signal')
+
+    Pipeline(ConsoleReader('>>>'), TextDisplayer()).run()
+    

Index: Examples/Filehandling/SimpleReading.py
===================================================================
--- Examples/Filehandling/SimpleReading.py	(revision 0)
+++ Examples/Filehandling/SimpleReading.py	(revision 5910)
@@ -0,0 +1,25 @@
+#!/usr/bin/python
+
+from Kamaelia.Util.Console import *
+from Kamaelia.Chassis.Pipeline import Pipeline
+from Kamaelia.File.Reading import SimpleReader
+from Kamaelia.Util.RateFilter import MessageRateLimit
+
+Pipeline(
+    SimpleReader("/etc/fstab"),
+    ConsoleEchoer(),
+).run()
+
+
+Pipeline(
+    SimpleReader("/etc/fstab"),
+    MessageRateLimit(2,1,hardlimit=0),
+    ConsoleEchoer(),
+).run()
+
+Pipeline(
+    SimpleReader("/etc/fstab"),
+    MessageRateLimit(0.5,1,hardlimit=1),
+    ConsoleEchoer(),
+).run()
+

Index: Examples/SimpleGraphicalApps/KidsProgramming/SimpleLogoInterpreter.py
===================================================================
--- Examples/SimpleGraphicalApps/KidsProgramming/SimpleLogoInterpreter.py	(revision 0)
+++ Examples/SimpleGraphicalApps/KidsProgramming/SimpleLogoInterpreter.py	(revision 5910)
@@ -0,0 +1,287 @@
+#!/usr/bin/env python
+##
+## Copyright (C) 2007 British Broadcasting Corporation and Kamaelia Contributors(1)
+##     All Rights Reserved.
+##
+import Axon
+import pygame
+from Axon.Ipc import WaitComplete
+from Kamaelia.UI.GraphicDisplay import PygameDisplay
+from Kamaelia.UI.Pygame.Text import TextDisplayer, Textbox
+from Kamaelia.Chassis.Pipeline import Pipeline
+from Kamaelia.Chassis.Graphline import Graphline
+from Kamaelia.Util.Backplane import *
+from Kamaelia.Visualisation.PhysicsGraph.lines_to_tokenlists import lines_to_tokenlists as text_to_tokenlists
+from Kamaelia.UI.Pygame.Image import Image
+
+import Actions
+
+class PygameComponent(Axon.Component.component):
+   """
+   Borrows ideas from Kamaelia.UI.MH.PyGameApp.PyGameApp & mainly from Ticker
+   """
+   Inboxes = { "inbox"        : "Specify (new) filename",
+               "display_control"      : "Shutdown messages & feedback from Pygame Display service",
+               "alphacontrol" : "Transparency of the ticker (0=fully transparent, 255=fully opaque)",
+               "control" : "...",
+               "events" : "...."
+             }
+   Outboxes = { "outbox" : "NOT USED",
+                "signal" : "",
+                "displaysignal" : "Shutdown signalling & sending requests to Pygame Display service",
+              }
+   configuration = {
+      "transparency" : "Colour to be made transparent. None == no colour transparent",
+   }
+   transparency = None
+   background = 0xffffff
+   surfacesize = (1024, 768)
+   surfaceposition=(0,0)
+   onlymouseinside = False
+   def __init__(self, **argd):
+       super(PygameComponent,self).__init__(**argd)
+       self.eventHandlers = {}
+
+   def waitBox(self,boxname):
+      """Generator. yields 1 until data ready on the named inbox."""
+      while True:
+         if self.dataReady(boxname): return
+         else: yield 1
+
+   def flip(self):
+       self.send({"REDRAW":True, "surface":self.display}, "displaysignal")
+
+   def requestDisplay(self, **argd):
+      """\
+      Generator. Gets a display surface from the Pygame Display service.
+
+      Makes the request, then yields 1 until a display surface is returned.
+      """
+      displayservice = PygameDisplay.getDisplayService()
+      self.link((self,"displaysignal"), displayservice)
+      self.send(argd, "displaysignal")
+      for _ in self.waitBox("display_control"): yield 1
+      display = self.recv("display_control")
+      self.display = display
+
+   def handleAlpha(self):
+       if self.dataReady("alphacontrol"):
+            alpha = self.recv("alphacontrol")
+            self.display.set_alpha(alpha)
+
+   def doRequestDisplay(self):
+        return WaitComplete(
+                 self.requestDisplay(DISPLAYREQUEST=True,
+                                     callback = (self,"display_control"),
+                                     events = (self, "events"),
+                                     size = self.surfacesize,
+                                     transparency = self.transparency,
+                                     position = self.surfaceposition,
+                                     onlymouseinside = self.onlymouseinside, ### Tempted to do events depth instead
+                 )
+               )
+
+   def clearDisplay(self):
+       """Clears the ticker of any existing text."""
+       self.display.fill(self.background)
+
+   def addHandler(self, eventtype, handler):
+        """\
+        Add an event handler, for a given PyGame event type.
+
+        The handler is passed the pygame event object as its argument when called.
+        """
+        if not self.eventHandlers.has_key(eventtype):
+            self.eventHandlers[eventtype] = []
+            self.send({ "ADDLISTENEVENT" : eventtype,
+                        "surface" : self.display,
+                      }, "displaysignal")
+        self.eventHandlers[eventtype] += [handler]
+        return handler
+
+   def removeHandler(self, eventtype, handler):
+       """Remove the specified pygame event handler from the specified event."""
+       if self.eventHandlers.has_key(eventtype):
+           try:
+               self.eventHandlers[eventtype].remove(handler) # Latent bugs in application will cause an error here
+           except ValueError:
+               pass
+           if len(self.eventHandlers[eventtype]) == 0:
+               print "NO HANDLER LEFT"
+
+   def events(self):
+       """Generator. Receive events on "events" inbox and yield then one at a time."""
+       while self.dataReady("events"):
+          event_bundle = self.recv("events")
+          for event in event_bundle:
+             yield event
+
+   def _dispatch(self):
+        """\
+        Internal pygame event dispatcher.
+        For all events received, it calls all event handlers in sequence
+        until one returns True.
+        """
+        for event in self.events():
+            if self.eventHandlers.has_key(event.type):
+                for handler in self.eventHandlers[event.type]:
+                    if handler(event):
+                        break
+
+
+
+class DrawingCanvas(PygameComponent):
+    background = 0x820046
+    surfacesize = (400, 610)
+    surfaceposition=(550,20)
+    x = 200
+    y = 200
+    orientation = 0
+    width = 1
+    colour = (0,0,0)
+    def redraw(self):
+        self.clearDisplay()
+        self.flip()
+    def main(self):
+        """Main loop."""
+        yield self.doRequestDisplay()
+        self.redraw()
+        yield 1
+        while 1:
+            while not self.anyReady():
+                self.pause()
+                yield 1
+            while self.dataReady("inbox"):
+                self.dirty = False
+                d = self.recv("inbox")
+                reload(Actions)
+                if (not isinstance(d, list)) and (not len(d)>0):
+                    continue
+                for command,handler in Actions.actions:
+                    if d[0] == command:
+                        handler(self, *d[1:])
+                if self.dirty:
+                    self.flip()
+                yield 1
+                
+class Memory(Axon.Component.component):
+    Outboxes = [
+        "outbox",
+        "signal",
+        "toconsole",   
+    ]
+    recording = False
+    def __init__(self, **argd):
+        super(Memory, self).__init__(**argd)
+        self.noting = None
+        self.notes = {}
+        self.contextactions = [self.doCommand]
+        self.commands = {
+            "to": self.start_recording,
+            "end": self.stop_recording,
+        }
+        
+    def sleep(self):
+        while not self.anyReady():
+            self.pause()
+            yield 1
+
+    def main(self):
+        while 1:
+            yield WaitComplete(self.sleep())
+            for d in self.Inbox("inbox"):
+                try:
+                    command = self.commands.get(d[0])
+                except KeyError:
+                    pass
+                if command:
+                    command(d[1:])
+                else:
+                    (self.contextactions[-1])(d)
+
+    def doCommand(self,d):
+        if d[0] in self.notes:
+            for command in self.notes[d[0]]:
+                self.send(command, "outbox")
+        else:
+            self.send(d, "outbox")
+
+    def start_recording(self, d):
+        if len(d) != 1:
+            return
+        print "recording", d[0]
+        self.noting = d[0]
+        self.notes[self.noting] = []
+        self.contextactions.append(self.note)
+        self.recording = True
+
+    def stop_recording(self, d):
+        print "stopping recording", self.noting
+        self.noting = None
+        self.recording = False
+        self.contextactions.pop()
+        print self.notes
+
+    def note(self, d):
+        print "Noting ", self.noting, repr(d)
+        self.notes[self.noting].append(d)
+        print self.notes
+            
+if __name__ == '__main__':
+    Backplane("RAWINPUT").activate()
+    Backplane("PARSEDINPUT").activate()
+    Backplane("DISPLAYCONSOLE").activate()
+
+
+    Image(image="kamaelia_logo.png",
+          bgcolour=(255,255,255),
+          position=(20, 20),
+          size = (64,64),
+          maxpect = (64,64),
+          ).activate()
+    
+    Graphline(
+        RAW = SubscribeTo("RAWINPUT"),
+        PARSER = text_to_tokenlists(),
+        MEM = Memory(),
+        PARSED = PublishTo("PARSEDINPUT"),
+        linkages = {
+            ("RAW","outbox"): ("PARSER","inbox"),
+            ("PARSER","outbox"): ("MEM","inbox"),
+            ("MEM","outbox"): ("PARSED","inbox"),
+
+            ("RAW","signal"): ("PARSER","control"),
+            ("PARSER","signal"): ("MEM","control"),
+            ("MEM","signal"): ("PARSED","control"),
+            
+        }
+    ).activate()
+
+    
+    Pipeline(
+        SubscribeTo("RAWINPUT"),
+        PublishTo("DISPLAYCONSOLE"),
+    ).activate()
+    
+    Pipeline(
+        SubscribeTo("PARSEDINPUT"),
+        DrawingCanvas(background = 0xD0D0D0, # Grey!
+                      surfacesize = (570, 650),
+                      surfaceposition=(430,90)),
+        ).activate()
+
+    Pipeline(Textbox(position=(20, 430),
+                     size = (392,310),
+                     text_height=36,
+                     background_color=(130,0,70),
+                     text_color=(255,255,255)),
+             PublishTo("RAWINPUT"),
+    ).activate()
+
+    Pipeline(SubscribeTo("DISPLAYCONSOLE"),
+             TextDisplayer(position=(20, 90),
+                     size = (392,320),
+                           text_height=36,
+                           background_color=(130,0,70),
+                           text_color=(255,255,255))
+    ).run()

Index: Examples/SimpleGraphicalApps/KidsProgramming/Actions.py
===================================================================
--- Examples/SimpleGraphicalApps/KidsProgramming/Actions.py	(revision 0)
+++ Examples/SimpleGraphicalApps/KidsProgramming/Actions.py	(revision 5910)
@@ -0,0 +1,57 @@
+
+print "loading Actions"
+import pygame
+
+def main(x):
+   print x
+
+def pink(self,*args):
+    self.background = 0xF6D0D2
+    self.redraw()
+
+def blue(self,*args):
+    self.background = 0xD2D0F6
+    self.redraw()
+
+def foo(self,*args):
+    pygame.draw.line(self.display, (0,0,0), (self.x-5,self.y),(self.x+5,self.y),self.width)
+    pygame.draw.line(self.display, (0,0,0), (self.x+5,self.y),(self.x,self.y+20),self.width)
+    pygame.draw.line(self.display, (0,0,0), (self.x, self.y+20),(self.x-5,self.y),self.width)
+    self.dirty = True
+
+def move(self, *args):
+    if len(args) == 2:
+        P = [ int(x) for x in args ]
+        self.x = P[0]
+        self.y = P[1]
+        foo(self)
+
+def line(self, *args):
+    if len(args) == 4:
+        P = [ int(x) for x in args ]
+        pygame.draw.line(self.display, self.colour, (P[0],P[1]),(P[2],P[3]),self.width)
+        self.dirty = True
+    else:
+        print "Hmm", repr(args)
+
+def setwidth(self, *args):
+    if len(args) == 1:
+        self.width = int(args[0])
+
+def setcolour(self, *args):
+    if len(args) == 3:
+        self.colour = [ int(x) for x in args ]
+
+def quit(self,*args):
+    print self.scheduler.stop()
+
+actions = [
+   ("pink", pink),
+   ("blue", blue),
+   ("foo", foo),
+   ("move", move),
+   ("line", line),
+   ("quit", quit),
+   ("colour", setcolour),
+   ("width", setwidth),
+]

Index: Examples/SimpleGraphicalApps/KidsProgramming/kamaelia_logo.png
===================================================================
Cannot display: file marked as a binary type.
svn:mime-type = application/octet-stream

